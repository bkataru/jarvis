This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
.husky/
  pre-commit
public/
  .htaccess
  favicon.svg
scripts/
  serverProd.mjs
  updateVersion.mjs
src/
  ai/
    agentContext/
      AgentContext.ts
      AgentContextProvider.tsx
      constants.ts
      useAgent.ts
    imageToText/
      constants.ts
      ImageToText.ts
      imageToTextWorker.ts
      types.ts
    llm/
      textGeneration/
        languageModel/
          worker/
            utils/
              CausalLMPipeline.ts
              getLanguageModelAvailability.ts
              isFileInCache.ts
              KVCache.ts
              prompt.ts
              WorkerError.ts
            types.ts
          TransformersJsModel.ts
          webWorkerHandler.ts
          worker.ts
        constants.ts
        index.ts
        TextGeneration.ts
      utils/
        toolsToSystemPrompt.ts
      Conversation.ts
      ConversationGemini.ts
      worker.ts
    mcp/
      auth/
        browser-provider.ts
        callback.ts
        readme.txt
        types.ts
      mcpServers/
        builtinMcp.ts
        MemoriesServer.ts
        TakePictureServer.ts
      react/
        McpServerContext.ts
        McpServerContextProvider.tsx
        types.ts
        useMcpServer.ts
      utils/
        mcpServerStore.ts
      HttpTransport.ts
      McpServer.ts
      PromiseTransport.ts
      types.ts
    speechToText/
      constants.ts
      SpeechToText.ts
      types.ts
      worker.ts
    textToSpeech/
      kokoro/
        constants.ts
        Kokoro.ts
        phonemize.ts
        SequentialAudioPlayer.ts
        types.ts
        voices.ts
        worker.ts
      types.ts
    voiceActivityDetection/
      constants.ts
      types.ts
      vad-processor.ts
      VoiceActivityDetection.ts
      worker.ts
    agent.ts
    types.ts
  pages/
    ChatPage.tsx
    McpPage.tsx
    OAuthCallbackPage.tsx
  theme/
    button/
      Button.tsx
    form/
      Checkbox.tsx
      FormField.tsx
      InputText.tsx
      RadioGroup.tsx
      Select.tsx
      Textarea.tsx
      types.ts
    jarvis/
      Crosshair.tsx
    misc/
      Dot.tsx
      Loader.tsx
      LoadingDots.tsx
      McpIcon.tsx
      Message.tsx
      Progress.tsx
    modal/
      Modal.tsx
    page/
      Background.tsx
      ContentBox.tsx
      PageContent.tsx
    index.ts
  ui/
    chat/
      Chat.tsx
      Message.tsx
    jarvis/
      Jarvis.tsx
      Rings.tsx
      ToolCallPopup.tsx
    mcp/
      components/
        McpPrompts.tsx
        McpResources.tsx
        McpServerHeader.tsx
        McpTools.tsx
      AddHttpServer.tsx
      CallTool.tsx
      McpOverview.tsx
      TakePictureModal.tsx
    DownLoadDisclaimer.tsx
  utils/
    classnames.ts
    constants.ts
    eventEmitter.ts
    extractFunctionCall.ts
    extractSentences.ts
    formatBytes.ts
    isFileInCache.ts
    isFullSentence.ts
    isFullXMLToolCall.ts
    LocalStorage.ts
    nl2brJsx.tsx
    useExternalState.ts
    useStableValue.ts
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.env.example
.gitignore
index.html
LICENSE
package.json
README.md
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/deploy.yml">
name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Clean and install dependencies
        run: |
          rm -rf package-lock.json node_modules
          npm install

      - name: Build production
        run: npm run build

      - name: Upload to FTP
        uses: SamKirkland/FTP-Deploy-Action@v4.3.5
        with:
          server: ${{ secrets.FTP_SERVER }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          local-dir: ./dist/
          server-dir: ./
          exclude: |
            **/.git*
            **/.git*/**
            **/node_modules/**
</file>

<file path=".husky/pre-commit">
node scripts/updateVersion.mjs patch
git add package.json
</file>

<file path="public/.htaccess">
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /

  # Don't rewrite existing files or directories
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d

  # Redirect everything else to index.html
  RewriteRule ^ index.html [QSA,L]
</IfModule>
</file>

<file path="public/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 128 128"><linearGradient id="a" x1="16.398" x2="16.398" y1="53.071" y2="85.571" gradientTransform="matrix(1 0 0 -1 0 128)" gradientUnits="userSpaceOnUse"><stop offset=".5" style="stop-color:#ffca28"/><stop offset="1" style="stop-color:#ffb300"/></linearGradient><path d="M26.28 62.35a38 38 0 0 1-6.08-5.66c-.95-1.05-2.83-2.78-4.69-2.62-.38.03-.87.16-1.34.51-1.27-1.64-4.2-6.04-5.66-9.92-.59-1.23-1.62-1.43-2.33-1.23-1.26.37-2.07 1.97-1.88 3.74.62 5.9 5.24 13.09 6.97 14.78l-.03.02c3.4 4.14 3.72 10.18 3.72 10.24.02.47.37.86.83.94l9.51 1.59c.06.01.11.01.17.01.42 0 .81-.27.94-.68.63-1.85 2.09-6.25 2.11-7.25.06-2.92-1.79-4.2-2.24-4.47" style="fill:url(#a)"/><linearGradient id="b" x1="111.822" x2="111.822" y1="53.071" y2="85.571" gradientTransform="matrix(1 0 0 -1 0 128)" gradientUnits="userSpaceOnUse"><stop offset=".5" style="stop-color:#ffca28"/><stop offset="1" style="stop-color:#ffb300"/></linearGradient><path d="M122.08 43.45c-.71-.22-1.77-.02-2.41 1.31-1.43 3.8-4.36 8.19-5.63 9.83a2.7 2.7 0 0 0-1.34-.51c-1.86-.16-3.74 1.57-4.7 2.63a38 38 0 0 1-6.07 5.64c-.45.27-2.3 1.54-2.24 4.48.02 1 1.48 5.41 2.11 7.25.14.41.52.68.94.68.06 0 .11 0 .17-.01l9.51-1.59a.99.99 0 0 0 .83-1.06c0-.05-.34-5.39 3.71-10.11l-.03-.02c1.73-1.68 6.2-9.03 6.98-14.77.24-1.75-.55-3.37-1.83-3.75" style="fill:url(#b)"/><linearGradient id="c" x1="64.067" x2="64.067" y1="44.571" y2="1.818" gradientTransform="matrix(1 0 0 -1 0 128)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#00bfa5"/><stop offset=".47" style="stop-color:#00b29a"/><stop offset="1" style="stop-color:#009e89"/></linearGradient><path d="M115.64 70.51a1.56 1.56 0 0 0-1.45-1.51l-12.81-.75h-.11c-.78 0-1.45.59-1.54 1.38L97.05 88.6c-4.18-3.58-9.95-6.21-17.88-6.21-2.61 0-27.58-.12-30.2-.12-7.93 0-13.7 2.63-17.88 6.21l-2.67-18.97c-.09-.79-.76-1.38-1.55-1.38h-.11l-12.81.75c-.8.06-1.42.71-1.45 1.51l-.11 40.54c-.14 7.11 5.58 12.94 12.69 12.94 4.92 0 8.86-3.69 9.46-8.31l.03.02v8.41h58.98v-8.29l.04-.02c.6 4.62 4.54 8.31 9.46 8.31 7.11 0 12.83-5.84 12.69-12.94z" style="fill:url(#c)"/><path d="M99.06 123.1a8 8 0 0 1-1.65-.97 9.8 9.8 0 0 1-1.89-1.86 9.44 9.44 0 0 1-1.91-4.59l-.02.01-.38-10.68s.63 9.15 5.85 18.09M34.93 105.01l-.38 10.59v.01c-.43 3.23-2.5 6-5.39 7.36 5.14-8.9 5.77-17.96 5.77-17.96" style="fill:#009984"/><path d="M54.92 78.33v9.98c0 4.51 3.62 8.17 9.08 8.17s9.08-3.66 9.08-8.17v-9.98zM86.49 43.78l-49.72 6.05c-5.36.65-9.18 5.86-8.48 11.57.69 5.71 5.65 9.85 11.01 9.2l49.72-6.05c5.36-.65 9.18-5.86 8.48-11.57-.69-5.71-5.65-9.85-11.01-9.2" style="fill:#e59600"/><path d="M57.28 10.99C41.44 12.92 28.84 31.63 31.81 56c2.95 24.23 19.51 34.38 34.9 32.51S95.75 72.82 92.8 48.58C89.83 24.21 73.11 9.07 57.28 10.99" style="fill:#ffca28"/><path d="M71.05 75.72c.22 2.78-2.21 3.55-5.27 3.79s-5.58-.21-5.8-2.92c-.22-2.86 2.12-4.82 5.17-5.06 3.06-.24 5.67 1.28 5.9 4.19" style="fill:#795548"/><path d="M67.1 62.41c-.1-.03-.2-.04-.3-.04l-6.44.78c-.1.02-.19.06-.28.11-.56.31-.8.95-.45 1.56s1.85 2.26 4.44 1.95c2.58-.31 3.64-2.28 3.84-2.95.19-.68-.2-1.24-.81-1.41" style="fill:#e59600"/><ellipse cx="47.55" cy="56.45" rx="4.49" ry="4.65" style="fill:#404040" transform="rotate(-6.851 47.543 56.444)"/><ellipse cx="77.32" cy="52.87" rx="4.49" ry="4.65" style="fill:#404040" transform="rotate(-6.851 77.317 52.867)"/><path d="M81.77 45c-2.7-.8-5.4-.93-8.06.15-.87.35-1.82 1.2-2.78 1.29-.69.07-1.36-.39-1.54-1.07-.16-.62.15-1.14.49-1.64 1.95-2.85 5.76-4.1 9.08-3.45 1.48.29 3.1.97 4.14 2.11.98 1.08.36 3.07-1.33 2.61M39.6 47.91c1.62-3.03 5.4-4.43 8.69-4.08 1.49.16 2.97.7 4.17 1.62.91.7 2.08 2.14.61 3.04-.93.56-2.41-.21-3.35-.37-1.35-.22-2.74-.19-4.07.1-1.36.29-2.57.83-3.76 1.53-1.26.72-3.08-.28-2.29-1.84" style="fill:#6d4c41"/><path d="M56.56 4.43h-.04c-41.69 5.2-27.47 51.83-27.47 51.83s2.46 4.69 3.57 6.76c.16.3.61.21.64-.13.42-4.09 1.94-18.6 3.04-23.09.65-2.64 3.1-4.43 5.82-4.26 4.18.25 10.8.4 17.99-.46.03 0 .05-.01.08-.01s.05-.01.08-.01c7.19-.86 13.59-2.55 17.59-3.78 2.6-.8 5.4.36 6.66 2.78 2.12 4.09 6.98 17.76 8.36 21.69.11.32.57.3.66-.03l1.9-7.37c.01 0 2.87-48.67-38.88-43.92" style="fill:#543930"/><radialGradient id="d" cx="59.756" cy="84.07" r="35.227" gradientTransform="matrix(.993 -.1184 -.1336 -1.1203 13.158 145.238)" gradientUnits="userSpaceOnUse"><stop offset=".794" style="stop-color:#6d4c41;stop-opacity:0"/><stop offset="1" style="stop-color:#6d4c41"/></radialGradient><path d="M95.45 48.35S98.32-.32 56.57 4.43h-.02a49.8 49.8 0 0 0-5.46.98c-.01 0-.02.01-.03.01l-.24.06C16.2 14.1 29.07 56.26 29.07 56.26l3.57 6.72c.16.3.6.21.64-.12.42-4.13 1.94-18.58 3.04-23.06.65-2.64 3.1-4.43 5.82-4.26 4.18.25 10.8.4 17.99-.46.03 0 .05-.01.08-.01s.05-.01.08-.01c7.19-.86 13.59-2.55 17.59-3.78 2.6-.8 5.4.36 6.66 2.78 2.13 4.11 7.02 17.88 8.38 21.74.11.32.56.3.65-.03.58-2.26 1.88-7.42 1.88-7.42" style="fill:url(#d)"/></svg>
</file>

<file path="scripts/serverProd.mjs">
#!/usr/bin/env node
import { spawn } from "child_process";
import dotenv from "dotenv";
import express from "express";
import fs from "fs";
import https from "https";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, "..");

// Load environment variables
dotenv.config({ path: path.join(projectRoot, ".env") });

const PORT = process.env.PORT || 8844;
const SSL_KEY = process.env.SSL_KEY;
const SSL_CRT = process.env.SSL_CRT;

async function buildProject() {
  console.log("üî® Building production version...");

  return new Promise((resolve, reject) => {
    const buildProcess = spawn("npm", ["run", "build"], {
      cwd: projectRoot,
      stdio: "inherit",
    });

    buildProcess.on("close", (code) => {
      if (code === 0) {
        console.log("‚úÖ Build completed successfully");
        resolve();
      } else {
        console.error("‚ùå Build failed");
        reject(new Error(`Build process exited with code ${code}`));
      }
    });

    buildProcess.on("error", (error) => {
      console.error("‚ùå Build process error:", error);
      reject(error);
    });
  });
}

async function startServer() {
  console.log("üöÄ Starting production server...");

  const app = express();

  // Serve static files from dist directory
  const distPath = path.join(projectRoot, "dist");
  app.use(express.static(distPath));

  // Handle SPA routing - serve index.html for all routes that don't match static files
  app.use((req, res, next) => {
    // Check if the request is for a file (has an extension)
    if (path.extname(req.path)) {
      // Let express.static handle file requests
      next();
    } else {
      // For all other routes, serve the index.html (SPA routing)
      res.sendFile(path.join(distPath, "index.html"));
    }
  });

  // Check if SSL certificates exist
  if (!SSL_KEY || !SSL_CRT) {
    console.error("‚ùå SSL_KEY and SSL_CRT environment variables are required");
    process.exit(1);
  }

  if (!fs.existsSync(SSL_KEY)) {
    console.error(`‚ùå SSL key file not found: ${SSL_KEY}`);
    process.exit(1);
  }

  if (!fs.existsSync(SSL_CRT)) {
    console.error(`‚ùå SSL certificate file not found: ${SSL_CRT}`);
    process.exit(1);
  }

  // Create HTTPS server
  const options = {
    key: fs.readFileSync(SSL_KEY),
    cert: fs.readFileSync(SSL_CRT),
  };

  const server = https.createServer(options, app);

  server.listen(PORT, () => {
    console.log(`‚úÖ Production server running at https://localhost:${PORT}/`);
    console.log("Press Ctrl+C to stop the server");
  });

  // Graceful shutdown
  process.on("SIGINT", () => {
    console.log("\nüëã Shutting down server...");
    server.close(() => {
      console.log("‚úÖ Server stopped");
      process.exit(0);
    });
  });
}

async function main() {
  try {
    await buildProject();
    await startServer();
  } catch (error) {
    console.error("‚ùå Error:", error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="scripts/updateVersion.mjs">
import fs from "fs/promises";
import path from "path";

const pkgPath = path.resolve(process.cwd(), "package.json");

const [, , newVersion] = process.argv;

if (!newVersion) {
  console.error("Usage: node updateVersion.mjs <version|major|minor|patch>");
  process.exit(1);
}

function incVersion(version, type) {
  let [major, minor, patch] = version.split(".").map(Number);
  switch (type) {
    case "major":
      major += 1;
      minor = 0;
      patch = 0;
      break;
    case "minor":
      minor += 1;
      patch = 0;
      break;
    case "patch":
      patch += 1;
      break;
    default:
      return type; // explicit version
  }
  return [major, minor, patch].join(".");
}

const main = async () => {
  const pkgRaw = await fs.readFile(pkgPath, "utf8");
  const pkg = JSON.parse(pkgRaw);

  let finalVersion = incVersion(pkg.version, newVersion);

  pkg.version = finalVersion;

  await fs.writeFile(pkgPath, JSON.stringify(pkg, null, 2) + "\n");
  console.log(`Updated version to ${finalVersion}`);
};

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
</file>

<file path="src/ai/agentContext/AgentContext.ts">
import { Message, ModelStatus } from "@ai/types";
import { createContext } from "preact";
import { Dispatch, StateUpdater } from "preact/hooks";

export interface DownloadModelProgress {
  vad: number;
  llm: number;
  tts: number;
  stt: number;
  vlm: number;
}

export interface AgentContextValues {
  messages: Array<Message>;
  conversationStatus: ModelStatus;
  submit: (query: string) => Promise<void>;
  isMute: boolean;
  setMute: (mute: boolean) => void;
  isDeaf: boolean;
  setDeaf: (deaf: boolean) => Promise<void>;
  isSpeaking: boolean;
  loadModels: (
    callback: (progress: DownloadModelProgress) => void
  ) => Promise<void>;
  cacheCheckDone: boolean;
  allModelsLoaded: boolean;
  onVadDetected: (callback: (text: string) => void) => () => void;
  evaluateConversation: () => void;
  jarvisActive: boolean;
  setJarvisActive: Dispatch<StateUpdater<boolean>>;
}

const AgentContext = createContext<AgentContextValues>(null);

export default AgentContext;
</file>

<file path="src/ai/agentContext/AgentContextProvider.tsx">
import { INSTRUCTIONS, SYSTEM_PROMPT } from "@ai/agent";
import ConversationGemini from "@ai/llm/ConversationGemini";
import useExternalState from "@utils/useExternalState";
import { ComponentChildren } from "preact";
import {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "preact/hooks";
import { v4 as uuidv4 } from "uuid";

import ImageToText from "../imageToText/ImageToText";
import Conversation from "../llm/Conversation";
import useMcpServer from "../mcp/react/useMcpServer";
import SpeechToText from "../speechToText/SpeechToText";
import Kokoro from "../textToSpeech/kokoro/Kokoro";
import { Message, MessagePartType, MessageRole, MessageUser } from "../types";
import VoiceActivityDetection from "../voiceActivityDetection/VoiceActivityDetection";
import { VoiceActivityDetectionStatus } from "../voiceActivityDetection/types";
import AgentContext, { DownloadModelProgress } from "./AgentContext";
import { FILL_WORDS } from "./constants";

export default function AgentContextProvider({
  children,
}: {
  children: ComponentChildren;
}) {
  const [cacheCheckDone, setCacheCheckDone] = useState<boolean>(false);
  const [allModelsLoaded, setAllModelsLoaded] = useState<boolean>(false);
  const { active: activeMcpServers } = useMcpServer();
  const [mute, setMute] = useState<boolean>(true);
  const [jarvisActive, setJarvisActive] = useState<boolean>(false);

  const [speakerAbortController, setSpeakerAbortController] = useState(
    () => new AbortController()
  );

  const speechToText = useMemo(() => new SpeechToText(), []);
  const tts = useMemo(() => new Kokoro(), []);
  const imageToText = useMemo(() => new ImageToText(), []);

  const isSpeaking = useExternalState<boolean>(
    tts.player.onIsPlayingChange,
    () => tts.player.isPlaying
  );

  const conversation = useMemo(
    () =>
      new (import.meta.env.VITE_GEMINI_API_KEY
        ? ConversationGemini
        : Conversation)({
        //onConversationEnded: () => setJarvisActive(false),
        //conversationEndKeyword: "<END>",
      }),
    []
  );

  const conversationIdRef = useRef<string>();
  const evaluateConversation = useCallback(() => {
    if (!allModelsLoaded) return;
    const conversationId = JSON.stringify([
      SYSTEM_PROMPT,
      INSTRUCTIONS,
      activeMcpServers,
    ]);

    if (conversationIdRef.current === conversationId) return;
    conversation.createConversation(
      SYSTEM_PROMPT + "\n\n# Instructions:\n\n" + INSTRUCTIONS.join("\n"),
      activeMcpServers
    );
    conversationIdRef.current = conversationId;
  }, [activeMcpServers, allModelsLoaded, conversation]);

  const messages = useExternalState<Array<Message>>(
    conversation.onMessagesChange,
    () => conversation.messages
  );

  const conversationStatus = useExternalState(
    conversation.onStatusChange,
    () => conversation.status
  );

  const processPrompt = useCallback(
    async (
      message: MessageUser,
      onTextFeedback?: (feedback: string) => void
    ): Promise<void> => {
      return conversation.processPrompt(message, onTextFeedback);
    },
    [conversation]
  );

  const submit = useCallback(
    (prompt: string) =>
      processPrompt(
        {
          id: uuidv4(),
          messageParts: [
            {
              type: MessagePartType.TEXT,
              id: uuidv4(),
              text: prompt,
            },
          ],
          role: MessageRole.USER,
        },
        (feedback) =>
          !mute && tts.speak(feedback, speakerAbortController.signal)
      ),
    [processPrompt, tts, speakerAbortController.signal, mute]
  );

  const vadListeners = useRef<Set<(text: string) => void>>(new Set());
  const onVadDetected = useCallback((callback: (text: string) => void) => {
    vadListeners.current.add(callback);
    return () => vadListeners.current.delete(callback);
  }, []);

  const vad = useMemo(() => {
    const vad = new VoiceActivityDetection();
    vad.setCallbacks({
      onSpeechChunk: (buffer, timing) => {
        timing.duration > 200 &&
          speechToText.generate(buffer).then((text) => {
            const isFillWord = FILL_WORDS.includes(text.trim().toLowerCase());
            const possibleFillWord =
              text.trim().startsWith("(") && text.trim().startsWith(")");
            if (!isFillWord && !possibleFillWord) {
              vadListeners.current.forEach((callback) => callback(text));
            }
          });
      },
    });
    return vad;
  }, [speechToText, vadListeners.current]);

  const vadStatus = useExternalState<VoiceActivityDetectionStatus>(
    vad.onStatusChange,
    () => vad.status
  );

  const loadModels = useCallback(
    (callback: (progress: DownloadModelProgress) => void = () => {}) =>
      new Promise<void>(async (resolve) => {
        const loaded: DownloadModelProgress = {
          vad: 0,
          llm: 0,
          tts: 0,
          stt: 0,
          vlm: 0,
        };

        const listener = (model: string, progress: number) => {
          loaded[model as keyof DownloadModelProgress] = progress;
          callback({ ...loaded });
        };

        await Promise.all([
          vad.preload((progress) => listener("vad", progress)),
          speechToText.preload((progress) => listener("stt", progress)),
          tts.preload((progress) => listener("tts", progress)),
          conversation.createConversation(
            "",
            [],
            (progress) => listener("llm", Math.round(progress * 100)),
            false,
            false,
            true
          ),
          imageToText.preload((progress) => listener("vlm", progress)),
        ]);
        setAllModelsLoaded(true);
        resolve();
      }),
    [vad, speechToText, tts, conversation, imageToText]
  );

  useEffect(() => {
    (async () => {
      const [vadCached, sttCached, ttsCached, llmCached, vlmCached] =
        await Promise.all([
          vad.isCached(),
          speechToText.isCached(),
          tts.isCached(),
          conversation.isCached(),
          imageToText.isCached(),
        ]);
      if (vadCached && sttCached && ttsCached && llmCached && vlmCached) {
        await loadModels();
      }
      setCacheCheckDone(true);
    })();
  }, []);

  return (
    <AgentContext
      value={{
        messages,
        conversationStatus,
        submit,
        isMute: mute,
        setMute: (mute) => {
          setMute(mute);
          if (mute) {
            speakerAbortController.abort();
            setSpeakerAbortController(new AbortController());
          }
        },
        isDeaf: vadStatus === VoiceActivityDetectionStatus.IDLE,
        setDeaf: async (deaf) =>
          deaf ? vad.stopMicrophone() : await vad.startMicrophone(),
        isSpeaking,
        loadModels,
        cacheCheckDone,
        allModelsLoaded,
        onVadDetected,
        evaluateConversation,
        jarvisActive,
        setJarvisActive,
      }}
    >
      {children}
    </AgentContext>
  );
}
</file>

<file path="src/ai/agentContext/constants.ts">
export const FILL_WORDS = [
  // Non-speech sounds
  "(laughs)",
  "(laughter)",
  "(chuckles)",
  "(coughs)",
  "(clears throat)",
  "(sighs)",
  "(sniffs)",
  "(breathing)",
  "(inhales)",
  "(exhales)",
  "(applause)",
  "(music)",
  "(silence)",
  "(wooshing)",

  // Whisper-specific artifacts
  "[BLANK_AUDIO]",
  "[Music]",
  "[Applause]",
  "[Laughter]",
  "[Silence]",
  "[Inaudible]",
  "[Background noise]",
].map((s) => s.toLowerCase());
</file>

<file path="src/ai/agentContext/useAgent.ts">
import { useContext } from "preact/hooks";

import AgentContext from "./AgentContext";

function useAgent() {
  const context = useContext(AgentContext);
  if (!context) {
    throw new Error("useAgent must be used within a AgentContextProvider");
  }
  return context;
}

export default useAgent;
</file>

<file path="src/ai/imageToText/constants.ts">
export const MODEL_ID = "HuggingFaceTB/SmolVLM-256M-Instruct";
export const MODEL_ONNX_URL_BASE = `https://huggingface.co/${MODEL_ID}/resolve/main/`;

export const EXPECTED_FILES = {
  "preprocessor_config.json": 486,
  "config.json": 7353,
  "processor_config.json": 68,
  "tokenizer.json": 3548256,
  "tokenizer_config.json": 28249,
  "generation_config.json": 136,
  "onnx/embed_tokens_fp16.onnx": 56770946,
  "onnx/decoder_model_merged_fp16.onnx": 270414183,
  "onnx/vision_encoder_fp16.onnx": 187294693,
};
</file>

<file path="src/ai/imageToText/ImageToText.ts">
import { ProgressInfo } from "@huggingface/transformers";
import isFileInCache from "@utils/isFileInCache";

import { EXPECTED_FILES, MODEL_ONNX_URL_BASE } from "./constants";
import { ImageToTextWorkerMessage, ImageToTextWorkerResponse } from "./types";

class ImageToText {
  private worker: Worker;
  private isReady: boolean = false;

  constructor() {
    this.worker = new Worker(
      new URL("./imageToTextWorker.ts", import.meta.url),
      {
        type: "module",
      }
    );

    // Initialize worker
    this.worker.postMessage({ type: "check" });
  }

  public async preload(
    loadingCallback: (progress: number) => void = () => {}
  ): Promise<void> {
    const files: Record<
      string,
      {
        total: number;
        loaded: number;
      }
    > = Object.entries(EXPECTED_FILES).reduce(
      (acc, [file, total]) => ({
        ...acc,
        [file]: {
          total,
          loaded: 0,
        },
      }),
      {}
    );

    return new Promise((resolve, reject) => {
      const listener = (e: MessageEvent<ImageToTextWorkerResponse>) => {
        if (e.data.status === "ready") {
          this.isReady = true;
          loadingCallback(100);
          this.worker.removeEventListener("message", listener);
          resolve();
        }
        if (
          e.data.status === "loading" &&
          e.data.progress &&
          e.data.progress.status === "progress"
        ) {
          const progress = e.data.progress;
          files[progress.file] = {
            loaded: progress.loaded,
            total: progress.total,
          };
          const { total, loaded } = Object.entries(files).reduce(
            (acc, [file, progress]) => ({
              total: acc.total + progress.total,
              loaded: acc.loaded + progress.loaded,
            }),
            { total: 0, loaded: 0 }
          );
          loadingCallback(Math.round((loaded / total) * 100));
        }

        if (e.data.status === "error") {
          this.worker.removeEventListener("message", listener);
          reject(new Error(e.data.error || "Failed to initialize"));
        }
      };

      this.worker.addEventListener("message", listener);
      this.postMessage({ type: "load" });
    });
  }

  public async generate(
    imageDataUrl: string,
    prompt: string = "Describe this image in detail.",
    onUpdate?: (partialText: string, tps?: number, numTokens?: number) => void
  ): Promise<string> {
    if (!this.isReady) {
      await this.preload();
    }

    return new Promise((resolve, reject) => {
      const id = Math.random().toString(36);
      let fullOutput = "";

      const listener = (e: MessageEvent<ImageToTextWorkerResponse>) => {
        if ("id" in e.data && e.data.id !== id) return;

        if (e.data.status === "start") {
          // Generation started
        }

        if (e.data.status === "update") {
          fullOutput = e.data.output || "";
          if (onUpdate) {
            onUpdate(fullOutput, e.data.tps, e.data.numTokens);
          }
        }

        if (e.data.status === "complete") {
          this.worker.removeEventListener("message", listener);
          resolve(e.data.output || fullOutput);
        }

        if (e.data.status === "error") {
          this.worker.removeEventListener("message", listener);
          reject(new Error(e.data.error || "Image to text failed"));
        }
      };

      this.worker.addEventListener("message", listener);

      this.postMessage({
        type: "generate",
        data: {
          id,
          image: imageDataUrl,
          prompt,
        },
      });
    });
  }

  private postMessage = (message: ImageToTextWorkerMessage) =>
    this.worker.postMessage(message);

  public async generateFromBlob(
    imageBlob: Blob,
    prompt: string = "Describe this image in detail.",
    onUpdate?: (partialText: string, tps?: number, numTokens?: number) => void
  ): Promise<string> {
    const dataUrl = await this.blobToDataUrl(imageBlob);
    return this.generate(dataUrl, prompt, onUpdate);
  }

  public async generateFromFile(
    file: File,
    prompt: string = "Describe this image in detail.",
    onUpdate?: (partialText: string, tps?: number, numTokens?: number) => void
  ): Promise<string> {
    if (!file.type.startsWith("image/")) {
      throw new Error("File is not an image");
    }
    return this.generateFromBlob(file, prompt, onUpdate);
  }

  public async generateFromUrl(
    imageUrl: string,
    prompt: string = "Describe this image in detail.",
    onUpdate?: (partialText: string, tps?: number, numTokens?: number) => void
  ): Promise<string> {
    const blob = await this.urlToBlob(imageUrl);
    return this.generateFromBlob(blob, prompt, onUpdate);
  }

  public interrupt(): void {
    this.postMessage({ type: "interrupt" });
  }

  public reset(): void {
    this.postMessage({ type: "reset" });
  }

  private async blobToDataUrl(blob: Blob): Promise<string> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.onerror = () => reject(new Error("Failed to read blob"));
      reader.readAsDataURL(blob);
    });
  }

  private async urlToBlob(url: string): Promise<Blob> {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.statusText}`);
    }
    return response.blob();
  }

  public isCached = async (): Promise<boolean> => {
    return (
      await Promise.all(
        Object.keys(EXPECTED_FILES).map((file) =>
          isFileInCache("transformers-cache", MODEL_ONNX_URL_BASE + file)
        )
      )
    ).every((c) => c);
  };
}

export default ImageToText;
</file>

<file path="src/ai/imageToText/imageToTextWorker.ts">
import {
  AutoModelForVision2Seq,
  AutoProcessor,
  InterruptableStoppingCriteria,
  ProgressInfo,
  TextStreamer,
  load_image,
} from "@huggingface/transformers";

import { ImageToTextWorkerMessage, ImageToTextWorkerResponse } from "./types";

const MAX_NEW_TOKENS = 512;

/**
 * Helper function to perform feature detection for WebGPU
 */
let fp16_supported = false;
async function check() {
  try {
    if (!("gpu" in navigator)) {
      throw new Error("WebGPU is not supported");
    }
    // @ts-ignore
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error("WebGPU is not supported (no adapter found)");
    }
    fp16_supported = adapter.features.has("shader-f16");

    postMessage({
      status: "ready",
    });
  } catch (e: any) {
    postMessage({
      status: "error",
      error: e.toString(),
    });
  }
}

/**
 * This class uses the Singleton pattern to enable lazy-loading of the pipeline
 */
class SmolVLM {
  static model_id = "HuggingFaceTB/SmolVLM-256M-Instruct";
  static processor: Promise<any> | null = null;
  static model: Promise<any> | null = null;

  static async getInstance(
    progress_callback: (progress: ProgressInfo) => void = null
  ) {
    this.processor ??= AutoProcessor.from_pretrained(this.model_id, {
      progress_callback,
    });

    this.model ??= AutoModelForVision2Seq.from_pretrained(this.model_id, {
      dtype: fp16_supported ? "fp16" : "fp32",
      device: "webgpu",
      progress_callback,
    });

    return Promise.all([this.processor, this.model]);
  }
}

const stopping_criteria = new InterruptableStoppingCriteria();

let past_key_values_cache: any = null;

async function generate(data: { id: string; image: string; prompt?: string }) {
  const { id, image, prompt = "Describe this image in detail." } = data;

  try {
    // Retrieve the processor and model
    const [processor, model] = await SmolVLM.getInstance();

    // Load the image
    const loadedImage = await load_image(image);

    // Prepare the message format for SmolVLM
    const messages = [
      {
        role: "user",
        content: [
          { type: "image", image: loadedImage },
          { type: "text", text: prompt },
        ],
      },
    ];

    // Prepare inputs
    const text = processor.apply_chat_template(messages, {
      add_generation_prompt: true,
    });

    const inputs = await processor(text, [loadedImage]);

    let startTime: number | undefined;
    let numTokens = 0;
    let tps: number | undefined;

    const token_callback_function = (_tokens: any) => {
      startTime ??= performance.now();
      if (numTokens++ > 0) {
        tps = (numTokens / (performance.now() - startTime!)) * 1000;
      }
    };

    const callback_function = (output: string) => {
      postMessage({
        id,
        status: "update",
        output,
        tps: tps!,
        numTokens,
      });
    };

    const streamer = new TextStreamer(processor.tokenizer, {
      skip_prompt: true,
      skip_special_tokens: true,
      callback_function,
      token_callback_function,
    });

    // Tell the main thread we are starting
    postMessage({
      id,
      status: "start",
    });

    const { past_key_values, sequences } = await model.generate({
      ...inputs,
      do_sample: false,
      repetition_penalty: 1.1,
      max_new_tokens: MAX_NEW_TOKENS,
      streamer,
      stopping_criteria,
      return_dict_in_generate: true,
    });

    past_key_values_cache = past_key_values;

    const decoded = processor.batch_decode(sequences, {
      skip_special_tokens: true,
    });

    // Send the output back to the main thread
    postMessage({
      id,
      status: "complete",
      output: decoded[0] || "",
    });
  } catch (error) {
    console.error("Image to text error:", error);
    postMessage({
      id,
      status: "error",
      error: error instanceof Error ? error.message : "Unknown error occurred",
    });
  }
}

async function load() {
  postMessage({
    status: "loading",
  });

  try {
    await SmolVLM.getInstance((progress) => {
      postMessage({
        status: "loading",
        progress,
      });
    });

    postMessage({
      status: "ready",
    });
  } catch (error) {
    postMessage({
      status: "error",
      error: error instanceof Error ? error.message : "Failed to load model",
    });
  }
}

// Listen for messages from the main thread
self.addEventListener(
  "message",
  async (e: MessageEvent<ImageToTextWorkerMessage>) => {
    const { type } = e.data;

    switch (type) {
      case "check":
        await check();
        break;

      case "load":
        await load();
        break;

      case "generate":
        if (e.data.data) {
          stopping_criteria.reset();
          await generate(e.data.data);
        }
        break;

      case "interrupt":
        stopping_criteria.interrupt();
        break;

      case "reset":
        past_key_values_cache = null;
        stopping_criteria.reset();
        break;
    }
  }
);

const postMessage = (message: ImageToTextWorkerResponse) =>
  self.postMessage(message);
</file>

<file path="src/ai/imageToText/types.ts">
import { ProgressInfo } from "@huggingface/transformers";

interface ImageToTextWorkerMessageGenerate {
  type: "generate";
  data?: {
    id: string;
    image: string; // base64 data URL
    prompt: string;
  };
}

export interface ImageToTextWorkerMessageSimple {
  type: "check" | "load" | "interrupt" | "reset";
}

export type ImageToTextWorkerMessage =
  | ImageToTextWorkerMessageGenerate
  | ImageToTextWorkerMessageSimple;

interface ImageToTextWorkerResponseReady {
  status: "ready";
}

interface ImageToTextWorkerResponseLoading {
  status: "loading";
  progress?: ProgressInfo;
}

interface ImageToTextWorkerResponseError {
  status: "error";
  error: string;
  id?: string;
}

interface ImageToTextWorkerResponseStart {
  status: "start";
  id: string;
}

interface ImageToTextWorkerResponseComplete {
  status: "complete";
  id: string;
  output: string;
}

interface ImageToTextWorkerResponseUpdate {
  status: "update";
  id: string;
  output: string;
  tps: number;
  numTokens?: number;
}

export type ImageToTextWorkerResponse =
  | ImageToTextWorkerResponseReady
  | ImageToTextWorkerResponseLoading
  | ImageToTextWorkerResponseComplete
  | ImageToTextWorkerResponseStart
  | ImageToTextWorkerResponseUpdate
  | ImageToTextWorkerResponseError;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/CausalLMPipeline.ts">
import {
  AutoTokenizer,
  AutoModelForCausalLM,
  PreTrainedModel,
  PreTrainedTokenizer,
  ProgressCallback,
} from "@huggingface/transformers";
import { ModelIds, MODELS } from "../../../constants";

class CausalLMPipeline {
  static tokenizer: Partial<Record<ModelIds, PreTrainedTokenizer>> = {};
  static model: Partial<Record<ModelIds, PreTrainedModel>> = {};

  static async getInstance(
    model_id: ModelIds,
    progress_callback: ProgressCallback = null,
    abortSignal?: AbortSignal,
  ): Promise<[PreTrainedTokenizer, PreTrainedModel]> {
    if (!(model_id in MODELS)) {
      throw new Error(
        `Model ${model_id} not found. Available models: ${Object.keys(MODELS).join(", ")}`,
      );
    }
    const MODEL = MODELS[model_id];

    if (
      !this.tokenizer ||
      !this.tokenizer[model_id] ||
      !this.model ||
      !this.model[model_id]
    ) {
      const tokenizer = AutoTokenizer.from_pretrained(MODEL.id, {
        progress_callback,
        ...(abortSignal && { signal: abortSignal }),
      });

      const model = AutoModelForCausalLM.from_pretrained(MODEL.id, {
        dtype: MODEL.dtype,
        device: "webgpu",
        progress_callback,
        ...(abortSignal && { signal: abortSignal }),
      });

      const loaded = await Promise.all([tokenizer, model]);

      this.tokenizer[model_id] = loaded[0];
      this.model[model_id] = loaded[1];
    }
    return [this.tokenizer[model_id], this.model[model_id]];
  }
}

export default CausalLMPipeline;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/getLanguageModelAvailability.ts">
/// <reference types="@webgpu/types" />
import isFileInCache from "./isFileInCache";
import { ModelIds, MODELS } from "../../../constants";

const getLanguageModelAvailability = async (
  model_id: ModelIds,
): Promise<Availability> => {
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter || !(model_id in MODELS)) {
    return "unavailable";
  }

  const filesInCache = await Promise.all(
    Object.keys(MODELS[model_id].expectedFiles).map((file) =>
      isFileInCache(
        "transformers-cache",
        `https://huggingface.co/${MODELS[model_id].id}/resolve/main/${file}`,
      ),
    ),
  );

  if (filesInCache.every((c) => c)) {
    return "available";
  }

  return "downloadable";
};

export default getLanguageModelAvailability;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/isFileInCache.ts">
const isFileInCache = async (
  cacheName: string,
  fileUrl: string,
): Promise<boolean> => {
  try {
    const cache = await caches.open(cacheName);
    const response = await cache.match(fileUrl);
    return response !== undefined;
  } catch (error) {
    console.error("Error checking cache:", error);
    return false;
  }
};

export default isFileInCache;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/KVCache.ts">
import { Message, Tensor } from "@huggingface/transformers";

class KVCache {
  private cache: Map<
    string,
    { session_id: string; kv: Record<string, Tensor> }
  >;

  public constructor() {
    this.cache = new Map();
  }

  public generateHash = (messages: Array<Message>): string => {
    let hash = 5381;
    for (let i = 0; i < messages.length; i++) {
      const msg = messages[i];
      const roleLen = msg.role.length;
      for (let j = 0; j < roleLen; j++) {
        hash = (hash * 33) ^ msg.role.charCodeAt(j);
      }
      const contentLen = msg.content.length;
      for (let j = 0; j < contentLen; j++) {
        hash = (hash * 33) ^ msg.content.charCodeAt(j);
      }
      hash = hash ^ (i << 16);
    }
    return (hash >>> 0).toString(36);
  };

  // this goes back in the messages array and find the last cache.
  // todo: I guess this wont work because transformers.js always expects the messages[messages.length - 1] as the cache
  /*public get(messages: Array<Message>) {
    const removedMessages: Array<Message> = [];
    let currentMessages = [...messages];

    while (currentMessages.length > 0) {
      const hash = this.generateHash(currentMessages);
      const cachedValue = this.cache.get(hash);

      if (cachedValue !== undefined) {
        return {
          value: cachedValue,
          new_messages: removedMessages,
        };
      }

      const lastMessage = currentMessages.pop();
      if (lastMessage) {
        removedMessages.unshift(lastMessage);
      }
    }

    return {
      value: null,
      new_messages: removedMessages,
    };
  }*/
  public get(messages: Array<Message>) {
    const currentMessages = [...messages];
    const messagesForCache = currentMessages.slice(0, -1);
    const removedMessages = currentMessages.slice(-1);

    const hash = this.generateHash(messagesForCache);
    const cache = this.cache.get(hash);

    return {
      value: cache?.kv || null,
      new_messages: removedMessages,
    };
  }

  public set(
    messages: Array<Message>,
    data: { kv: Record<string, Tensor>; session_id: string },
  ) {
    const hash = this.generateHash(messages);
    this.cache.set(hash, data);
  }

  public deleteSession(session_id: string) {
    this.cache.forEach((value, key) => {
      if (value.session_id === session_id) {
        this.cache.delete(key);
      }
    });
  }
}

export default KVCache;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/prompt.ts">
import {
  InterruptableStoppingCriteria,
  Message,
  PreTrainedModel,
  PreTrainedTokenizer,
  Tensor,
  TextStreamer,
} from "@huggingface/transformers";

import { MODELS, ModelIds } from "../../../constants";
import { ModelUsage } from "../types";
import KVCache from "./KVCache";
import { WorkerError, WorkerErrorCode } from "./WorkerError";

let stopping_criteria: any = null;

const prompt = async (params: {
  tokenizer: PreTrainedTokenizer;
  model: PreTrainedModel;
  messages: Array<Message>;
  cache: KVCache;
  on_response_update: (token: string) => void;
  temperature: number;
  top_k: number;
  is_init_cache: boolean;
  model_id: ModelIds;
  session_id: string;
  abortSignal?: AbortSignal;
}): Promise<{
  answer: string;
  usage: ModelUsage;
  newMessages: Array<Message>;
}> => {
  const {
    tokenizer,
    model,
    messages,
    cache,
    on_response_update,
    temperature,
    top_k,
    is_init_cache,
    model_id,
    session_id,
    abortSignal,
  } = params;

  if (!stopping_criteria) {
    stopping_criteria = new InterruptableStoppingCriteria();
  }

  const input_start_time: DOMHighResTimeStamp = performance.now();
  const inputs = tokenizer.apply_chat_template(messages, {
    add_generation_prompt: true,
    return_dict: true,
    // @ts-ignore
    enable_thinking: false,
  });

  const input_size = (
    tokenizer.apply_chat_template(messages, {
      tokenize: true,
      return_tensor: false,
    }) as Array<number>
  ).length;

  const { value: kv_cache, new_messages } = cache.get(messages);

  if (input_size >= MODELS[model_id].maxToken) {
    throw new WorkerError(
      WorkerErrorCode.MAX_TOTAL_TOKENS_EXCEEDED,
      `Input size ${input_size} exceeds maximum allowed tokens ${MODELS[model_id].maxToken}`,
      { input_size, max_tokens: MODELS[model_id].maxToken }
    );
  }

  const new_messages_size = (
    tokenizer.apply_chat_template(new_messages, {
      tokenize: true,
      return_tensor: false,
    }) as Array<number>
  ).length;

  /*if (new_messages_size >= MODELS[model_id].maxNewTokens) {
    throw new WorkerError(
      WorkerErrorCode.MAX_NEW_TOKENS_EXCEEDED,
      `Input size of new tokens ${new_messages_size} exceeds maximum allowed tokens per prompt ${MODELS[model_id].maxNewTokens}`,
      { new_messages_size, max_new_tokens: MODELS[model_id].maxNewTokens },
    );
  }*/

  let first_token_time: DOMHighResTimeStamp = null;
  let num_tokens = 0;
  let tps: number = 0;
  let answer = "";

  const token_callback_function = (tokens: number[] | bigint[] | Tensor) => {
    first_token_time ??= performance.now();
    if (num_tokens++ > 0) {
      tps = (num_tokens / (performance.now() - first_token_time)) * 1000;
    }
  };

  const callback_function = (output: string) => {
    if (abortSignal?.aborted) {
      stopping_criteria.interrupt();
      throw new DOMException("Request cancelled", "AbortError");
    }
    answer = answer + output;
    on_response_update(output);
  };

  const streamer = new TextStreamer(tokenizer, {
    skip_prompt: true,
    skip_special_tokens: true,
    callback_function,
    token_callback_function,
  });

  // @ts-ignore
  const { past_key_values, ...s } = await model.generate({
    // @ts-ignore
    ...inputs,
    past_key_values: kv_cache,

    // Sampling
    do_sample: true,
    // repetition_penalty: 1.1,
    top_k,
    temperature,

    max_new_tokens: is_init_cache ? 1 : 16384,
    streamer,
    stopping_criteria,
    return_dict_in_generate: true,
  });

  const newMessages: Array<Message> = [
    ...messages,
    {
      role: "assistant",
      content: is_init_cache ? "" : answer,
    },
  ];

  const done_time: DOMHighResTimeStamp = performance.now();

  cache.set(newMessages, { session_id, kv: past_key_values });

  const usage: ModelUsage = {
    new_input_tokens: new_messages_size,
    input_tokens: input_size,
    input_duration_ms: first_token_time - input_start_time,
    input_cache_used: Boolean(kv_cache),
    output_tokens: num_tokens,
    output_duration_ms: done_time - first_token_time,
    output_tps: tps,
    total_tokens: input_size + num_tokens,
    model_id,
  };

  return {
    answer,
    usage,
    newMessages,
  };
};

export default prompt;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/utils/WorkerError.ts">
import { ResponseType, ErrorResponse } from "../types";

export enum WorkerErrorCode {
  // Model loading errors
  MODEL_LOAD_FAILED = "MODEL_LOAD_FAILED",
  MODEL_NOT_FOUND = "MODEL_NOT_FOUND",
  MODEL_UNSUPPORTED = "MODEL_UNSUPPORTED",

  // Prompt processing errors
  PROMPT_TOO_LONG = "PROMPT_TOO_LONG",
  PROMPT_INVALID = "PROMPT_INVALID",
  GENERATION_FAILED = "GENERATION_FAILED",

  // Token/Cache errors
  MAX_TOTAL_TOKENS_EXCEEDED = "MAX_TOTAL_TOKENS_EXCEEDED",
  MAX_NEW_TOKENS_EXCEEDED = "MAX_NEW_TOKENS_EXCEEDED",
  CACHE_ERROR = "CACHE_ERROR",

  // General errors
  HANDLER_ERROR = "HANDLER_ERROR",
  NO_HANDLER = "NO_HANDLER",
  UNKNOWN_ERROR = "UNKNOWN_ERROR",

  // Resource errors
  OUT_OF_MEMORY = "OUT_OF_MEMORY",
  NETWORK_ERROR = "NETWORK_ERROR",
}

export class WorkerError extends Error {
  public readonly code: WorkerErrorCode;
  public readonly details?: unknown;

  constructor(code: WorkerErrorCode, message: string, details?: unknown) {
    super(message);
    this.name = "WorkerError";
    this.code = code;
    this.details = details;
  }

  static fromError(
    error: unknown,
    fallbackCode: WorkerErrorCode = WorkerErrorCode.UNKNOWN_ERROR,
  ): WorkerError {
    if (error instanceof WorkerError) {
      return error;
    }

    if (error instanceof Error) {
      // Try to map common error types to specific codes
      if (error.message.includes("Max token exceeded")) {
        return new WorkerError(
          WorkerErrorCode.MAX_TOTAL_TOKENS_EXCEEDED,
          error.message,
          error,
        );
      }
      if (
        error.message.includes("out of memory") ||
        error.message.includes("OOM")
      ) {
        return new WorkerError(
          WorkerErrorCode.OUT_OF_MEMORY,
          error.message,
          error,
        );
      }
      if (
        error.message.includes("network") ||
        error.message.includes("fetch")
      ) {
        return new WorkerError(
          WorkerErrorCode.NETWORK_ERROR,
          error.message,
          error,
        );
      }

      return new WorkerError(fallbackCode, error.message, error);
    }

    return new WorkerError(fallbackCode, String(error), error);
  }

  toErrorResponse(requestId: string): ErrorResponse {
    return {
      id: requestId,
      type: ResponseType.ERROR,
      error: {
        message: this.message,
        code: this.code,
        details: this.details,
      },
    };
  }
}
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker/types.ts">
import { Message, ProgressInfo } from "@huggingface/transformers";
import { ModelIds } from "../../constants";

interface BaseRequest {
  id: string;
  type: RequestType;
  model_id: ModelIds;
  session_id: string;
}

interface BaseResponse {
  id: string;
  type: ResponseType;
}

export enum RequestType {
  CHECK_AVAILABILITY,
  LOAD_MODEL,
  PROMPT,
  CANCEL,
  DESTROY,
}

export enum ResponseType {
  ERROR,
  AVAILABILITY,
  LOAD_MODEL_PROGRESS,
  MODEL_LOADED,
  PROMPT_DONE,
  PROMPT_PROGRESS,
  CANCELLED,
}

/**
 * Request Types
 */

interface CheckAvailabilityRequest extends BaseRequest {
  type: RequestType.CHECK_AVAILABILITY;
}

interface LoadModelRequest extends BaseRequest {
  type: RequestType.LOAD_MODEL;
}

interface PromptRequest extends BaseRequest {
  type: RequestType.PROMPT;
  messages: Array<Message>;
  temperature: number;
  top_k: number;
  is_init_cache: boolean;
}

interface CancelRequest extends BaseRequest {
  type: RequestType.CANCEL;
}

interface DestroyRequest extends BaseRequest {
  type: RequestType.DESTROY;
}

/**
 * Response Types
 */

interface AvailabilityResponse extends BaseResponse {
  type: ResponseType.AVAILABILITY;
  availability: Availability;
}

interface ModelLoadingProgressResponse extends BaseResponse {
  type: ResponseType.LOAD_MODEL_PROGRESS;
  progress: ProgressInfo;
}

interface ModelLoadedResponse extends BaseResponse {
  type: ResponseType.MODEL_LOADED;
}

interface PromptProgressResponse extends BaseResponse {
  type: ResponseType.PROMPT_PROGRESS;
  token_generated: string;
}

interface PromptDoneResponse extends BaseResponse {
  type: ResponseType.PROMPT_DONE;
  response: string;
  messages: Array<Message>;
  usage: ModelUsage;
}

export interface ErrorResponse extends BaseResponse {
  type: ResponseType.ERROR;
  error: {
    message: string;
    code?: string;
    details?: unknown;
  };
}

interface PromptCancelledResponse extends BaseResponse {
  type: ResponseType.CANCELLED;
  message: string;
}

export type WorkerRequest =
  | CheckAvailabilityRequest
  | LoadModelRequest
  | PromptRequest
  | CancelRequest
  | DestroyRequest;

export type WorkerResponse =
  | AvailabilityResponse
  | ErrorResponse
  | ModelLoadedResponse
  | ModelLoadingProgressResponse
  | PromptProgressResponse
  | PromptDoneResponse
  | PromptCancelledResponse;

export interface ModelUsage {
  new_input_tokens: number;
  input_tokens: number;
  input_duration_ms: number;
  input_cache_used: boolean;
  output_tokens: number;
  output_duration_ms: number;
  output_tps: number;
  total_tokens: number;
  model_id: ModelIds;
}
</file>

<file path="src/ai/llm/textGeneration/languageModel/TransformersJsModel.ts">
import {
  ModelUsage,
  RequestType,
  ResponseType,
  WorkerRequest,
  WorkerResponse,
} from "./worker/types";
import { ModelIds, MODELS } from "../constants";
import { Message } from "@huggingface/transformers";

let workerRequestId = 0;

class TransformersJsModel {
  private model_id: ModelIds;
  private worker: Worker;
  private session_id: string;

  public constructor(
    worker: Worker,
    session_id: string,
    model_id: ModelIds = "SmolLM3-3B",
  ) {
    this.model_id = model_id;
    if (worker) {
      this.worker = worker;
    } else {
      throw new Error("No worker provided");
    }
    this.session_id = session_id;
  }

  private postMessage = (message: WorkerRequest) => {
    try {
      this.worker.postMessage(message);
    } catch (e) {
      console.error(e);
    }
  };

  public get maxToken() {
    return MODELS[this.model_id].maxToken;
  }

  public get modelSize(): number {
    return Object.values(MODELS[this.model_id].expectedFiles).reduce(
      (acc, val) => acc + val,
      0,
    );
  }

  public async loadModel(
    monitor?: CreateMonitor,
    signal?: AbortSignal,
  ): Promise<void> {
    if (signal?.aborted) {
      throw new DOMException("Operation aborted", "AbortError");
    }

    const updateProgress = (progress: {
      progress: number;
      loaded: number;
      total: number;
    }) => {
      if (monitor) {
        const event = new ProgressEvent("downloadprogress", {
          lengthComputable: true,
          loaded: progress.progress,
          total: progress.total,
        });

        if (monitor.ondownloadprogress) {
          monitor.ondownloadprogress.call(monitor, event);
        }
        monitor.dispatchEvent(event);
      }
    };

    return new Promise<void>((resolve, reject) => {
      const requestId = (workerRequestId++).toString();

      const filesMap: Record<
        string,
        {
          loaded: number;
          total: number;
        }
      > = Object.entries(MODELS[this.model_id].expectedFiles).reduce(
        (acc, [file, total]) => ({
          ...acc,
          [file]: {
            loaded: 0,
            total,
          },
        }),
        {},
      );

      let refProgressPercentages = 0;

      const listener = (e: MessageEvent<WorkerResponse>) => {
        if (e.data.id !== requestId) return;

        if (
          e.data.type === ResponseType.ERROR ||
          e.data.type === ResponseType.CANCELLED
        ) {
          this.worker.removeEventListener("message", listener);
          reject(
            e.data.type === ResponseType.ERROR ? e.data.error : e.data.message,
          );
        }

        if (e.data.type === ResponseType.MODEL_LOADED) {
          this.worker.removeEventListener("message", listener);
          //console.log(JSON.stringify(filesMap));
          resolve();
        }

        if (
          e.data.type === ResponseType.LOAD_MODEL_PROGRESS &&
          e.data.progress.status === "progress"
        ) {
          const progress = e.data.progress;
          filesMap[progress.file] = {
            loaded: progress.loaded,
            total: progress.total,
          };
          const { total, loaded } = Object.entries(filesMap).reduce(
            (acc, [, progress]) => ({
              total: acc.total + progress.total,
              loaded: acc.loaded + progress.loaded,
            }),
            { total: 0, loaded: 0 },
          );
          const newProgressPercentages =
            Math.round((loaded / total) * 10000) / 10000;
          const newProgress = {
            progress: newProgressPercentages,
            loaded,
            total,
          };
          if (
            JSON.stringify(refProgressPercentages) !==
            JSON.stringify(newProgressPercentages)
          ) {
            updateProgress(newProgress);
            refProgressPercentages = newProgressPercentages;
          }
        }
      };

      this.worker.addEventListener("message", listener);

      this.postMessage({
        id: requestId,
        type: RequestType.LOAD_MODEL,
        model_id: this.model_id,
        session_id: this.session_id,
      });

      if (signal) {
        signal.onabort = () => {
          this.postMessage({
            id: requestId,
            type: RequestType.CANCEL,
            model_id: this.model_id,
            session_id: this.session_id,
          });
        };
      }
    });
  }

  async prompt(
    input: Array<LanguageModelMessage | LanguageModelSystemMessage>,
    temperature: number,
    top_k: number,
    is_init_cache: boolean,
    onResponseUpdate: (response: string) => void = () => {},
    options?: LanguageModelPromptOptions,
  ): Promise<{
    response: string;
    messages: Array<Message>;
    usage: ModelUsage;
  }> {
    return new Promise((resolve, reject) => {
      const requestId = (workerRequestId++).toString();
      const listener = (e: MessageEvent<WorkerResponse>) => {
        if (e.data.id !== requestId) return;

        if (
          e.data.type === ResponseType.ERROR ||
          e.data.type === ResponseType.CANCELLED
        ) {
          this.worker.removeEventListener("message", listener);
          reject(
            e.data.type === ResponseType.ERROR ? e.data.error : e.data.message,
          );
        }

        if (e.data.type === ResponseType.PROMPT_PROGRESS) {
          onResponseUpdate(e.data.token_generated);
        }

        if (e.data.type === ResponseType.PROMPT_DONE) {
          this.worker.removeEventListener("message", listener);
          resolve({
            response: e.data.response,
            messages: e.data.messages,
            usage: e.data.usage,
          });
        }
      };

      this.worker.addEventListener("message", listener);

      this.postMessage({
        id: requestId,
        type: RequestType.PROMPT,
        messages: input.map((message) => ({
          role: message.role,
          content: message.content.toString(),
        })),
        temperature,
        top_k,
        is_init_cache,
        model_id: this.model_id,
        session_id: this.session_id,
      });

      if (options?.signal) {
        options.signal.onabort = () => {
          this.postMessage({
            id: requestId,
            type: RequestType.CANCEL,
            model_id: this.model_id,
            session_id: this.session_id,
          });
        };
      }
    });
  }

  async destroy() {
    const requestId = (workerRequestId++).toString();
    this.postMessage({
      id: requestId,
      type: RequestType.DESTROY,
      model_id: this.model_id,
      session_id: this.session_id,
    });
  }

  async availability(): Promise<Availability> {
    return new Promise((resolve, reject) => {
      const requestId = (workerRequestId++).toString();
      const listener = (e: MessageEvent<WorkerResponse>) => {
        if (e.data.id !== requestId) return;
        this.worker.removeEventListener("message", listener);

        if (e.data.type === ResponseType.ERROR) {
          reject(e.data.error);
        }

        if (e.data.type === ResponseType.AVAILABILITY) {
          resolve(e.data.availability);
        } else {
          resolve("unavailable");
        }
      };

      this.worker.addEventListener("message", listener);

      this.postMessage({
        id: requestId,
        type: RequestType.CHECK_AVAILABILITY,
        model_id: "Qwen3-4B",
        session_id: this.session_id,
      });
    });
  }

  static downloadSize = (model_id: ModelIds) => {
    return Object.values(MODELS[model_id].expectedFiles).reduce(
      (acc, val) => acc + val,
      0,
    );
  };
}

export default TransformersJsModel;
</file>

<file path="src/ai/llm/textGeneration/languageModel/webWorkerHandler.ts">
import {
  RequestType,
  ResponseType,
  WorkerRequest,
  WorkerResponse,
} from "./worker/types";
import CausalLMPipeline from "./worker/utils/CausalLMPipeline";
import KVCache from "./worker/utils/KVCache";
import { WorkerError, WorkerErrorCode } from "./worker/utils/WorkerError";
import getLanguageModelAvailability from "./worker/utils/getLanguageModelAvailability";
import prompt from "./worker/utils/prompt";

const cache = new KVCache();
const activePromptRequests = new Map<string, AbortController>();
const activeModelLoadRequests = new Map<string, AbortController>();

const webWorkerHandler = () => {
  const postMessage = (message: WorkerResponse) => self.postMessage(message);

  return {
    onmessage: async (event: MessageEvent<WorkerRequest>) => {
      const request = event.data;

      try {
        switch (request.type) {
          case RequestType.CHECK_AVAILABILITY: {
            postMessage({
              id: request.id,
              type: ResponseType.AVAILABILITY,
              availability: await getLanguageModelAvailability(
                request.model_id
              ),
            });
            return;
          }
          case RequestType.LOAD_MODEL: {
            const abortController = new AbortController();
            activeModelLoadRequests.set(request.id, abortController);

            await CausalLMPipeline.getInstance(
              request.model_id,
              (progressInfo) => {
                if (abortController.signal.aborted) {
                  throw new DOMException("Request cancelled", "AbortError");
                }
                postMessage({
                  id: request.id,
                  type: ResponseType.LOAD_MODEL_PROGRESS,
                  progress: progressInfo,
                });
              },
              abortController.signal
            );

            activeModelLoadRequests.delete(request.id);
            postMessage({
              id: request.id,
              type: ResponseType.MODEL_LOADED,
            });

            return;
          }
          case RequestType.PROMPT: {
            const abortController = new AbortController();
            activePromptRequests.set(request.id, abortController);
            const [tokenizer, model] = await CausalLMPipeline.getInstance(
              request.model_id,
              (progressInfo) => {
                // Check if request was cancelled
                if (abortController.signal.aborted) {
                  throw new DOMException("Request cancelled", "AbortError");
                }
                postMessage({
                  id: request.id,
                  type: ResponseType.LOAD_MODEL_PROGRESS,
                  progress: progressInfo,
                });
              },
              abortController.signal
            );

            const resp = await prompt({
              tokenizer,
              model,
              messages: request.messages,
              cache,
              on_response_update: (token_generated: string) => {
                // Check if request was cancelled
                if (abortController.signal.aborted) {
                  throw new DOMException("Request cancelled", "AbortError");
                }
                postMessage({
                  id: request.id,
                  type: ResponseType.PROMPT_PROGRESS,
                  token_generated,
                });
              },
              temperature: request.temperature,
              top_k: request.top_k,
              is_init_cache: request.is_init_cache,
              model_id: request.model_id,
              session_id: request.session_id,
              abortSignal: abortController.signal,
            });

            activePromptRequests.delete(request.id);
            postMessage({
              id: request.id,
              type: ResponseType.PROMPT_DONE,
              response: resp.answer,
              messages: resp.newMessages,
              usage: resp.usage,
            });

            return;
          }
          case RequestType.CANCEL: {
            // Check for active prompt request
            const promptAbortController = activePromptRequests.get(request.id);
            if (promptAbortController) {
              promptAbortController.abort();
              activePromptRequests.delete(request.id);
              postMessage({
                id: request.id,
                type: ResponseType.CANCELLED,
                message: "Prompt request cancelled successfully",
              });
              return;
            }

            // Check for active model load request
            const modelAbortController = activeModelLoadRequests.get(
              request.id
            );
            if (modelAbortController) {
              modelAbortController.abort();
              activeModelLoadRequests.delete(request.id);
              postMessage({
                id: request.id,
                type: ResponseType.CANCELLED,
                message: "Model loading cancelled successfully",
              });
              return;
            }

            // No active request found
            const cancelError = new WorkerError(
              WorkerErrorCode.NO_HANDLER,
              `No active request found with id: ${request.id}`
            );
            postMessage(cancelError.toErrorResponse(request.id));
            return;
          }
          case RequestType.DESTROY:
            cache.deleteSession(request.session_id);
            return;
          default:
            const noHandlerError = new WorkerError(
              WorkerErrorCode.NO_HANDLER,
              // @ts-expect-error
              `No handler found for request type: ${request.type}`
            );
            // @ts-expect-error
            postMessage(noHandlerError.toErrorResponse(request.id));
        }
      } catch (error) {
        const workerError = WorkerError.fromError(
          error,
          WorkerErrorCode.HANDLER_ERROR
        );
        postMessage(workerError.toErrorResponse(request.id));
      }
    },
  };
};

export default webWorkerHandler;
</file>

<file path="src/ai/llm/textGeneration/languageModel/worker.ts">
import webWorkerHandler from "./webWorkerHandler";

self.onmessage = webWorkerHandler().onmessage;
</file>

<file path="src/ai/llm/textGeneration/constants.ts">
interface ModelDefinition {
  id: string;
  dtype:
    | "auto"
    | "fp32"
    | "fp16"
    | "q8"
    | "int8"
    | "uint8"
    | "q4"
    | "bnb4"
    | "q4f16";
  expectedFiles: Record<string, number>;
  maxToken: number;
  maxNewTokens: number; // todo: I think this does not depend on the model but on the device.
}

export type ModelIds = "Qwen3-4B" | "SmolLM3-3B" /*| "Gemma3-270m"*/;

export const MODELS: Record<ModelIds, ModelDefinition> = {
  "SmolLM3-3B": {
    id: "HuggingFaceTB/SmolLM3-3B-ONNX",
    dtype: "q4f16",
    expectedFiles: {
      "tokenizer.json": 11574059,
      "tokenizer_config.json": 56256,
      "config.json": 2056,
      "onnx/model_q4f16.onnx": 301534,
      "generation_config.json": 182,
      "onnx/model_q4f16.onnx_data": 2124320768,
    },
    maxToken: 10000,
    maxNewTokens: 1500,
  },
  "Qwen3-4B": {
    id: "onnx-community/Qwen3-4B-ONNX",
    dtype: "q4f16",
    expectedFiles: {
      "tokenizer.json": 9117040,
      "tokenizer_config.json": 9761,
      "config.json": 1780,
      "onnx/model_q4f16.onnx": 59762833,
      "generation_config.json": 219,
      "onnx/model_q4f16.onnx_data_1": 677150720,
      "onnx/model_q4f16.onnx_data": 2096005120,
    },
    maxToken: 10000,
    maxNewTokens: 1500,
  },
  /*"Gemma3-270m": {
    id: "onnx-community/gemma-3-270m-it-ONNX",
    dtype: "fp32",
    expectedFiles: {
      "config.json": 1612,
      "tokenizer_config.json": 1158469,
      "tokenizer.json": 20323106,
      "generation_config.json": 172,
      "onnx/model.onnx": 201742,
      "onnx/model.onnx_data": 1139501568,
    },
    maxToken: 10000,
    maxNewTokens: 1500,
  },
  "Gemma3-270m-q4f16": {
    id: "onnx-community/gemma-3-270m-it-ONNX",
    dtype: "q4f16",
    expectedFiles: {
      "config.json": 1612,
      "tokenizer_config.json": 1158469,
      "tokenizer.json": 20323106,
      "generation_config.json": 172,
      "onnx/model_q4f16.onnx": 330642,
      "onnx/model_q4f16.onnx_data": 425724416,
    },
    maxToken: 10000,
    maxNewTokens: 1500,
  },*/
};
</file>

<file path="src/ai/llm/textGeneration/index.ts">
export { default as TextGeneration } from "./TextGeneration";
export { default as webWorkerHandler } from "./languageModel/webWorkerHandler";
</file>

<file path="src/ai/llm/textGeneration/TextGeneration.ts">
import { ModelIds } from "./constants";
import TransformersJsModel from "./languageModel/TransformersJsModel";
import { ModelUsage } from "./languageModel/worker/types";

const default_model_id = "SmolLM3-3B";

class TextGeneration extends EventTarget implements DestroyableModel {
  private static defaultParams: LanguageModelParams = {
    defaultTopK: 3,
    maxTopK: 8,
    defaultTemperature: 1,
    maxTemperature: 2,
  };
  public static model_id: ModelIds = default_model_id;
  public static worker: Worker;
  private _inputUsage = 0;
  private _inputQuota = 0;
  private _topK = TextGeneration.defaultParams.defaultTopK;
  private _temperature = TextGeneration.defaultParams.defaultTemperature;
  private _destroyed = false;
  private model: TransformersJsModel;
  public _conversationHistory: Array<
    LanguageModelMessage | LanguageModelSystemMessage
  > = [];
  private _latestUsage: ModelUsage = null;
  private session_id: string = null;
  public onquotaoverflow: ((this: TextGeneration, ev: Event) => any) | null =
    null;

  private static getWorker(): Worker {
    return new Worker(new URL("./languageModel/worker.ts", import.meta.url), {
      type: "module",
    });
  }

  get inputUsage(): number {
    return this._inputUsage;
  }
  get inputQuota(): number {
    return this._inputQuota;
  }
  get topK(): number {
    return this._topK;
  }
  get temperature(): number {
    return this._temperature;
  }

  get latestUsage(): ModelUsage {
    return this._latestUsage;
  }

  private constructor() {
    super();
  }

  static async create(
    options?: Omit<
      LanguageModelCreateOptions,
      "tools" | "expectedInputs" | "expectedOutputs"
    > & { buildKVCache?: boolean }
  ): Promise<TextGeneration> {
    const instance = new TextGeneration();
    instance.session_id = Math.random().toString(36).substring(2, 15);
    instance.model = new TransformersJsModel(
      TextGeneration.getWorker(),
      instance.session_id,
      this.model_id
    );
    instance._inputQuota = instance.model.maxToken;

    // @ts-expect-error
    if (options?.tools || options?.expectedInputs || options?.expectedOutputs) {
      throw new Error(
        "tools, expectedInputs and expectedOutputs are not yet implemented"
      );
    }

    if (options?.topK !== undefined) {
      instance._topK = options.topK;
    }
    if (options?.temperature !== undefined) {
      instance._temperature = options.temperature;
    }
    if (options?.initialPrompts) {
      instance._conversationHistory = options.initialPrompts;
    }

    if (options?.monitor) {
      const monitor = instance.createProgressMonitor();
      options.monitor(monitor);
      await instance.model.loadModel(monitor, options?.signal);
    } else {
      await instance.model.loadModel(undefined, options?.signal);
    }

    // build the KVCache
    if (options?.buildKVCache !== false) {
      const response = await instance.model.prompt(
        instance._conversationHistory,
        instance._temperature,
        instance._topK,
        true,
        () => {},
        {
          signal: options?.signal,
        }
      );
      instance.updateUsage(response.usage);
      instance._conversationHistory =
        response.messages as LanguageModelMessage[];
    }
    return instance;
  }

  private createProgressMonitor(): CreateMonitor {
    const monitor = new EventTarget() as CreateMonitor;
    monitor.ondownloadprogress = null;
    return monitor;
  }

  async prompt(
    input: LanguageModelPrompt,
    options?: LanguageModelPromptOptions
  ): Promise<string> {
    this.ensureNotDestroyed();

    const messages = this.processPromptInput(input);
    this._conversationHistory.push(...messages);

    const response = await this.model.prompt(
      this._conversationHistory,
      this._temperature,
      this._topK,
      false,
      () => {},
      options
    );

    this.updateUsage(response.usage);
    this._conversationHistory = response.messages as LanguageModelMessage[];

    return response.response;
  }

  promptStreaming(
    input: LanguageModelPrompt,
    options?: LanguageModelPromptOptions
  ): ReadableStream<string> & AsyncIterable<string> {
    this.ensureNotDestroyed();

    const messages = this.processPromptInput(input);
    this._conversationHistory.push(...messages);

    const stream = new ReadableStream<string>({
      start: async (controller) => {
        try {
          const response = await this.model.prompt(
            this._conversationHistory,
            this._temperature,
            this._topK,
            false,
            (token_generated) => {
              controller.enqueue(token_generated);
            },
            options
          );

          this.updateUsage(response.usage);
          this._conversationHistory =
            response.messages as LanguageModelMessage[];

          controller.close();
        } catch (error) {
          controller.error(error);
        }
      },
    });

    const asyncIterable = {
      [Symbol.asyncIterator]: async function* () {
        const reader = stream.getReader();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      },
    };

    return Object.assign(stream, asyncIterable);
  }

  async append(
    input: LanguageModelPrompt,
    options?: LanguageModelAppendOptions
  ): Promise<undefined> {
    this.ensureNotDestroyed();

    // Your append implementation
    return undefined;
  }

  async clone(options?: LanguageModelCloneOptions): Promise<TextGeneration> {
    return TextGeneration.create({
      topK: this._topK,
      temperature: this._temperature,
      ...options,
    });
  }

  static async availability(
    options?: LanguageModelCreateCoreOptions
  ): Promise<Availability> {
    const instance = new TransformersJsModel(
      TextGeneration.getWorker(),
      this.model_id
    );
    return instance.availability();
  }

  static async params(): Promise<LanguageModelParams> {
    return new Promise((resolve) => resolve(this.defaultParams));
  }

  private updateUsage(usage: ModelUsage): void {
    this._inputUsage = usage.total_tokens;
    this._latestUsage = usage;
    if (this._inputUsage > this._inputQuota && this.onquotaoverflow) {
      const event = new Event("quotaoverflow");
      this.onquotaoverflow.call(this, event);
      this.dispatchEvent(event);
    }
  }

  private ensureNotDestroyed(): void {
    if (this._destroyed) {
      throw new Error("TextGeneration has been destroyed");
    }
  }

  destroy(): undefined {
    this._destroyed = true;
    // Cleanup resources
    this.model.destroy();
    this.model = null;
    return undefined;
  }

  private processPromptInput(
    input: LanguageModelPrompt
  ): LanguageModelMessage[] {
    if (typeof input === "string") {
      // Convert string to message format
      return [
        {
          role: "user",
          content: input,
        },
      ];
    }
    return input;
  }

  static downloadSize(model_id: ModelIds = default_model_id): number {
    return TransformersJsModel.downloadSize(model_id);
  }
}

export default TextGeneration;
</file>

<file path="src/ai/llm/utils/toolsToSystemPrompt.ts">
import { Tool } from "@modelcontextprotocol/sdk/types.js";

const createFunctionCallTemplate = (
  functionName: string,
  parameters: Array<{ name: string; type: string; value: string }>
) => {
  const parameterElements = parameters
    .map(
      (param) =>
        `    <${param.name} type="${param.type}">${param.value}</${param.name}>`
    )
    .join("\n");

  return `<functionCall>
  <name>${functionName}</name>
  <parameters>
${parameterElements}
  </parameters>
</functionCall>`;
};

const generateExampleCall = (tool: Tool) => {
  if (!tool.inputSchema?.properties) {
    return createFunctionCallTemplate(tool.name, []);
  }

  const properties = tool.inputSchema.properties;
  const required = tool.inputSchema.required || [];

  const exampleParams = Object.entries(properties).map(
    ([paramName, paramSchema]: [string, any]) => {
      const type = paramSchema.type || "string";
      let exampleValue = "";

      switch (type) {
        case "string":
          exampleValue = paramSchema.default || `example ${paramName}`;
          break;
        case "integer":
        case "number":
          exampleValue = paramSchema.default?.toString() || "10";
          break;
        case "boolean":
          exampleValue = paramSchema.default?.toString() || "true";
          break;
        default:
          exampleValue =
            paramSchema.default?.toString() || `example ${paramName}`;
      }

      return { name: paramName, type, value: exampleValue };
    }
  );

  return createFunctionCallTemplate(tool.name, exampleParams);
};

const toolsToSystemPrompt = (tools: Array<Tool>): string => {
  const toolDescriptions: Array<string> = tools.map((tool) => {
    let parameterText = "**Parameters:** None";

    if (tool.inputSchema?.properties) {
      const properties = tool.inputSchema.properties;
      const required = tool.inputSchema.required || [];

      const parameterList = Object.entries(properties).map(
        ([paramName, paramSchema]: [string, any]) => {
          const isRequired = required.includes(paramName);
          const type = paramSchema.type || "string";
          const description =
            paramSchema.description || "No description available";
          const defaultValue = paramSchema.default;

          let paramLine = `- ${paramName} (${type}`;
          if (isRequired) {
            paramLine += ", required";
          } else {
            paramLine += ", optional";
            if (defaultValue !== undefined) {
              paramLine += `, default: ${JSON.stringify(defaultValue)}`;
            }
          }
          paramLine += `): ${description}`;

          return paramLine;
        }
      );

      if (parameterList.length > 0) {
        parameterText = `**Parameters:**\n${parameterList.join("\n")}`;
      }
    }

    const exampleCall = generateExampleCall(tool);

    return `**Tool Name:** ${tool.name}
**Description:** ${tool.description}
${parameterText}
**Example:**
${exampleCall}`;
  });

  return `# Tool Calling

You have the ability to call tools to accomplish tasks or find context to answer questions. Use them when necessary to provide accurate, helpful responses.
Never tell the user you cant do something if there is a tool that could do it.
Only use tools if you really have to. If its just a casual request where you dont need to call a tool, dont do it.
If you need to call a tool wait until the call is done. Never just assume a response.
"This is the response of the called tools.." is an instruction. Never generate this yourself!
  
## Available Tools

${toolDescriptions.join("\n\n")}

## Usage Guidelines

- **When to use tools:** Use tools when you see a tool that would help you fullfill the request.
- **When not to use tools:** Don't use tools for general knowledge questions you can answer directly
- **Always explain first:** Before calling any tool, briefly explain to the user why you're using that specific tool

## Format

Use this exact format for tool calls:

${createFunctionCallTemplate("{functionName}", [
  { name: "{paramName}", type: "{type}", value: "{value}" },
])}`;
};

export default toolsToSystemPrompt;
</file>

<file path="src/ai/llm/Conversation.ts">
import { getEndInstructions } from "@ai/agent";
import toolsToSystemPrompt from "@ai/llm/utils/toolsToSystemPrompt";
import { McpServerWithState } from "@ai/mcp/react/types";
import {
  ConversationConstructorOptions,
  McpServerStoreBuiltIn,
  McpServerStoreHttp,
  Message,
  MessagePartType,
  MessageRole,
  MessageUser,
  ModelStatus,
  XMLToolSignature,
} from "@ai/types";
import isFullSentence from "@utils/isFullSentence";
import isFullXMLToolCall from "@utils/isFullXMLToolCall";
import { v4 as uuidv4 } from "uuid";

import { TextGeneration } from "./textGeneration";

const modelId = "Qwen3-4B";
TextGeneration.model_id = modelId;

class Conversation {
  private log: (message?: any, ...optionalParams: any[]) => void = () => {};
  private onConversationEnded?: () => void;
  private conversationEndKeyword?: string;
  private mcpServers: Array<
    (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
  > = [];
  private session: TextGeneration;
  private systemMessage: string;
  private _messages: Array<Message> = [];
  private messagesEventListeners: Set<(messages: Array<Message>) => void> =
    new Set();
  private _engineStatus: ModelStatus = ModelStatus.IDLE;
  private statusEventListeners: Set<(status: ModelStatus) => void> = new Set();

  public constructor(options?: ConversationConstructorOptions) {
    if (options?.log) {
      this.log = options.log;
    }
    if (options?.onConversationEnded) {
      this.onConversationEnded = options.onConversationEnded;
    }
    if (options?.conversationEndKeyword) {
      this.conversationEndKeyword = options.conversationEndKeyword;
    }
  }

  public async createConversation(
    initSystemPrompt: string,
    mcpServers: Array<
      (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
    >,
    downloadProgress: (progress: number) => void = () => {},
    forceRebuild: boolean = false,
    buildKVCache: boolean = true,
    onlyDownload: boolean = false
  ) {
    this.mcpServers = mcpServers;
    if (this.mcpServers.length === 0 && !onlyDownload) {
      return;
    }

    const systemPromptParts: Array<string> = [initSystemPrompt];

    const activePrompts = await this.getActivePromptsContent(mcpServers);
    if (activePrompts.length > 0) {
      systemPromptParts.push(
        "# additional Context\n\n" + activePrompts.join("\n\n")
      );
    }

    if (this.conversationEndKeyword) {
      systemPromptParts.push(getEndInstructions(this.conversationEndKeyword));
    }

    const tools = mcpServers.reduce(
      (acc, server) => [
        ...acc,
        ...server.server.tools.filter((tool) =>
          server.activeTools.includes(tool.name)
        ),
      ],
      []
    );

    if (tools.length) {
      systemPromptParts.push(toolsToSystemPrompt(tools));
    }

    const systemPrompt = systemPromptParts.join("\n\n");

    if (this.systemMessage === systemPrompt && !forceRebuild) {
      return;
    }
    this.systemMessage = systemPrompt;

    if (this.session) {
      this.session.destroy();
    }

    const systemMessageId = uuidv4();
    this.status = ModelStatus.MODEL_LOADING;
    this.session = await TextGeneration.create({
      buildKVCache,
      initialPrompts: [{ role: "system", content: systemPrompt }],
      temperature: 0,
      monitor: (m) => {
        m.addEventListener("downloadprogress", (e) => {
          downloadProgress(e.loaded);
          if (e.loaded >= 1) this.status = ModelStatus.CONVERSATION_LOADING;
        });
      },
    });

    this.status = ModelStatus.READY;
    this.messages = [
      {
        id: systemMessageId,
        role: MessageRole.SYSTEM,
        messageParts: [
          {
            type: MessagePartType.TEXT,
            id: systemMessageId,
            text: systemPrompt,
          },
        ],
      },
    ];
  }

  public get messages() {
    return this._messages;
  }

  public set messages(messages) {
    this._messages = messages;
    this.messagesEventListeners.forEach((listener) => listener(messages));
  }

  public onMessagesChange = (callback: (messages: Array<Message>) => void) => {
    const listener = () => callback(this.messages);
    this.messagesEventListeners.add(listener);
    return () => this.messagesEventListeners.delete(listener);
  };

  public isCached = async () => {
    return (await TextGeneration.availability()) === "available";
  };

  public static downloadSize = TextGeneration.downloadSize(modelId);

  public get status() {
    return this._engineStatus;
  }

  public set status(status: ModelStatus) {
    this._engineStatus = status;
    this.statusEventListeners.forEach((listener) => listener(this.status));
  }

  public onStatusChange = (callback: (status: ModelStatus) => void) => {
    const listener = () => callback(this.status);
    this.statusEventListeners.add(listener);
    return () => this.statusEventListeners.delete(listener);
  };

  private callTool = async (
    tool: XMLToolSignature,
    assistantId: string
  ): Promise<{ functionName: string; response: string }> => {
    try {
      const server = this.mcpServers.find((server) =>
        server.activeTools.includes(tool.functionName)
      );

      if (!server) {
        return {
          functionName: tool.functionName,
          response: "Cannot call tool",
        };
      }
      const response = await server.server.callTool(
        tool.functionName,
        tool.parameters
      );

      const textResponse = response.content
        .filter(({ type }) => type === "text")
        .map(({ text }) => text)
        .join("\n");

      const mediaResponse = response.content.find(
        ({ type }) => type === "image" || type === "audio"
      );

      this.messages = this.messages.map((message) => {
        if (message.id === assistantId) {
          return {
            ...message,
            messageParts: message.messageParts.map((part) =>
              part.type === MessagePartType.TOOL_CALL &&
              part.functionName === tool.functionName
                ? {
                    ...part,
                    response: textResponse,
                    responseMedia: mediaResponse
                      ? {
                          type:
                            mediaResponse.type === "audio" ? "audio" : "image",
                          data: (mediaResponse.data as string) || "",
                          mimeType: (mediaResponse.mimeType as string) || "",
                        }
                      : null,
                  }
                : part
            ),
          };
        }
        return message;
      });

      return {
        functionName: tool.functionName,
        response: textResponse,
      };
    } catch (e) {
      return {
        functionName: tool.functionName,
        response: `Could not call tool: ${JSON.stringify(e)}`,
      };
    }
  };

  public processPrompt = async (
    message: MessageUser,
    onTextFeedback?: (feedback: string) => void
  ): Promise<void> => {
    this.messages = [...this.messages, message];

    let nextPrompt = message.messageParts
      .map((part) => (part.type === MessagePartType.TEXT ? part.text : ""))
      .join("\n");
    let shouldTriggerEndConversation = false;

    const assistantId = uuidv4();

    this.messages.push({
      id: assistantId,
      role: MessageRole.ASSISTANT,
      messageParts: [],
    });

    while (nextPrompt) {
      const { toolsToCall, shouldEndConversation } = await this.generateAnswer(
        nextPrompt,
        assistantId,
        onTextFeedback
      );

      shouldTriggerEndConversation = shouldEndConversation;

      const responses: Array<{ functionName: string; response: string }> =
        await Promise.all(
          toolsToCall.map(async (tool) => this.callTool(tool, assistantId))
        );

      if (toolsToCall.length !== 0) {
        nextPrompt = `This is the response of the called tools: ${responses
          .map(
            (resp) => `${resp.functionName}:
Response: ${resp.response}`
          )
          .join("\n\n")}`;
      } else {
        nextPrompt = "";
      }
    }

    if (shouldTriggerEndConversation) {
      if (this.onConversationEnded) {
        this.onConversationEnded();
      }
    }
  };

  private generateAnswer = async (
    prompt: string,
    assistantId: string,
    onTextFeedback?: (feedback: string) => void
  ): Promise<{
    text: string;
    toolsToCall: Array<XMLToolSignature>;
    shouldEndConversation: boolean;
  }> => {
    let processedReply: string = "";
    const toolsToCall: Array<XMLToolSignature> = [];

    const stream = this.session.promptStreaming(prompt);
    const reader = stream.getReader();
    let reply = "";
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      reply += value;

      const newReply = reply.replace(processedReply, "");
      const fullSentence = isFullSentence(newReply);
      const fullXMLToolCall = isFullXMLToolCall(newReply);

      if (fullSentence) {
        processedReply = reply;
        onTextFeedback && onTextFeedback(fullSentence);
        this.messages = this.messages.map((message) => ({
          ...message,
          messageParts:
            message.id === assistantId
              ? [
                  ...message.messageParts,
                  {
                    type: MessagePartType.TEXT,
                    id: uuidv4(),
                    text: fullSentence,
                  },
                ]
              : message.messageParts,
        }));
      }

      if (fullXMLToolCall) {
        processedReply = reply;
        toolsToCall.push(fullXMLToolCall);
        this.messages = this.messages.map((message) => ({
          ...message,
          messageParts:
            message.id === assistantId
              ? [
                  ...message.messageParts,
                  {
                    type: MessagePartType.TOOL_CALL,
                    id: uuidv4(),
                    functionName: fullXMLToolCall.functionName,
                    parameters: fullXMLToolCall.parameters,
                    response: "",
                  },
                ]
              : message.messageParts,
        }));
      }
    }

    return {
      text: reply,
      toolsToCall,
      shouldEndConversation:
        this.conversationEndKeyword &&
        reply.endsWith(this.conversationEndKeyword),
    };
  };

  private async getActivePromptsContent(
    mcpServers: Array<
      (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
    >
  ): Promise<string[]> {
    const promptContents: string[] = [];

    for (const serverConfig of mcpServers) {
      if (
        !serverConfig.active ||
        (serverConfig.activePrompts || []).length === 0
      ) {
        continue;
      }

      const activePrompts = serverConfig.server.prompts.filter((prompt) =>
        serverConfig.activePrompts.includes(prompt.name)
      );

      for (const prompt of activePrompts) {
        try {
          const promptResult = await serverConfig.server.getPrompt(prompt.name);

          if (promptResult.messages && promptResult.messages.length > 0) {
            const promptContent = promptResult.messages
              .map((message) => {
                if (message.content.type === "text") {
                  return message.content.text;
                }
                return "";
              })
              .filter((content) => content.length > 0)
              .join("\n");

            if (promptContent) {
              promptContents.push(`## ${prompt.name}\n${promptContent}`);
            }
          }
        } catch (error) {
          this.log(
            `Failed to retrieve prompt "${prompt.name}": ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
    }

    return promptContents;
  }
}

export default Conversation;
</file>

<file path="src/ai/llm/ConversationGemini.ts">
import { getEndInstructions } from "@ai/agent";
import toolsToSystemPrompt from "@ai/llm/utils/toolsToSystemPrompt";
import { McpServerWithState } from "@ai/mcp/react/types";
import {
  ConversationConstructorOptions,
  McpServerStoreBuiltIn,
  McpServerStoreHttp,
  Message,
  MessagePartType,
  MessageRole,
  MessageUser,
  ModelStatus,
  XMLToolSignature,
} from "@ai/types";
import { GoogleGenerativeAI } from "@google/generative-ai";
import isFullSentence from "@utils/isFullSentence";
import isFullXMLToolCall from "@utils/isFullXMLToolCall";
import { v4 as uuidv4 } from "uuid";

export interface ConversationGeminiOptions
  extends ConversationConstructorOptions {
  model?: string;
}

class ConversationGemini {
  private log: (message?: any, ...optionalParams: any[]) => void = () => {};
  private onConversationEnded?: () => void;
  private conversationEndKeyword?: string;
  private mcpServers: Array<
    (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
  > = [];
  private genAI: GoogleGenerativeAI;
  private model: any;
  private chat: any;
  private modelName: string;
  private systemMessage: string;
  private _messages: Array<Message> = [];
  private messagesEventListeners: Set<(messages: Array<Message>) => void> =
    new Set();
  private _engineStatus: ModelStatus = ModelStatus.IDLE;
  private statusEventListeners: Set<(status: ModelStatus) => void> = new Set();

  public constructor(options?: ConversationGeminiOptions) {
    const apiKey = import.meta.env.VITE_GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error("VITE_GEMINI_API_KEY environment variable is required");
    }

    this.genAI = new GoogleGenerativeAI(apiKey);
    this.modelName = options?.model || "gemini-2.5-flash-preview-09-2025";

    if (options?.log) {
      this.log = options.log;
    }
    if (options?.onConversationEnded) {
      this.onConversationEnded = options.onConversationEnded;
    }
    if (options?.conversationEndKeyword) {
      this.conversationEndKeyword = options.conversationEndKeyword;
    }
  }

  public async createConversation(
    initSystemPrompt: string,
    mcpServers: Array<
      (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
    >,
    downloadProgress: (progress: number) => void = () => {},
    forceRebuild: boolean = false,
    buildKVCache: boolean = true
  ) {
    this.mcpServers = mcpServers;

    const systemPromptParts: Array<string> = [initSystemPrompt];

    const activePrompts = await this.getActivePromptsContent(mcpServers);
    if (activePrompts.length > 0) {
      systemPromptParts.push(
        "# additional Context\n\n" + activePrompts.join("\n\n")
      );
    }

    if (this.conversationEndKeyword) {
      systemPromptParts.push(getEndInstructions(this.conversationEndKeyword));
    }

    const tools = mcpServers.reduce(
      (acc, server) => [
        ...acc,
        ...server.server.tools.filter((tool) =>
          server.activeTools.includes(tool.name)
        ),
      ],
      []
    );

    if (tools.length) {
      systemPromptParts.push(toolsToSystemPrompt(tools));
    }

    const systemPrompt = systemPromptParts.join("\n\n");

    if (this.systemMessage === systemPrompt && !forceRebuild) {
      return;
    }
    this.systemMessage = systemPrompt;

    const systemMessageId = uuidv4();
    this.status = ModelStatus.MODEL_LOADING;

    // Initialize Gemini model
    this.model = this.genAI.getGenerativeModel({
      model: this.modelName,
      systemInstruction: systemPrompt,
    });

    this.chat = this.model.startChat({
      history: [],
      generationConfig: {
        temperature: 0,
      },
    });

    downloadProgress(1); // Gemini doesn't need downloading
    this.status = ModelStatus.READY;

    this.messages = [
      {
        id: systemMessageId,
        role: MessageRole.SYSTEM,
        messageParts: [
          {
            type: MessagePartType.TEXT,
            id: systemMessageId,
            text: systemPrompt,
          },
        ],
      },
    ];
  }

  public get messages() {
    return this._messages;
  }

  public set messages(messages) {
    this._messages = messages;
    this.messagesEventListeners.forEach((listener) => listener(messages));
  }

  public onMessagesChange = (callback: (messages: Array<Message>) => void) => {
    const listener = () => callback(this.messages);
    this.messagesEventListeners.add(listener);
    return () => this.messagesEventListeners.delete(listener);
  };

  public isCached = async () => {
    return true; // Gemini is always available if API key is set
  };

  public static downloadSize = 0; // No download needed for Gemini

  public get status() {
    return this._engineStatus;
  }

  public set status(status: ModelStatus) {
    this._engineStatus = status;
    this.statusEventListeners.forEach((listener) => listener(this.status));
  }

  public onStatusChange = (callback: (status: ModelStatus) => void) => {
    const listener = () => callback(this.status);
    this.statusEventListeners.add(listener);
    return () => this.statusEventListeners.delete(listener);
  };

  private callTool = async (
    tool: XMLToolSignature,
    assistantId: string
  ): Promise<{ functionName: string; response: string }> => {
    try {
      const server = this.mcpServers.find((server) =>
        server.activeTools.includes(tool.functionName)
      );

      if (!server) {
        return {
          functionName: tool.functionName,
          response: "Cannot call tool",
        };
      }
      const response = await server.server.callTool(
        tool.functionName,
        tool.parameters
      );

      const textResponse = response.content
        .filter(({ type }) => type === "text")
        .map(({ text }) => text)
        .join("\n");

      const mediaResponse = response.content.find(
        ({ type }) => type === "image" || type === "audio"
      );

      this.messages = this.messages.map((message) => {
        if (message.id === assistantId) {
          return {
            ...message,
            messageParts: message.messageParts.map((part) =>
              part.type === MessagePartType.TOOL_CALL &&
              part.functionName === tool.functionName
                ? {
                    ...part,
                    response: textResponse,
                    responseMedia: mediaResponse
                      ? {
                          type:
                            mediaResponse.type === "audio" ? "audio" : "image",
                          data: (mediaResponse.data as string) || "",
                          mimeType: (mediaResponse.mimeType as string) || "",
                        }
                      : null,
                  }
                : part
            ),
          };
        }
        return message;
      });

      return {
        functionName: tool.functionName,
        response: textResponse,
      };
    } catch (e) {
      return {
        functionName: tool.functionName,
        response: `Could not call tool: ${JSON.stringify(e)}`,
      };
    }
  };

  public processPrompt = async (
    message: MessageUser,
    onTextFeedback?: (feedback: string) => void
  ): Promise<void> => {
    this.messages = [...this.messages, message];

    let nextPrompt = message.messageParts
      .map((part) => (part.type === MessagePartType.TEXT ? part.text : ""))
      .join("\n");
    let shouldTriggerEndConversation = false;

    const assistantId = uuidv4();

    this.messages.push({
      id: assistantId,
      role: MessageRole.ASSISTANT,
      messageParts: [],
    });

    while (nextPrompt) {
      const { toolsToCall, shouldEndConversation } = await this.generateAnswer(
        nextPrompt,
        assistantId,
        onTextFeedback
      );

      shouldTriggerEndConversation = shouldEndConversation;

      const responses: Array<{ functionName: string; response: string }> =
        await Promise.all(
          toolsToCall.map(async (tool) => this.callTool(tool, assistantId))
        );

      if (toolsToCall.length !== 0) {
        nextPrompt = `This is the response of the called tools: ${responses
          .map(
            (resp) => `${resp.functionName}:
Response: ${resp.response}`
          )
          .join("\n\n")}`;
      } else {
        nextPrompt = "";
      }
    }

    if (shouldTriggerEndConversation) {
      if (this.onConversationEnded) {
        this.onConversationEnded();
      }
    }
  };

  private generateAnswer = async (
    prompt: string,
    assistantId: string,
    onTextFeedback?: (feedback: string) => void
  ): Promise<{
    text: string;
    toolsToCall: Array<XMLToolSignature>;
    shouldEndConversation: boolean;
  }> => {
    let processedReply: string = "";
    const toolsToCall: Array<XMLToolSignature> = [];

    //await new Promise((resolve) => window.setTimeout(resolve, 1000));

    // Use Gemini streaming
    const result = await this.chat.sendMessageStream(prompt);
    let reply = "";

    for await (const chunk of result.stream) {
      const chunkText = chunk.text();
      reply += chunkText;

      const newReply = reply.replace(processedReply, "");
      const fullSentence = isFullSentence(newReply);
      const fullXMLToolCall = isFullXMLToolCall(newReply);

      if (fullSentence) {
        processedReply = reply;
        onTextFeedback && onTextFeedback(fullSentence);
        this.messages = this.messages.map((message) => ({
          ...message,
          messageParts:
            message.id === assistantId
              ? [
                  ...message.messageParts,
                  {
                    type: MessagePartType.TEXT,
                    id: uuidv4(),
                    text: fullSentence,
                  },
                ]
              : message.messageParts,
        }));
      }

      if (fullXMLToolCall) {
        processedReply = reply;
        toolsToCall.push(fullXMLToolCall);
        this.messages = this.messages.map((message) => ({
          ...message,
          messageParts:
            message.id === assistantId
              ? [
                  ...message.messageParts,
                  {
                    type: MessagePartType.TOOL_CALL,
                    id: uuidv4(),
                    functionName: fullXMLToolCall.functionName,
                    parameters: fullXMLToolCall.parameters,
                    response: "",
                  },
                ]
              : message.messageParts,
        }));
      }
    }

    return {
      text: reply,
      toolsToCall,
      shouldEndConversation:
        this.conversationEndKeyword &&
        reply.endsWith(this.conversationEndKeyword),
    };
  };

  private async getActivePromptsContent(
    mcpServers: Array<
      (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
    >
  ): Promise<string[]> {
    const promptContents: string[] = [];

    for (const serverConfig of mcpServers) {
      if (
        !serverConfig.active ||
        (serverConfig.activePrompts || []).length === 0
      ) {
        continue;
      }

      const activePrompts = serverConfig.server.prompts.filter((prompt) =>
        serverConfig.activePrompts.includes(prompt.name)
      );

      for (const prompt of activePrompts) {
        try {
          const promptResult = await serverConfig.server.getPrompt(prompt.name);

          if (promptResult.messages && promptResult.messages.length > 0) {
            const promptContent = promptResult.messages
              .map((message) => {
                if (message.content.type === "text") {
                  return message.content.text;
                }
                return "";
              })
              .filter((content) => content.length > 0)
              .join("\n");

            if (promptContent) {
              promptContents.push(`## ${prompt.name}\n${promptContent}`);
            }
          }
        } catch (error) {
          this.log(
            `Failed to retrieve prompt "${prompt.name}": ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }
    }

    return promptContents;
  }
}

export default ConversationGemini;
</file>

<file path="src/ai/llm/worker.ts">
import { webWorkerHandler } from "./textGeneration";

self.onmessage = webWorkerHandler().onmessage;
</file>

<file path="src/ai/mcp/auth/browser-provider.ts">
import { OAuthClientProvider } from "@modelcontextprotocol/sdk/client/auth.js";
import {
  OAuthClientInformation,
  OAuthClientMetadata,
  OAuthMetadata,
  OAuthTokens,
} from "@modelcontextprotocol/sdk/shared/auth.js";
import { sanitizeUrl } from "strict-url-sanitise";

import { StoredState } from "./types";

/**
 * Browser-compatible OAuth client provider for MCP using localStorage.
 */
export class BrowserOAuthClientProvider implements OAuthClientProvider {
  readonly serverUrl: string;
  readonly storageKeyPrefix: string;
  readonly serverUrlHash: string;
  readonly clientName: string;
  readonly clientUri: string;
  readonly callbackUrl: string;
  private preventAutoAuth?: boolean;
  readonly onPopupWindow:
    | ((url: string, features: string, window: Window | null) => void)
    | undefined;
  readonly onLog:
    | ((level: "debug" | "info" | "warn" | "error", message: string) => void)
    | undefined;

  constructor(
    serverUrl: string,
    options: {
      storageKeyPrefix?: string;
      clientName?: string;
      clientUri?: string;
      callbackUrl?: string;
      preventAutoAuth?: boolean;
      onPopupWindow?: (
        url: string,
        features: string,
        window: Window | null
      ) => void;
      onLog?: (
        level: "debug" | "info" | "warn" | "error",
        message: string
      ) => void;
    } = {}
  ) {
    this.serverUrl = serverUrl;
    this.storageKeyPrefix = options.storageKeyPrefix || "mcp:auth";
    this.serverUrlHash = this.hashString(serverUrl);
    this.clientName = options.clientName || "MCP Browser Client";
    this.clientUri =
      options.clientUri ||
      (typeof window !== "undefined" ? window.location.origin : "");
    this.callbackUrl = sanitizeUrl(
      options.callbackUrl ||
        (typeof window !== "undefined"
          ? new URL("/oauth/callback", window.location.origin).toString()
          : "/oauth/callback")
    );
    this.preventAutoAuth = options.preventAutoAuth;
    this.onPopupWindow = options.onPopupWindow;
    this.onLog = options.onLog;
  }

  // --- SDK Interface Methods ---

  get redirectUrl(): string {
    return sanitizeUrl(this.callbackUrl);
  }

  get clientMetadata(): OAuthClientMetadata {
    return {
      redirect_uris: [this.redirectUrl],
      token_endpoint_auth_method: "none", // Public client
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      client_name: this.clientName,
      client_uri: this.clientUri,
      // scope: 'openid profile email mcp', // Example scopes, adjust as needed
    };
  }

  async clientInformation(): Promise<OAuthClientInformation | undefined> {
    // Try to get stored client information from dynamic client registration
    const key = this.getKey("client_info");
    const data = localStorage.getItem(key);
    if (!data) return undefined;
    try {
      // TODO: Add validation using a schema
      return JSON.parse(data) as OAuthClientInformation;
    } catch (e) {
      this.log("warn", `Failed to parse client information: ${e}`);
      localStorage.removeItem(key);
      return undefined;
    }
  }

  // NOTE: The SDK's auth() function uses this if dynamic registration is needed.
  // Ensure your OAuthClientInformationFull matches the expected structure if DCR is used.
  async saveClientInformation(
    clientInformation: OAuthClientInformation /* | OAuthClientInformationFull */
  ): Promise<void> {
    const key = this.getKey("client_info");
    // Cast needed if handling OAuthClientInformationFull specifically
    localStorage.setItem(key, JSON.stringify(clientInformation));
  }

  async tokens(): Promise<OAuthTokens | undefined> {
    const key = this.getKey("tokens");
    const data = localStorage.getItem(key);
    if (!data) return undefined;
    try {
      // TODO: Add validation
      return JSON.parse(data) as OAuthTokens;
    } catch (e) {
      this.log("warn", `Failed to parse tokens: ${e}`);
      localStorage.removeItem(key);
      return undefined;
    }
  }

  async saveTokens(tokens: OAuthTokens): Promise<void> {
    const key = this.getKey("tokens");
    localStorage.setItem(key, JSON.stringify(tokens));
    // Clean up code verifier and last auth URL after successful token save
    localStorage.removeItem(this.getKey("code_verifier"));
    localStorage.removeItem(this.getKey("last_auth_url"));
  }

  async saveCodeVerifier(codeVerifier: string): Promise<void> {
    const key = this.getKey("code_verifier");
    this.log("info", `Saving code verifier with key: ${key}`);
    localStorage.setItem(key, codeVerifier);
  }

  async codeVerifier(): Promise<string> {
    const key = this.getKey("code_verifier");
    this.log("info", `Looking for code verifier with key: ${key}`);
    
    // Debug: List all localStorage keys that match our pattern
    const allKeys = [];
    for (let i = 0; i < localStorage.length; i++) {
      const storageKey = localStorage.key(i);
      if (storageKey && storageKey.includes('code_verifier')) {
        allKeys.push(storageKey);
      }
    }
    this.log("info", `All code_verifier keys in storage: ${JSON.stringify(allKeys)}`);
    
    const verifier = localStorage.getItem(key);
    if (!verifier) {
      this.log("error", `Code verifier not found! Expected key: ${key}, Available keys: ${JSON.stringify(allKeys)}`);
      throw new Error(
        `[${this.storageKeyPrefix}] Code verifier not found in storage for key ${key}. Auth flow likely corrupted or timed out.`
      );
    }
    // SDK's auth() retrieves this BEFORE exchanging code. Don't remove it here.
    // It will be removed in saveTokens on success.
    return verifier;
  }

  /**
   * Generates and stores the authorization URL with state, without opening a popup.
   * Used when preventAutoAuth is enabled to provide the URL for manual navigation.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   * @returns The full authorization URL with state parameter.
   */
  async prepareAuthorizationUrl(authorizationUrl: URL): Promise<string> {
    // Generate a unique state parameter for this authorization request
    const state = crypto.randomUUID();
    const stateKey = `${this.storageKeyPrefix}:state_${state}`;

    // Store context needed by the callback handler, associated with the state param
    const stateData: StoredState = {
      serverUrlHash: this.serverUrlHash,
      expiry: Date.now() + 1000 * 60 * 10, // State expires in 10 minutes
      // Store provider options needed to reconstruct on callback
      providerOptions: {
        serverUrl: this.serverUrl,
        storageKeyPrefix: this.storageKeyPrefix,
        clientName: this.clientName,
        clientUri: this.clientUri,
        callbackUrl: this.callbackUrl,
      },
    };
    localStorage.setItem(stateKey, JSON.stringify(stateData));

    // Add the state parameter to the URL
    authorizationUrl.searchParams.set("state", state);
    const authUrlString = authorizationUrl.toString();

    // Sanitize the authorization URL to prevent XSS attacks
    const sanitizedAuthUrl = sanitizeUrl(authUrlString);

    // Persist the exact auth URL in case the popup fails and manual navigation is needed
    localStorage.setItem(this.getKey("last_auth_url"), sanitizedAuthUrl);

    return sanitizedAuthUrl;
  }

  /**
   * Redirects the user agent to the authorization URL, storing necessary state.
   * This now adheres to the SDK's void return type expectation for the interface.
   * @param authorizationUrl The fully constructed authorization URL from the SDK.
   */
  async redirectToAuthorization(authorizationUrl: URL): Promise<void> {
    this.log(
      "info",
      `redirectToAuthorization called with URL: ${authorizationUrl.toString()}`
    );

    // Ideally we should catch things before we get here, but if we don't, let's not show everyone we are dum
    if (this.preventAutoAuth) {
      this.log("warn", "preventAutoAuth is enabled, not opening popup");
      return;
    }

    // Prepare the authorization URL with state
    const sanitizedAuthUrl =
      await this.prepareAuthorizationUrl(authorizationUrl);

    this.log("info", `Prepared authorization URL: ${sanitizedAuthUrl}`);

    // Attempt to open the popup
    const popupFeatures =
      "width=600,height=700,resizable=yes,scrollbars=yes,status=yes"; // Make configurable if needed
    try {
      this.log("info", "Attempting to open popup window...");
      const popup = window.open(
        sanitizedAuthUrl,
        `mcp_auth_${this.serverUrlHash}`,
        popupFeatures
      );

      this.log("info", `Popup window reference: ${popup ? "valid" : "null"}`);

      // If a callback is provided, invoke it after opening the popup
      if (this.onPopupWindow) {
        this.log("info", "Calling onPopupWindow callback");
        this.onPopupWindow(sanitizedAuthUrl, popupFeatures, popup);
      }

      if (!popup || popup.closed || typeof popup.closed === "undefined") {
        this.log(
          "warn",
          "Popup likely blocked by browser. Manual navigation might be required using the stored URL."
        );
        // Cannot signal failure back via SDK auth() directly.
        // useMcp will need to rely on timeout or manual trigger if stuck.
      } else {
        popup.focus();
        this.log("info", "Redirecting to authorization URL in popup.");
      }
    } catch (e) {
      this.log("error", `Error opening popup window: ${e}`);
      // Cannot signal failure back via SDK auth() directly.
    }
    // Regardless of popup success, the interface expects this method to initiate the redirect.
    // If the popup failed, the user journey stops here until manual action or timeout.
  }

  // --- Helper Methods ---

  /**
   * Retrieves the last URL passed to `redirectToAuthorization`. Useful for manual fallback.
   */
  getLastAttemptedAuthUrl(): string | null {
    const storedUrl = localStorage.getItem(this.getKey("last_auth_url"));
    return storedUrl ? sanitizeUrl(storedUrl) : null;
  }

  clearStorage(): number {
    const prefixPattern = `${this.storageKeyPrefix}_${this.serverUrlHash}_`;
    const statePattern = `${this.storageKeyPrefix}:state_`;
    const keysToRemove: string[] = [];
    let count = 0;

    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (!key) continue;

      if (key.startsWith(prefixPattern)) {
        keysToRemove.push(key);
      } else if (key.startsWith(statePattern)) {
        try {
          const item = localStorage.getItem(key);
          if (item) {
            // Check if state belongs to this provider instance based on serverUrlHash
            // We need to parse cautiously as the structure isn't guaranteed.
            const state = JSON.parse(item) as Partial<StoredState>;
            if (state.serverUrlHash === this.serverUrlHash) {
              keysToRemove.push(key);
            }
          }
        } catch (e) {
          this.log(
            "warn",
            `Error parsing state key ${key} during clearStorage: ${e}`
          );
          // Optionally remove malformed keys
          // keysToRemove.push(key);
        }
      }
    }

    const uniqueKeysToRemove = Array.from(new Set(keysToRemove));
    uniqueKeysToRemove.forEach((key) => {
      localStorage.removeItem(key);
      count++;
    });
    return count;
  }

  private hashString(str: string): string {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(16);
  }

  getKey(keySuffix: string): string {
    return `${this.storageKeyPrefix}_${this.serverUrlHash}_${keySuffix}`;
  }

  private log(
    level: "debug" | "info" | "warn" | "error",
    message: string
  ): void {
    this.onLog && this.onLog(level, message);
  }
}
</file>

<file path="src/ai/mcp/auth/callback.ts">
import { auth } from "@modelcontextprotocol/sdk/client/auth.js";

import { BrowserOAuthClientProvider } from "./browser-provider.js";
// Adjust path
import { StoredState } from "./types.js";

// Adjust path, ensure definition includes providerOptions

/**
 * Handles the OAuth callback using the SDK's auth() function.
 * Assumes it's running on the page specified as the callbackUrl.
 */
export async function onMcpAuthorization() {
  const queryParams = new URLSearchParams(window.location.search);
  const code = queryParams.get("code");
  const state = queryParams.get("state");
  const error = queryParams.get("error");
  const errorDescription = queryParams.get("error_description");

  const logPrefix = "[mcp-callback]"; // Generic prefix, or derive from stored state later
  console.log(`${logPrefix} Starting callback handler for URL: ${window.location.href}`);
  console.log(`${logPrefix} Handling callback...`, {
    code: code ? `${code.substring(0, 10)}...` : null,
    state,
    error,
    errorDescription,
  });

  let provider: BrowserOAuthClientProvider | null = null;
  let storedStateData: StoredState | null = null;
  const stateKey = state ? `mcp:auth:state_${state}` : null; // Reconstruct state key prefix assumption

  try {
    // --- Basic Error Handling ---
    if (error) {
      throw new Error(
        `OAuth error: ${error} - ${errorDescription || "No description provided."}`
      );
    }
    if (!code) {
      throw new Error(
        "Authorization code not found in callback query parameters."
      );
    }
    if (!state || !stateKey) {
      throw new Error(
        "State parameter not found or invalid in callback query parameters."
      );
    }

    // --- Retrieve Stored State & Provider Options ---
    const storedStateJSON = localStorage.getItem(stateKey);
    if (!storedStateJSON) {
      throw new Error(
        `Invalid or expired state parameter "${state}". No matching state found in storage.`
      );
    }
    try {
      storedStateData = JSON.parse(storedStateJSON) as StoredState;
    } catch (e) {
      throw new Error("Failed to parse stored OAuth state.");
    }

    // Validate expiry
    if (!storedStateData.expiry || storedStateData.expiry < Date.now()) {
      localStorage.removeItem(stateKey); // Clean up expired state
      throw new Error(
        "OAuth state has expired. Please try initiating authentication again."
      );
    }

    // Ensure provider options are present
    if (!storedStateData.providerOptions) {
      throw new Error("Stored state is missing required provider options.");
    }
    const { serverUrl, ...providerOptions } = storedStateData.providerOptions;

    // --- Instantiate Provider ---
    console.log(
      `${logPrefix} Re-instantiating provider for server: ${serverUrl}`
    );
    provider = new BrowserOAuthClientProvider(serverUrl, providerOptions);
    
    // Debug: Log the provider configuration
    console.log(`${logPrefix} Provider config:`, {
      serverUrl,
      storageKeyPrefix: providerOptions.storageKeyPrefix,
      serverUrlHash: provider.getKey('').split('_')[1], // Extract hash from key
      callbackUrl: providerOptions.callbackUrl,
      clientName: providerOptions.clientName
    });

    // Check what client information will be used
    const clientInfo = await provider.clientInformation();
    console.log(`${logPrefix} Client information:`, clientInfo);

    // --- Call SDK Auth Function ---
    console.log(`${logPrefix} Calling SDK auth() to exchange code...`);
    
    // Import CORS proxy setting - this should ideally be shared but for now duplicate the const
    const USE_CORS_PROXY = true; // Set to false to disable CORS proxy
    
    // Create fetch function with optional CORS proxy
    const createFetchFn = () => {
      if (!USE_CORS_PROXY) {
        // Return regular fetch when CORS proxy is disabled
        return fetch;
      }

      const CORS_PROXY_URL = "https://cors.nico.dev";
      return async (url: string | URL, init?: RequestInit): Promise<Response> => {
        const targetUrl = url.toString();
        const proxyUrl = `${CORS_PROXY_URL}?url=${encodeURIComponent(targetUrl)}`;
        console.log(`${logPrefix} Proxying request through CORS proxy: ${targetUrl} -> ${proxyUrl}`);
        console.log(`${logPrefix} Request init:`, {
          method: init?.method,
          headers: init?.headers,
          body: init?.body?.toString()
        });
        
        const response = await fetch(proxyUrl, init);
        console.log(`${logPrefix} Response status:`, response.status);
        console.log(`${logPrefix} Response headers:`, Object.fromEntries(response.headers.entries()));
        
        // Log response body for token exchange requests
        if (targetUrl.includes('token')) {
          const clonedResponse = response.clone();
          const responseText = await clonedResponse.text();
          console.log(`${logPrefix} Token exchange response body:`, responseText);
        }
        
        return response;
      };
    };

    // The SDK auth() function will internally:
    // 1. Use provider.clientInformation()
    // 2. Use provider.codeVerifier()
    // 3. Call exchangeAuthorization()
    // 4. Use provider.saveTokens() on success
    const authResult = await auth(provider, {
      serverUrl,
      authorizationCode: code,
      fetchFn: createFetchFn(),
    });

    if (authResult === "AUTHORIZED") {
      console.log(
        `${logPrefix} Authorization successful via SDK auth(). Notifying opener...`
      );
      // --- Notify Opener and Close (Success) ---
      if (window.opener && !window.opener.closed) {
        window.opener.postMessage(
          { type: "mcp_auth_callback", success: true },
          window.location.origin
        );
        window.close();
      } else {
        console.warn(
          `${logPrefix} No opener window detected. Redirecting to root.`
        );
        window.location.href = "/"; // Or a configured post-auth destination
      }
      // Clean up state ONLY on success and after notifying opener
      localStorage.removeItem(stateKey);
    } else {
      // This case shouldn't happen if `authorizationCode` is provided to `auth()`
      console.warn(
        `${logPrefix} SDK auth() returned unexpected status: ${authResult}`
      );
      throw new Error(
        `Unexpected result from authentication library: ${authResult}`
      );
    }
  } catch (err) {
    console.error(`${logPrefix} Error during OAuth callback handling:`, err);
    const errorMessage = err instanceof Error ? err.message : String(err);

    // --- Notify Opener and Display Error (Failure) ---
    if (window.opener && !window.opener.closed) {
      window.opener.postMessage(
        { type: "mcp_auth_callback", success: false, error: errorMessage },
        window.location.origin
      );
      // Optionally close even on error, depending on UX preference
      // window.close();
    }

    // Display error in the callback window
    try {
      document.body.innerHTML = `
            <div style="font-family: sans-serif; padding: 20px;">
            <h1>Authentication Error</h1>
            <p style="color: red; background-color: #ffebeb; border: 1px solid red; padding: 10px; border-radius: 4px;">
                ${errorMessage}
            </p>
            <p>You can close this window or <a href="#" onclick="window.close(); return false;">click here to close</a>.</p>
            <pre style="font-size: 0.8em; color: #555; margin-top: 20px; white-space: pre-wrap;">${
              err instanceof Error ? err.stack : ""
            }</pre>
            </div>
        `;
    } catch (displayError) {
      console.error(
        `${logPrefix} Could not display error in callback window:`,
        displayError
      );
    }
    // Clean up potentially invalid state on error
    if (stateKey) {
      localStorage.removeItem(stateKey);
    }
    // Clean up potentially dangling verifier or last_auth_url if auth failed badly
    // Note: saveTokens should clean these on success
    if (provider) {
      localStorage.removeItem(provider.getKey("code_verifier"));
      localStorage.removeItem(provider.getKey("last_auth_url"));
    }
  }
}
</file>

<file path="src/ai/mcp/auth/readme.txt">
from https://github.com/modelcontextprotocol/use-mcp/tree/main/src/auth
</file>

<file path="src/ai/mcp/auth/types.ts">
import { OAuthMetadata } from "@modelcontextprotocol/sdk/shared/auth.js";

/**
 * Internal type for storing OAuth state in localStorage during the popup flow.
 * @internal
 */
export interface StoredState {
  expiry: number;
  metadata?: OAuthMetadata; // Optional: might not be needed if auth() rediscovers
  serverUrlHash: string;
  // Add provider options needed on callback:
  providerOptions: {
    serverUrl: string;
    storageKeyPrefix: string;
    clientName: string;
    clientUri: string;
    callbackUrl: string;
  };
}
</file>

<file path="src/ai/mcp/mcpServers/builtinMcp.ts">
import MemoriesServer from "@ai/mcp/mcpServers/MemoriesServer";
import { McpServerStoreBuiltIn } from "@ai/types";

import PromiseTransport from "../PromiseTransport";
import TakePictureServer from "./TakePictureServer";

export const defaultBuiltinServers: McpServerStoreBuiltIn[] = [
  {
    name: "Take Picture",
    serverType: "take_picture",
    active: false,
    activeTools: [],
    activePrompts: [],
  },
  {
    name: "Memories",
    serverType: "memories",
    active: false,
    activeTools: [],
    activePrompts: [],
  },
];

export const getBuiltInServerTransport = (
  serverType: string
): PromiseTransport => {
  switch (serverType) {
    case "take_picture":
      return new TakePictureServer().getTransport();
    case "memories":
      return new MemoriesServer().getTransport();
    default:
      throw new Error(`Unknown built-in server type: ${serverType}`);
  }
};
</file>

<file path="src/ai/mcp/mcpServers/MemoriesServer.ts">
import type {
  JSONRPCError,
  JSONRPCRequest,
  JSONRPCResponse,
} from "@modelcontextprotocol/sdk/types.js";

import PromiseTransport, {
  type PromiseTransportConfig,
} from "../PromiseTransport";

export interface AddMemoryResult {
  success: boolean;
  memory?: string;
  error?: string;
}

export class MemoriesServer {
  private transport: PromiseTransport;

  constructor() {
    const config: PromiseTransportConfig = {
      executeRequest: async (
        request: JSONRPCRequest
      ): Promise<JSONRPCResponse | JSONRPCError> => {
        return this.handleRequest(request);
      },
      timeout: 30000,
      onConnect: async () => {
        //console.log("[MemoriesServer] Connected");
      },
    };

    this.transport = new PromiseTransport(config);
  }

  private async handleRequest(
    request: JSONRPCRequest
  ): Promise<JSONRPCResponse | JSONRPCError> {
    try {
      if (request.method === "initialize") {
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            protocolVersion: "2024-11-05",
            capabilities: {
              tools: {},
              prompts: {},
            },
            serverInfo: {
              name: "memories-server",
              version: "1.0.0",
            },
          },
        };
      }

      if (request.method === "tools/list") {
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            tools: [
              {
                name: "add_memory",
                description:
                  "Store important information about the user or conversation context in memory. Use this when the user shares personal information, preferences, or context that should be remembered for future interactions. Dont forget to add context to the memory. If the user tells you that they are 20 years old, store 'The users ager is 20 years' and not only '20' since it will be hard to make sense of the value later without this context",
                inputSchema: {
                  type: "object",
                  properties: {
                    memory: {
                      type: "string",
                      description:
                        "The memory to store, describing what should be remembered about the user or context and also the context of what this memory is about.",
                    },
                  },
                  required: ["memory"],
                  additionalProperties: false,
                },
              },
            ],
          },
        };
      }

      if (request.method === "prompts/list") {
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            prompts: [
              {
                name: "user_memories",
                description: "Retrieve all stored memories about the user",
              },
            ],
          },
        };
      }

      if (request.method === "prompts/get") {
        const params = request.params as {
          name: string;
        };

        if (params.name === "user_memories") {
          const memories = this.getStoredMemories();
          return {
            jsonrpc: "2.0",
            id: request.id,
            result: {
              description: "User memories and context",
              messages: [
                {
                  role: "user",
                  content: {
                    type: "text",
                    text:
                      memories.length > 0
                        ? `Here are the stored memories about the user:\n${memories.map((m) => `- ${m}`).join("\n")}`
                        : "No memories have been stored yet.",
                  },
                },
              ],
            },
          };
        }
      }

      if (request.method === "tools/call") {
        const params = request.params as {
          name: string;
          arguments?: {
            memory?: string;
          };
        };

        if (params.name === "add_memory") {
          const memory = params.arguments?.memory;
          if (!memory) {
            return {
              jsonrpc: "2.0",
              id: request.id,
              result: {
                content: [
                  {
                    type: "text",
                    text: "Error: Memory content is required",
                  },
                ],
              },
            };
          }

          const result = this.addMemory(memory);
          return {
            jsonrpc: "2.0",
            id: request.id,
            result: {
              content: [
                {
                  type: "text",
                  text: result.success
                    ? `Memory stored successfully: ${result.memory}`
                    : `Failed to store memory: ${result.error}`,
                },
              ],
            },
          };
        }
      }

      return {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32601,
          message: "Method not found",
        },
      } as JSONRPCError;
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32603,
          message: error instanceof Error ? error.message : "Internal error",
        },
      } as JSONRPCError;
    }
  }

  private addMemory(memory: string): AddMemoryResult {
    try {
      const existingMemories = this.getStoredMemories();
      const updatedMemories = [...existingMemories, memory];

      localStorage.setItem(
        "jarvis_user_memories",
        JSON.stringify(updatedMemories)
      );

      return {
        success: true,
        memory,
      };
    } catch (error) {
      return {
        success: false,
        error:
          error instanceof Error ? error.message : "Failed to store memory",
      };
    }
  }

  private getStoredMemories(): string[] {
    try {
      const stored = localStorage.getItem("jarvis_user_memories");
      return stored ? JSON.parse(stored) : [];
    } catch {
      return [];
    }
  }

  public getTransport(): PromiseTransport {
    return this.transport;
  }
}

export default MemoriesServer;
</file>

<file path="src/ai/mcp/mcpServers/TakePictureServer.ts">
import type {
  JSONRPCError,
  JSONRPCRequest,
  JSONRPCResponse,
} from "@modelcontextprotocol/sdk/types.js";
import { eventEmitter } from "@utils/eventEmitter";

import PromiseTransport, {
  type PromiseTransportConfig,
} from "../PromiseTransport";

export interface TakePictureResult {
  success: boolean;
  imageData?: string;
  description?: string;
  error?: string;
}

export class TakePictureServer {
  private transport: PromiseTransport;

  constructor() {
    const config: PromiseTransportConfig = {
      executeRequest: async (
        request: JSONRPCRequest
      ): Promise<JSONRPCResponse | JSONRPCError> => {
        return this.handleRequest(request);
      },
      timeout: 30000,
      onConnect: async () => {
        //console.log("[TakePictureServer] Connected");
      },
    };

    this.transport = new PromiseTransport(config);
  }

  private async handleRequest(
    request: JSONRPCRequest
  ): Promise<JSONRPCResponse | JSONRPCError> {
    try {
      if (request.method === "initialize") {
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            protocolVersion: "2024-11-05",
            capabilities: {
              tools: {},
            },
            serverInfo: {
              name: "take-picture-server",
              version: "1.0.0",
            },
          },
        };
      }

      if (request.method === "tools/list") {
        return {
          jsonrpc: "2.0",
          id: request.id,
          result: {
            tools: [
              {
                name: "take_picture",
                description:
                  'This tool captures a photo using the device camera and provides an AI-generated description of the image content. Use this tool when the user requests to take a photo, asks you to analyze or describe something in their current environment, wants to identify objects/text/scenes they can see, or asks questions like "What do you see?" or "Can you look at this?". The tool will return the content of the image. Then its your job to answer the users question based on the image content',
                inputSchema: {
                  type: "object",
                  properties: {
                    query: {
                      type: "string",
                      description:
                        "Optional question or description of what to look for in the picture. If not provided, a general description will be generated.",
                    },
                  },
                  additionalProperties: false,
                },
              },
            ],
          },
        };
      }

      if (request.method === "tools/call") {
        const params = request.params as {
          name: string;
          arguments?: {
            query?: string;
          };
        };

        if (params.name === "take_picture") {
          const query = params.arguments?.query;
          const result = await this.takePicture(query);

          return {
            jsonrpc: "2.0",
            id: request.id,
            result: {
              content: [
                {
                  type: "text",
                  text: result.success
                    ? result.description
                      ? `Picture taken successfully. Description: ${result.description}`
                      : "Picture taken successfully"
                    : `Failed to take picture: ${result.error}`,
                },
                ...(result.imageData
                  ? [
                      {
                        type: "image",
                        data: result.imageData,
                        mimeType: "image/png",
                      },
                    ]
                  : []),
              ],
            },
          };
        }
      }

      return {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32601,
          message: "Method not found",
        },
      } as JSONRPCError;
    } catch (error) {
      return {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: -32603,
          message: error instanceof Error ? error.message : "Internal error",
        },
      } as JSONRPCError;
    }
  }

  private takePicture(query?: string): Promise<TakePictureResult> {
    return new Promise((resolve) => {
      const onPictureTaken = async ({
        imageData,
        imageDescription,
      }: {
        imageData: string;
        imageDescription: string;
      }) => {
        resolve({
          success: true,
          imageData,
          description: imageDescription,
        });
        unsubscribeError();
      };

      const onPictureError = (error: string) => {
        resolve({ success: false, error });
        unsubscribePicture();
      };

      const unsubscribePicture = eventEmitter.on(
        "pictureTaken",
        onPictureTaken
      );

      const unsubscribeError = eventEmitter.on(
        "takePictureError",
        onPictureError
      );

      eventEmitter.emit("openTakePictureModal", query);
    });
  }

  public getTransport(): PromiseTransport {
    return this.transport;
  }
}

export default TakePictureServer;
</file>

<file path="src/ai/mcp/react/McpServerContext.ts">
import { createContext } from "preact";

import { McpServerContextType } from "./types";

const McpServerContextProvider =
  createContext<McpServerContextType>(null);

export default McpServerContextProvider;
</file>

<file path="src/ai/mcp/react/McpServerContextProvider.tsx">
import HttpTransport from "@ai/mcp/HttpTransport";
import { McpServer, McpState } from "@ai/mcp/McpServer";
import {
  McpServerStore,
  McpServerStoreBuiltIn,
  McpServerStoreHttp,
} from "@ai/types";
import { ComponentChildren } from "preact";
import { useEffect, useMemo, useState } from "preact/hooks";

import { getBuiltInServerTransport } from "../mcpServers/builtinMcp";
import {
  getBuiltInServers,
  getHttpServers,
  saveBuiltInServers,
  saveHttpServers,
} from "../utils/mcpServerStore";
import McpServerContext from "./McpServerContext";
import type { McpServerWithState } from "./types";

interface McpServerContextProviderProps {
  children: ComponentChildren;
}

export function McpServerContextProvider({
  children,
}: McpServerContextProviderProps) {
  const [httpServers, setHttpServers] = useState<
    Array<McpServerStoreHttp & McpServerWithState>
  >([]);
  const [builtinServers, setBuiltinServers] = useState<
    Array<McpServerStoreBuiltIn & McpServerWithState>
  >([]);
  const [error, setError] = useState<string | null>(null);

  // Helper function to create server with state tracking
  const createServerWithState = (
    serverConfig: McpServerStore
  ): McpServerWithState => {
    const server = new McpServer(
      {
        clientConfig: { name: serverConfig.name },
      },
      {
        onStateChange: (newState: McpState) => {
          const updateServerState = (servers: any[]) =>
            servers.map((s) => {
              if (s.server === server) {
                return {
                  ...s,
                  state: newState,
                  error: server.error,
                  lastStateChange: new Date(),
                };
              }
              return s;
            });

          if ("url" in serverConfig) {
            setHttpServers(updateServerState);
          } else {
            setBuiltinServers(updateServerState);
          }
        },
        onError: (error: string) => {
          const updateServerError = (servers: any[]) =>
            servers.map((s) => {
              if (s.server === server) {
                return {
                  ...s,
                  error,
                  lastStateChange: new Date(),
                };
              }
              return s;
            });

          if ("url" in serverConfig) {
            setHttpServers(updateServerError);
          } else {
            setBuiltinServers(updateServerError);
          }
        },
      }
    );

    return {
      server,
      state: server.state,
      error: server.error,
      lastStateChange: new Date(),
    };
  };

  const addHttpServer = async (name: string, url: string) => {
    const serverConfig: McpServerStoreHttp = {
      name: name.trim(),
      url: url.trim(),
      active: false,
      activeTools: [],
      activePrompts: [],
    };

    try {
      new URL(serverConfig.url);
    } catch (e) {
      throw new Error(`Invalid URL format: "${serverConfig.url}"`);
    }

    if (httpServers.find((server) => server.url === serverConfig.url)) {
      throw new Error("Server already exists");
    }

    const serverWithState = createServerWithState(serverConfig);

    await serverWithState.server.setTransport(
      new HttpTransport({
        url: serverConfig.url,
      })
    );

    await serverWithState.server.connect();

    if (serverWithState.server.state === McpState.FAILED) {
      throw new Error(
        `Server connection failed - the server may be invalid or unreachable: ${serverWithState.server.error || "Unknown connection error"}`
      );
    }

    if (serverWithState.server.state !== McpState.READY) {
      throw new Error(
        `Server connection incomplete - expected READY state but got ${serverWithState.server.state}`
      );
    }

    const newServerEntry: McpServerStoreHttp & McpServerWithState = {
      ...serverConfig,
      ...serverWithState,
      state: serverWithState.server.state,
      error: serverWithState.server.error,
    };
    setHttpServers((httpServers) => [...httpServers, newServerEntry]);
  };

  const removeHttpServer = (url: string) => {
    if (!httpServers.find((server) => server.url === url)) {
      throw new Error("Server does not exist exists");
    }

    setHttpServers((httpServers) => {
      const newServers = httpServers.filter((server) => server.url !== url);

      saveHttpServers(
        newServers.map((server) => ({
          name: server.name,
          url: server.url,
          active: server.active,
          activeTools: server.activeTools,
          activePrompts: server.activePrompts,
        }))
      );

      return newServers;
    });
  };

  const initializeServers = async () => {
    const initialHttpServers = getHttpServers().map((serverConfig) => {
      const serverWithState = createServerWithState(serverConfig);
      return {
        ...serverConfig,
        ...serverWithState,
        state: McpState.CONNECTING,
      };
    });

    const initialBuiltinServers = getBuiltInServers().map((serverConfig) => {
      const serverWithState = createServerWithState(serverConfig);
      return {
        ...serverConfig,
        ...serverWithState,
        state: McpState.CONNECTING,
      };
    });

    setHttpServers(initialHttpServers);
    setBuiltinServers(initialBuiltinServers);

    Promise.allSettled(
      getHttpServers().map(async (serverConfig) => {
        try {
          const { server } = createServerWithState(serverConfig);

          await server.setTransport(
            new HttpTransport({
              url: serverConfig.url,
            })
          );
          await server.connect();

          setHttpServers((prevServers) =>
            prevServers.map((s) =>
              s.url === serverConfig.url
                ? {
                    ...s,
                    server,
                    state: server.state,
                    error: server.error,
                  }
                : s
            )
          );
        } catch (error) {
          setHttpServers((prevServers) =>
            prevServers.map((s) =>
              s.url === serverConfig.url
                ? {
                    ...s,
                    state: McpState.FAILED,
                    error:
                      error instanceof Error ? error.message : String(error),
                  }
                : s
            )
          );
        }
      })
    );

    Promise.allSettled(
      getBuiltInServers().map(async (serverConfig) => {
        try {
          const { server } = createServerWithState(serverConfig);

          await server.setTransport(
            getBuiltInServerTransport(serverConfig.serverType)
          );
          await server.connect();

          setBuiltinServers((prevServers) =>
            prevServers.map((s) =>
              s.serverType === serverConfig.serverType
                ? {
                    ...s,
                    server,
                    state: server.state,
                    error: server.error,
                  }
                : s
            )
          );
        } catch (error) {
          setBuiltinServers((prevServers) =>
            prevServers.map((s) =>
              s.serverType === serverConfig.serverType
                ? {
                    ...s,
                    state: McpState.FAILED,
                    error:
                      error instanceof Error ? error.message : String(error),
                  }
                : s
            )
          );
        }
      })
    );
  };

  const updateServerConfig = (serverConfig: McpServerStore) => {
    if ("url" in serverConfig) {
      setHttpServers((servers) => {
        const newServers = servers.map((s) =>
          s.url === serverConfig.url ? { ...s, ...serverConfig } : s
        );

        saveHttpServers(
          newServers.map((server) => ({
            name: server.name,
            url: server.url,
            active: server.active,
            activeTools: server.activeTools,
            activePrompts: server.activePrompts,
          }))
        );

        return newServers;
      });
    }

    if ("serverType" in serverConfig) {
      setBuiltinServers((servers) => {
        const newServers = servers.map((s) =>
          s.serverType === serverConfig.serverType
            ? { ...s, ...serverConfig }
            : s
        );

        saveBuiltInServers(
          newServers.map((server) => ({
            name: server.name,
            serverType: server.serverType,
            active: server.active,
            activeTools: server.activeTools,
            activePrompts: server.activePrompts,
          }))
        );

        return newServers;
      });
    }
  };

  useEffect(() => {
    setError(null);
    initializeServers().catch((e) => {
      setError(e.message);
    });
  }, []);

  const activeServersAndTools = useMemo(() => {
    const servers = [...httpServers, ...builtinServers];
    return servers.filter((server) => {
      return server.active && server.state === McpState.READY;
    });
  }, [builtinServers, httpServers]);

  return (
    <McpServerContext
      value={{
        httpServers,
        builtinServers,
        error,
        addHttpServer,
        removeHttpServer,
        updateServerConfig,
        active: activeServersAndTools,
      }}
    >
      {children}
    </McpServerContext>
  );
}

export default McpServerContextProvider;
</file>

<file path="src/ai/mcp/react/types.ts">
import McpServer, { McpState } from "@ai/mcp/McpServer";
import {
  McpServerStore,
  McpServerStoreBuiltIn,
  McpServerStoreHttp,
} from "@ai/types";

export interface McpServerWithState {
  server: McpServer;
  state: McpState;
  error?: string;
  authUrl?: string | null;
  lastStateChange: Date;
}

export interface McpServerContextType {
  httpServers: Array<McpServerStoreHttp & McpServerWithState>;
  builtinServers: Array<McpServerStoreBuiltIn & McpServerWithState>;
  active: Array<
    (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
  >;
  error: string | null;
  addHttpServer: (name: string, url: string) => Promise<void>;
  removeHttpServer: (url: string) => void;
  updateServerConfig: (serverConfig: McpServerStore) => void;
}
</file>

<file path="src/ai/mcp/react/useMcpServer.ts">
import { useContext } from "preact/hooks";

import McpServerContext from "./McpServerContext";

const useMcpServer = () => {
  return useContext(McpServerContext);
};

export default useMcpServer;
</file>

<file path="src/ai/mcp/utils/mcpServerStore.ts">
import { McpServerStoreBuiltIn, McpServerStoreHttp } from "@ai/types";
import localStorage from "@utils/LocalStorage";
import {
  MCP_BUILTIN_SERVERS_STORAGE_KEY,
  MCP_SERVERS_STORAGE_KEY,
} from "@utils/constants";

import { defaultBuiltinServers } from "../mcpServers/builtinMcp";

export const saveBuiltInServers = (
  servers: Array<McpServerStoreBuiltIn> = []
) => localStorage.setItem(MCP_BUILTIN_SERVERS_STORAGE_KEY, servers);

export const getBuiltInServers = (): Array<McpServerStoreBuiltIn> => {
  const savedServers =
    localStorage.getItem<Array<McpServerStoreBuiltIn>>(
      MCP_BUILTIN_SERVERS_STORAGE_KEY
    ) ?? [];

  return defaultBuiltinServers.map((server) => {
    const saved =
      savedServers.find((s) => s.serverType === server.serverType) || {};
    return { ...server, ...saved };
  });
};

export const saveHttpServers = (servers: Array<McpServerStoreHttp> = []) =>
  localStorage.setItem(MCP_SERVERS_STORAGE_KEY, servers);

export const getHttpServers = () =>
  localStorage.getItem<Array<McpServerStoreHttp>>(MCP_SERVERS_STORAGE_KEY) ||
  [];
</file>

<file path="src/ai/mcp/HttpTransport.ts">
import { auth } from "@modelcontextprotocol/sdk/client/auth.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import { sanitizeUrl } from "strict-url-sanitise";

import { BrowserOAuthClientProvider } from "./auth/browser-provider";
import { McpTransport } from "./types";

export interface HttpTransportConfig {
  url: string;
  customHeaders?: Record<string, string>;
  requestInit?: RequestInit;
  authClientName?: string;
  authClientUri?: string;
  authCallbackUrl?: string;
}

const AUTH_TIMEOUT = 5 * 60 * 1000; // // 5 minute
const USE_CORS_PROXY = false; // Set to false to disable CORS proxy

export class HttpTransport implements McpTransport {
  private config: HttpTransportConfig;
  private transport: Transport | null = null;
  private connected = false;
  private authProvider: BrowserOAuthClientProvider | null = null;
  private _isAuthenticating = false;

  constructor(config: HttpTransportConfig) {
    this.config = {
      customHeaders: {},
      ...config,
    };
  }

  async connect(): Promise<Transport> {
    if (this.connected && this.transport) {
      return this.transport;
    }

    // Try to create transport with existing auth token if available
    await this.createTransport();
    this.connected = true;
    return this.transport!;
  }

  private async createTransport(): Promise<void> {
    if (!this.authProvider) {
      this.authProvider = new BrowserOAuthClientProvider(this.config.url, {
        clientName: this.config.authClientName || "MCP Client",
        clientUri: this.config.authClientUri || window.location.origin,
        callbackUrl:
          this.config.authCallbackUrl ||
          new URL("/oauth/callback", window.location.origin).toString(),
        onLog: (level, message) => this.log(level, `[OAuth] ${message}`),
      });

      // Debug: Log the provider configuration
      this.log("debug", `Provider created with config:`, {
        serverUrl: this.config.url,
        clientName: this.config.authClientName || "MCP Client",
        clientUri: this.config.authClientUri || window.location.origin,
        callbackUrl:
          this.config.authCallbackUrl ||
          new URL("/oauth/callback", window.location.origin).toString(),
      });
    }

    const headers: Record<string, string> = {
      Accept: "application/json",
      ...this.config.customHeaders,
    };

    const tokens = await this.authProvider.tokens();
    if (tokens?.access_token) {
      headers.Authorization = `Bearer ${tokens.access_token}`;
    }

    const options = {
      requestInit: {
        headers,
        ...this.config.requestInit,
      },
      fetch: this.createProxyFetch(),
    };

    const sanitizedUrl = sanitizeUrl(this.config.url);
    const targetUrl = new URL(sanitizedUrl);

    const baseTransport = new StreamableHTTPClientTransport(targetUrl, options);
    this.transport = this.createAuthInterceptor(baseTransport);
  }

  private createProxyFetch() {
    if (!USE_CORS_PROXY) {
      // Return regular fetch when CORS proxy is disabled
      return fetch;
    }

    const CORS_PROXY_URL = "https://cors.nico.dev";

    return async (url: string | URL, init?: RequestInit): Promise<Response> => {
      const targetUrl = url.toString();
      const proxyUrl = `${CORS_PROXY_URL}?url=${encodeURIComponent(targetUrl)}`;

      this.log(
        "debug",
        `Proxying request through CORS proxy: ${targetUrl} -> ${proxyUrl}`
      );

      // Log token exchange requests
      if (targetUrl.includes("token")) {
        this.log("debug", `Token exchange request init:`, init);
      }

      const response = await fetch(proxyUrl, init);

      // Log token exchange responses
      if (targetUrl.includes("token")) {
        this.log("debug", `Token exchange response status:`, response.status);
        const clonedResponse = response.clone();
        const responseText = await clonedResponse.text();
        this.log("debug", `Token exchange response body:`, responseText);
      }

      return response;
    };
  }

  private createAuthInterceptor(
    baseTransport: StreamableHTTPClientTransport
  ): Transport {
    const proxy = new Proxy(baseTransport, {
      set: (target, prop, value) => {
        if (prop === "onmessage" && typeof value === "function") {
          const originalCallback = value;
          (target as any)[prop] = (message: any, extra?: any) => {
            if (message && typeof message === "object" && "error" in message) {
              const error = message.error;
              if (this.isAuthError(error) && !this._isAuthenticating) {
                this.log("info", "Auth error detected, starting auth flow...");
                this.performAuthFlow().catch((authError) => {
                  this.log("error", "Auth flow failed:", authError);
                });
                // Don't continue processing this error message
                return;
              }
            }

            originalCallback(message, extra);
          };
          return true;
        }

        if (prop === "onerror" && typeof value === "function") {
          const originalErrorCallback = value;
          (target as any)[prop] = (error: Error) => {
            this.log("debug", "Transport onerror called:", error);

            if (this.isAuthError(error) && !this._isAuthenticating) {
              this.log(
                "info",
                "Auth error detected via onerror, starting auth flow..."
              );

              this.performAuthFlow()
                .then(async () => {
                  this.log("info", "Auth completed, reconnecting...");
                  // Don't recreate here - let the MCP client handle reconnection
                  // The next connection attempt will have the auth token
                })
                .catch((authError) => {
                  this.log("error", "Auth flow failed:", authError);
                  // Pass the original error to the client
                  originalErrorCallback(error);
                });

              // Don't pass the auth error to the client immediately
              return;
            }

            // Pass through non-auth errors
            originalErrorCallback(error);
          };
          return true;
        }

        (target as any)[prop] = value;
        return true;
      },
    });

    // Override the start method to handle auth errors during connection
    const originalStart = baseTransport.start.bind(baseTransport);
    proxy.start = async () => {
      try {
        this.log("debug", "Starting transport...");
        await originalStart();
        this.log("debug", "Transport started successfully");
      } catch (error) {
        this.log("error", "Transport start failed:", error);
        this.log(
          "debug",
          `Error type: ${typeof error}, isAuthError: ${this.isAuthError(error)}, isAuthenticating: ${this._isAuthenticating}`
        );

        if (this.isAuthError(error) && !this._isAuthenticating) {
          this.log(
            "info",
            "Auth required for connection, starting auth flow..."
          );

          await this.performAuthFlow();

          // Recreate the base transport with the new auth token
          await this.recreateTransportAfterAuth();

          // Start the newly created transport (which will be the updated this.transport)
          if (this.transport && this.transport !== proxy) {
            this.log(
              "debug",
              "Starting newly created authenticated transport..."
            );
            await this.transport.start();
          }
        } else {
          this.log(
            "error",
            "Non-auth error or already authenticating, rethrowing"
          );
          throw error;
        }
      }
    };

    return proxy;
  }

  private async recreateTransportAfterAuth(): Promise<void> {
    // Close the existing transport if it exists
    if (this.transport) {
      try {
        await this.transport.close();
      } catch (e) {
        // Ignore close errors
      }
      this.transport = null;
    }

    // Create a new transport with the updated auth token
    await this.createTransport();
  }

  private isAuthError(error: any): boolean {
    this.log("debug", `Checking if error is auth error:`, error);

    // Handle Error objects
    if (error instanceof Error) {
      const message = error.message;
      this.log("debug", `Error message: "${message}"`);

      if (
        message.includes("Unauthorized") ||
        message.includes("Bearer token required") ||
        message.includes("401") ||
        message.includes("403") ||
        message.includes("missing required Authorization header")
      ) {
        this.log("debug", "Detected as auth error via Error message");
        return true;
      }
    }

    // Check for JSON-RPC auth errors
    if (error?.code === -32603 && error?.message?.includes("Unauthorized")) {
      this.log("debug", "Detected as JSON-RPC auth error (Unauthorized)");
      return true;
    }
    if (
      error?.code === -32603 &&
      error?.message?.includes("Bearer token required")
    ) {
      this.log(
        "debug",
        "Detected as JSON-RPC auth error (Bearer token required)"
      );
      return true;
    }

    // Check for HTTP status codes
    if (error?.status === 401 || error?.status === 403) {
      this.log(
        "debug",
        `Detected as auth error via HTTP status: ${error.status}`
      );
      return true;
    }

    this.log("debug", "Not detected as auth error");
    return false;
  }

  private async performAuthFlow(): Promise<void> {
    this.log(
      "debug",
      `performAuthFlow called - isAuthenticating: ${this._isAuthenticating}, authProvider: ${!!this.authProvider}`
    );

    if (this._isAuthenticating) {
      this.log(
        "debug",
        "performAuthFlow early return - already authenticating"
      );
      return;
    }

    // Create auth provider if it doesn't exist
    if (!this.authProvider) {
      this.log("debug", "Creating auth provider for OAuth flow");
      this.authProvider = new BrowserOAuthClientProvider(this.config.url, {
        clientName: this.config.authClientName || "MCP Client",
        clientUri: this.config.authClientUri || window.location.origin,
        callbackUrl:
          this.config.authCallbackUrl ||
          new URL("/oauth/callback", window.location.origin).toString(),
        onLog: (level, message) => this.log(level, `[OAuth] ${message}`),
      });
    }

    this._isAuthenticating = true;
    try {
      // Check if we already have tokens
      const existingTokens = await this.authProvider.tokens();
      this.log(
        "debug",
        `Existing tokens: ${existingTokens ? "present" : "none"}`
      );

      this.log("info", "Starting OAuth flow...");
      const result = await auth(this.authProvider, {
        serverUrl: this.config.url,
        fetchFn: this.createProxyFetch(),
      });

      this.log("debug", `OAuth flow result: ${result}`);

      if (result === "AUTHORIZED") {
        this.log(
          "info",
          "Authentication successful - user already had valid tokens"
        );
        // Auth completed immediately, recreate transport
        await this.createTransport();
        this._isAuthenticating = false;
      } else if (result === "REDIRECT") {
        this.log(
          "info",
          "OAuth popup should have opened - waiting for user to complete authentication"
        );

        this.waitForAuthCompletion();
      } else {
        this.log("error", `Unexpected auth result: ${result}`);
        this._isAuthenticating = false;
      }
    } catch (error) {
      this.log("error", "Auth flow error:", error);
      this.log(
        "error",
        "Auth flow error details:",
        JSON.stringify(error, Object.getOwnPropertyNames(error))
      );
      if (error instanceof Error) {
        this.log("error", "Auth flow error message:", error.message);
        this.log("error", "Auth flow error stack:", error.stack);
      }
      this._isAuthenticating = false;
    }
  }

  private waitForAuthCompletion(): void {
    const handleAuthMessage = (event: MessageEvent) => {
      if (event.data?.type === "mcp_auth_callback") {
        window.removeEventListener("message", handleAuthMessage);
        if (event.data.success) {
          if (this.transport) {
            this.transport.close().catch(() => {
              // Ignore errors during cleanup
            });
            this.transport = null;
            this.connected = false;
          }

          window.setTimeout(() => {
            this.createTransport()
              .then(() => {
                this.connected = true;
              })
              .catch((error) => {
                this.log(
                  "error",
                  "Failed to recreate transport after auth:",
                  error
                );
              })
              .finally(() => {
                this._isAuthenticating = false;
              });
          }, 100);
        } else {
          this.log("error", "Auth failed:", event.data.error);
          this._isAuthenticating = false;
        }
      }
    };

    window.addEventListener("message", handleAuthMessage);
    window.setTimeout(() => {
      window.removeEventListener("message", handleAuthMessage);
      this._isAuthenticating = false;
    }, AUTH_TIMEOUT);
  }

  async disconnect(): Promise<void> {
    if (this.transport) {
      await this.transport.close();
      this.transport = null;
    }
    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected;
  }

  public isAuthenticating(): boolean {
    return this._isAuthenticating;
  }

  private log(
    level: "debug" | "info" | "warn" | "error",
    message: string,
    ...args: unknown[]
  ): void {
    const fullMessage =
      args.length > 0
        ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}`
        : message;

    //console[level](`[Mcp HttpTransport] ${fullMessage}`);
  }
}

export default HttpTransport;
</file>

<file path="src/ai/mcp/McpServer.ts">
import { McpTransport } from "@ai/mcp/types";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import {
  CallToolResultSchema,
  GetPromptResultSchema,
  JSONRPCMessage,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListToolsResultSchema,
  Prompt,
  ReadResourceResultSchema,
  Resource,
  ResourceTemplate,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";

export enum McpState {
  IDLE = "idle",
  CONNECTING = "connecting",
  LOADING = "loading",
  READY = "ready",
  FAILED = "failed",
}

export interface McpConfig {
  clientConfig?: {
    name?: string;
    version?: string;
  };
  debug?: boolean;
  autoRetry?: boolean | number;
  autoReconnect?: boolean | number;
}

export interface McpCallbacks {
  onStateChange?: (state: McpState) => void;
  onToolsChange?: (tools: Tool[]) => void;
  onResourcesChange?: (
    resources: Resource[],
    templates: ResourceTemplate[]
  ) => void;
  onPromptsChange?: (prompts: Prompt[]) => void;
  onError?: (error: string) => void;
  onLog?: (level: "debug" | "info" | "warn" | "error", message: string) => void;
}

export class McpServer {
  public config: McpConfig;
  private callbacks: McpCallbacks;
  private client: Client | null = null;
  private mcpTransport: McpTransport | null = null;

  private _state: McpState = McpState.IDLE;
  private _tools: Tool[] = [];
  private _resources: Resource[] = [];
  private _resourceTemplates: ResourceTemplate[] = [];
  private _prompts: Prompt[] = [];
  private _error: string | undefined;

  private connecting = false;
  private connectAttempt = 0;

  private readonly DEFAULT_RECONNECT_DELAY = 3000;

  constructor(config: McpConfig = {}, callbacks: McpCallbacks = {}) {
    this.config = {
      clientConfig: {
        name: "mcp-client",
        version: "0.1.0",
        ...config.clientConfig,
      },
      debug: false,
      autoRetry: false,
      autoReconnect: this.DEFAULT_RECONNECT_DELAY,
      ...config,
    };
    this.callbacks = callbacks;

    this.initializeClient();
  }

  get state() {
    return this._state;
  }
  get tools() {
    return this._tools;
  }
  get resources() {
    return this._resources;
  }
  get resourceTemplates() {
    return this._resourceTemplates;
  }
  get prompts() {
    return this._prompts;
  }
  get error() {
    return this._error;
  }

  public async setTransport(transport: McpTransport): Promise<void> {
    if (this.mcpTransport) {
      await this.disconnect();
    }

    this.mcpTransport = transport;
  }

  public async connect(): Promise<void> {
    if (this.connecting) {
      this.log("debug", "Connection attempt already in progress.");
      return;
    }

    if (!this.mcpTransport) {
      throw new Error(
        "No transport configured. Call setTransport() or setHttpUrl() first."
      );
    }

    this.connecting = true;
    this.connectAttempt += 1;
    this.setState(McpState.CONNECTING);
    this.setError(undefined);

    this.log("info", `Connecting attempt #${this.connectAttempt}...`);

    try {
      await this.tryConnect();
    } catch (error) {
      await this.handleConnectionError(error);
    } finally {
      this.connecting = false;
    }
  }

  private async tryConnect(): Promise<void> {
    const transport = await this.mcpTransport!.connect();

    this.setupTransportHandlers(transport);

    try {
      this.log("info", "Connecting client...");
      await this.client!.connect(transport);

      this.setState(McpState.LOADING);
      await this.loadData();

      this.setState(McpState.READY);
      this.connectAttempt = 0;
      this.log("info", "Connection successful");
    } catch (error) {
      throw error;
    }
  }

  public async disconnect(): Promise<void> {
    this.log("info", "Disconnecting...");
    this.connecting = false;

    if (this.mcpTransport) {
      try {
        await this.mcpTransport.disconnect();
      } catch (err) {
        this.log("warn", "Error disconnecting transport:", err);
      }
    }

    this.setState(McpState.IDLE);
    this.setTools([]);
    this.setResources([], []);
    this.setPrompts([]);
    this.setError(undefined);
  }

  public async callTool(name: string, args?: Record<string, unknown>) {
    if (this.state !== McpState.READY || !this.client) {
      throw new Error(
        `MCP client is not ready (current state: ${this.state}). Cannot call tool "${name}".`
      );
    }

    this.log("info", `Calling tool: ${name}`, args);

    try {
      const result = await this.client.request(
        { method: "tools/call", params: { name, arguments: args } },
        CallToolResultSchema
      );
      this.log("info", `Tool "${name}" call successful`);
      return result;
    } catch (error) {
      const errorInstance =
        error instanceof Error ? error : new Error(String(error));

      const isAuthenticating = this.mcpTransport?.isAuthenticating?.() ?? false;
      const isConnectionError =
        errorInstance.message.includes("Connection closed");
      // isConnectionClosed indicates that the transoprt closed the connection because of the auth flow
      const isConnectionClosed = this.isConnectionClosed(errorInstance);
      this.log("warn", `isConnectionClosed`, isConnectionClosed);
      this.log("warn", `isAuthenticating`, isAuthenticating);
      if (isConnectionClosed && isAuthenticating) {
        this.log(
          "debug",
          `Auth error detected for tool "${name}", waiting for authentication...`
        );

        try {
          await this.waitForAuthCompletion();
          this.log("debug", `Auth completed, retrying tool "${name}"`);

          // Retry the request after auth completion
          const result = await this.client.request(
            { method: "tools/call", params: { name, arguments: args } },
            CallToolResultSchema
          );
          this.log("info", `Tool "${name}" call successful after auth`);
          return result;
        } catch (retryError) {
          this.log(
            "error",
            `Error calling tool "${name}" after auth retry: ${retryError instanceof Error ? retryError.message : String(retryError)}`
          );
          throw retryError;
        }
      }

      // For non-auth errors or when already authenticating, handle normally
      if (!isAuthenticating || !isConnectionError) {
        this.log(
          "error",
          `Error calling tool "${name}": ${errorInstance.message}`
        );
      }

      throw error;
    }
  }

  private isConnectionClosed(error: Error): boolean {
    return error.message.includes("Connection closed");
  }

  private async waitForAuthCompletion(timeout: number = 60000): Promise<void> {
    return new Promise((resolve, reject) => {
      const startTime = Date.now();

      const checkAuth = () => {
        const isAuthenticating =
          this.mcpTransport?.isAuthenticating?.() ?? false;
        const isReady = this.state === McpState.READY;

        this.log(
          "debug",
          `Waiting for auth completion - isAuthenticating: ${isAuthenticating}, state: ${this.state}`
        );

        if (!isAuthenticating && isReady) {
          this.log("debug", "Auth and reconnection completed");
          resolve();
          return;
        }

        if (Date.now() - startTime > timeout) {
          reject(new Error("Authentication timeout"));
          return;
        }

        setTimeout(checkAuth, 100);
      };

      checkAuth();
    });
  }

  public async listResources() {
    if (this.state !== McpState.READY || !this.client) {
      throw new Error(
        `MCP client is not ready (current state: ${this.state}). Cannot list resources.`
      );
    }

    this.log("info", "Listing resources...");

    try {
      const response = await this.client.request(
        { method: "resources/list" },
        ListResourcesResultSchema
      );

      this.setResources(
        response.resources,
        Array.isArray(response.resourceTemplates)
          ? response.resourceTemplates
          : []
      );

      this.log("info", `Listed ${response.resources.length} resources`);
    } catch (error) {
      this.log(
        "error",
        `Error listing resources: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  public async readResource(uri: string) {
    if (this.state !== McpState.READY || !this.client) {
      throw new Error(
        `MCP client is not ready (current state: ${this.state}). Cannot read resource "${uri}".`
      );
    }

    this.log("info", `Reading resource: ${uri}`);

    try {
      const result = await this.client.request(
        { method: "resources/read", params: { uri } },
        ReadResourceResultSchema
      );
      this.log("info", `Resource "${uri}" read successfully`);
      return result;
    } catch (error) {
      this.log(
        "error",
        `Error reading resource "${uri}": ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  public async listPrompts() {
    if (this.state !== McpState.READY || !this.client) {
      throw new Error(
        `MCP client is not ready (current state: ${this.state}). Cannot list prompts.`
      );
    }

    this.log("info", "Listing prompts...");

    try {
      const response = await this.client.request(
        { method: "prompts/list" },
        ListPromptsResultSchema
      );

      this.setPrompts(response.prompts);
      this.log("info", `Listed ${response.prompts.length} prompts`);
    } catch (error) {
      this.log(
        "error",
        `Error listing prompts: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  public async getPrompt(name: string, args?: Record<string, string>) {
    if (this.state !== McpState.READY || !this.client) {
      throw new Error(
        `MCP client is not ready (current state: ${this.state}). Cannot get prompt "${name}".`
      );
    }

    this.log("info", `Getting prompt: ${name}`, args);

    try {
      const result = await this.client.request(
        { method: "prompts/get", params: { name, arguments: args } },
        GetPromptResultSchema
      );
      this.log("info", `Prompt "${name}" retrieved successfully`);
      return result;
    } catch (error) {
      this.log(
        "error",
        `Error getting prompt "${name}": ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }

  private initializeClient(): void {
    this.client = new Client(
      {
        name: this.config.clientConfig?.name || "mcp-client",
        version: this.config.clientConfig?.version || "0.1.0",
      },
      { capabilities: {} }
    );
  }

  private setupTransportHandlers(transport: Transport): void {
    transport.onmessage = (message: JSONRPCMessage) => {
      this.log("debug", `[Transport] Received: ${JSON.stringify(message)}`);
      // @ts-ignore
      this.client?.handleMessage?.(message);
    };

    transport.onerror = (err: Error) => {
      this.log("warn", `Transport error: ${err.message}`);
      this.failConnection(`Transport error: ${err.message}`, err);
    };

    transport.onclose = () => {
      const isAuthenticating = this.mcpTransport?.isAuthenticating?.() ?? false;

      if (
        !this.connecting &&
        this.state === McpState.READY &&
        this.config.autoReconnect
      ) {
        const delay =
          typeof this.config.autoReconnect === "number"
            ? this.config.autoReconnect
            : this.DEFAULT_RECONNECT_DELAY;

        // Only log reconnection message if not authenticating
        if (!isAuthenticating) {
          this.log(
            "info",
            `Connection closed, attempting to reconnect in ${delay}ms...`
          );
        }
        this.setState(McpState.CONNECTING);

        setTimeout(() => {
          this.connect();
        }, delay);
      } else if (this.state !== McpState.FAILED) {
        this.failConnection("Connection closed unexpectedly.");
      }
    };
  }

  private async loadData(): Promise<void> {
    const toolsResponse = await this.client!.request(
      { method: "tools/list" },
      ListToolsResultSchema
    );
    this.setTools(toolsResponse.tools);

    try {
      const resourcesResponse = await this.client!.request(
        { method: "resources/list" },
        ListResourcesResultSchema
      );
      this.setResources(
        resourcesResponse.resources,
        Array.isArray(resourcesResponse.resourceTemplates)
          ? resourcesResponse.resourceTemplates
          : []
      );
    } catch (err) {
      this.log("debug", "Server does not support resources/list method");
    }

    try {
      const promptsResponse = await this.client!.request(
        { method: "prompts/list" },
        ListPromptsResultSchema
      );
      this.setPrompts(promptsResponse.prompts);
    } catch (err) {
      this.log("debug", "Server does not support prompts/list method");
    }

    const summary = [
      `Loaded ${toolsResponse.tools.length} tools`,
      `${this.resources.length} resources`,
      `${this.prompts.length} prompts`,
    ];
    this.log("info", summary.join(", "));
  }

  private async handleConnectionError(error: unknown): Promise<void> {
    const errorInstance =
      error instanceof Error ? error : new Error(String(error));
    this.failConnection(
      `Failed to connect: ${errorInstance.message}`,
      errorInstance
    );
  }

  private failConnection(errorMessage: string, connectionError?: Error): void {
    this.log("error", errorMessage, connectionError ?? "");
    this.setState(McpState.FAILED);
    this.setError(errorMessage);
    this.connecting = false;
  }

  private setState(state: McpState): void {
    this._state = state;
    this.callbacks.onStateChange?.(state);
  }

  private setTools(tools: Tool[]): void {
    this._tools = tools;
    this.callbacks.onToolsChange?.(tools);
  }

  private setResources(
    resources: Resource[],
    templates: ResourceTemplate[]
  ): void {
    this._resources = resources;
    this._resourceTemplates = templates;
    this.callbacks.onResourcesChange?.(resources, templates);
  }

  private setPrompts(prompts: Prompt[]): void {
    this._prompts = prompts;
    this.callbacks.onPromptsChange?.(prompts);
  }

  private setError(error: string | undefined): void {
    this._error = error;
    if (error) {
      this.callbacks.onError?.(error);
    }
  }

  private log(
    level: "debug" | "info" | "warn" | "error",
    message: string,
    ...args: unknown[]
  ): void {
    const fullMessage =
      args.length > 0
        ? `${message} ${args.map((arg) => JSON.stringify(arg)).join(" ")}`
        : message;

    //console[level](`[Mcp] ${fullMessage}`);
    this.callbacks.onLog?.(level, fullMessage);
  }
}

export default McpServer;
</file>

<file path="src/ai/mcp/PromiseTransport.ts">
import { McpTransport } from "@ai/mcp/types";
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";
import type {
  JSONRPCError,
  JSONRPCMessage,
  JSONRPCRequest,
  JSONRPCResponse,
} from "@modelcontextprotocol/sdk/types.js";

export interface PromiseTransportConfig {
  /**
   * Function that executes MCP requests via promises
   * This could be a function that:
   * - Calls a local service/worker
   * - Executes code directly in the browser
   * - Communicates with a browser extension
   * - Uses WebRTC, WebSocket, or other protocols
   */
  executeRequest: (
    request: JSONRPCRequest
  ) => Promise<JSONRPCResponse | JSONRPCError>;

  /**
   * Optional function to handle transport-level setup
   */
  onConnect?: () => Promise<void>;

  /**
   * Optional function to handle transport-level cleanup
   */
  onDisconnect?: () => Promise<void>;

  /**
   * Optional timeout for requests (default: 30000ms)
   */
  timeout?: number;
}

class PromiseTransport implements McpTransport {
  private config: PromiseTransportConfig;
  private transport: PromiseTransportInstance | null = null;
  private connected = false;

  constructor(config: PromiseTransportConfig) {
    this.config = {
      timeout: 30000,
      ...config,
    };
  }

  async connect(): Promise<Transport> {
    if (this.connected && this.transport) {
      return this.transport;
    }

    if (this.config.onConnect) {
      await this.config.onConnect();
    }

    this.transport = new PromiseTransportInstance(this.config);
    this.connected = true;
    return this.transport;
  }

  async disconnect(): Promise<void> {
    if (this.transport) {
      await this.transport.close();
      this.transport = null;
    }

    // Call cleanup function if provided
    if (this.config.onDisconnect) {
      await this.config.onDisconnect();
    }

    this.connected = false;
  }

  isConnected(): boolean {
    return this.connected;
  }
}

class PromiseTransportInstance implements Transport {
  private config: PromiseTransportConfig;
  private pendingRequests = new Map<
    string | number,
    {
      resolve: (response: JSONRPCResponse) => void;
      reject: (error: Error) => void;
      timeout: number;
    }
  >();

  public onmessage?: (message: JSONRPCMessage) => void;
  public onerror?: (error: Error) => void;
  public onclose?: () => void;

  constructor(config: PromiseTransportConfig) {
    this.config = config;
  }

  async start(): Promise<void> {
    // Promise transport is ready immediately
  }

  async send(message: JSONRPCMessage): Promise<void> {
    try {
      if (this.isRequest(message)) {
        // Handle request - execute via promise and send response
        const response = await this.executeRequest(message);

        // Notify message handler with the response
        if (this.onmessage) {
          this.onmessage(response);
        }
      } else if (this.isResponse(message)) {
        // Handle response - resolve pending request
        const pending = this.pendingRequests.get(message.id);
        if (pending) {
          clearTimeout(pending.timeout);
          this.pendingRequests.delete(message.id);
          pending.resolve(message);
        }
      } else {
        // Handle notification - just pass through
        if (this.onmessage) {
          this.onmessage(message);
        }
      }
    } catch (error) {
      if (this.onerror) {
        this.onerror(error instanceof Error ? error : new Error(String(error)));
      }
    }
  }

  async close(): Promise<void> {
    // Reject all pending requests
    for (const [id, pending] of this.pendingRequests) {
      clearTimeout(pending.timeout);
      pending.reject(new Error("Transport closed"));
    }
    this.pendingRequests.clear();

    // Notify close handler
    if (this.onclose) {
      this.onclose();
    }
  }

  private async executeRequest(
    request: JSONRPCRequest
  ): Promise<JSONRPCResponse | JSONRPCError> {
    return new Promise((resolve, reject) => {
      // Set up timeout
      const timeoutId = window.setTimeout(() => {
        this.pendingRequests.delete(request.id);
        reject(new Error(`Request timeout after ${this.config.timeout}ms`));
      }, this.config.timeout);

      // Store pending request
      this.pendingRequests.set(request.id, {
        resolve,
        reject,
        timeout: timeoutId,
      });

      // Execute the request via the provided function
      this.config
        .executeRequest(request)
        .then((response) => {
          const pending = this.pendingRequests.get(request.id);
          if (pending) {
            clearTimeout(pending.timeout);
            this.pendingRequests.delete(request.id);
            // @ts-ignore
            pending.resolve(response);
          }
        })
        .catch((error) => {
          const pending = this.pendingRequests.get(request.id);
          if (pending) {
            clearTimeout(pending.timeout);
            this.pendingRequests.delete(request.id);
            pending.reject(
              error instanceof Error ? error : new Error(String(error))
            );
          }
        });
    });
  }

  private isRequest(message: JSONRPCMessage): message is JSONRPCRequest {
    return "method" in message && "id" in message;
  }

  private isResponse(message: JSONRPCMessage): message is JSONRPCResponse {
    return "id" in message && ("result" in message || "error" in message);
  }
}

export default PromiseTransport;
</file>

<file path="src/ai/mcp/types.ts">
import type { Transport } from "@modelcontextprotocol/sdk/shared/transport.js";

export interface McpTransport {
  connect(): Promise<Transport>;
  disconnect(): Promise<void>;
  isConnected(): boolean;
  isAuthenticating?(): boolean;
}
</file>

<file path="src/ai/speechToText/constants.ts">
export const MODEL_ID = "Xenova/whisper-base.en";

export const MODEL_ONNX_URL_BASE = `https://huggingface.co/${MODEL_ID}/resolve/main/`;

export const EXPECTED_FILES = {
  "config.json": 2202,
  "generation_config.json": 1500,
  "onnx/decoder_model_merged.onnx": 208558935,
  "onnx/encoder_model.onnx": 82474863,
  "preprocessor_config.json": 339,
  "tokenizer.json": 2128494,
  "tokenizer_config.json": 835,
};
</file>

<file path="src/ai/speechToText/SpeechToText.ts">
import {
  SpeechToTextWorkerMessage,
  SpeechToTextWorkerResponse,
} from "@ai/speechToText/types";
import isFileInCache from "@utils/isFileInCache";

import { EXPECTED_FILES, MODEL_ONNX_URL_BASE } from "./constants";

class SpeechToText {
  private worker: Worker;
  private id: number = 0;

  constructor() {
    this.worker = new Worker(new URL("./worker.ts", import.meta.url), {
      type: "module",
    });
  }

  public preload(
    callback: (progress: number) => void = () => {}
  ): Promise<void> {
    return new Promise((resolve) => {
      // Send a small dummy audio buffer to initialize the model
      const dummyAudio = new Float32Array(16000); // 1 second of silence at 16kHz
      this.generate(dummyAudio, 16000, callback)
        .then(() => resolve())
        .catch(() => {
          // Ignore errors during preload - this is just to initialize the model
        });
    });
  }

  public async generate(
    audioData: Float32Array,
    sampleRate: number = 16000,
    progressCallback: (progress: number) => void = () => {}
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const id = (this.id++).toString();

      const files: Record<string, { total: number; loaded: number }> =
        Object.entries(EXPECTED_FILES).reduce(
          (acc, [file, total]) => ({
            ...acc,
            [file]: {
              total,
              loaded: 0,
            },
          }),
          {}
        );

      const listener = (e: MessageEvent<SpeechToTextWorkerResponse>) => {
        if (e.data.id !== id) return;

        if (e.data.status === "progress") {
          if (e.data.progress.status === "progress") {
            files[e.data.progress.file] = {
              loaded: e.data.progress.loaded,
              total: e.data.progress.total,
            };
            const { total, loaded } = Object.entries(files).reduce(
              (acc, [file, progress]) => ({
                total: acc.total + progress.total,
                loaded: acc.loaded + progress.loaded,
              }),
              { total: 0, loaded: 0 }
            );
            progressCallback(Math.round((loaded / total) * 100));
          }
        }

        if (e.data.status === "complete") {
          this.worker.removeEventListener("message", listener);
          resolve(e.data.text || "");
        }

        if (e.data.status === "error") {
          this.worker.removeEventListener("message", listener);
          reject(new Error(e.data.error || "Speech to text failed"));
        }
      };

      this.worker.addEventListener("message", listener);

      this.worker.postMessage(
        {
          id,
          audioData,
          sampleRate,
        } as SpeechToTextWorkerMessage,
        [audioData.buffer]
      );
    });
  }

  public async generateFromBlob(audioBlob: Blob): Promise<string> {
    const audioData = await this.processAudioBlob(audioBlob);
    return this.generate(audioData.data, audioData.sampleRate);
  }

  private async processAudioBlob(
    blob: Blob
  ): Promise<{ data: Float32Array; sampleRate: number }> {
    const arrayBuffer = await blob.arrayBuffer();
    const audioContext = new (window.AudioContext ||
      (window as any).webkitAudioContext)();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    let audioData = audioBuffer.getChannelData(0);
    if (audioBuffer.sampleRate !== 16000) {
      audioData = this.resampleAudio(audioData, audioBuffer.sampleRate, 16000);
    }

    return {
      data: audioData,
      sampleRate: 16000,
    };
  }

  public isCached = async (): Promise<boolean> => {
    const cached = await Promise.all(
      Object.keys(EXPECTED_FILES).map((file) =>
        isFileInCache("transformers-cache", MODEL_ONNX_URL_BASE + file)
      )
    );
    return cached.every((c) => c);
  };

  private resampleAudio(
    audioData: Float32Array,
    originalSampleRate: number,
    targetSampleRate: number
  ): Float32Array {
    const ratio = originalSampleRate / targetSampleRate;
    const newLength = Math.round(audioData.length / ratio);
    const result = new Float32Array(newLength);

    for (let i = 0; i < newLength; i++) {
      const originalIndex = i * ratio;
      const leftIndex = Math.floor(originalIndex);
      const rightIndex = Math.ceil(originalIndex);
      const fraction = originalIndex - leftIndex;

      if (rightIndex < audioData.length) {
        result[i] =
          audioData[leftIndex] * (1 - fraction) +
          audioData[rightIndex] * fraction;
      } else {
        result[i] = audioData[leftIndex];
      }
    }

    return result;
  }
}

export default SpeechToText;
</file>

<file path="src/ai/speechToText/types.ts">
import { ProgressInfo } from "@huggingface/transformers";

export interface SpeechToTextWorkerMessage {
  id: string;
  audioData: Float32Array;
  sampleRate: number;
}

interface SpeechToTextWorkerResponseAudio {
  id: string;
  status: "loading" | "complete" | "error";
  text?: string;
  error?: string;
}

export interface SpeechToTextWorkerResponseProgress {
  id: string;
  status: "progress";
  progress: ProgressInfo;
}

export type SpeechToTextWorkerResponse =
  | SpeechToTextWorkerResponseAudio
  | SpeechToTextWorkerResponseProgress;
</file>

<file path="src/ai/speechToText/worker.ts">
import {
  AutomaticSpeechRecognitionPipeline,
  ProgressInfo,
  pipeline,
} from "@huggingface/transformers";

import { MODEL_ID } from "./constants";
import { SpeechToTextWorkerMessage, SpeechToTextWorkerResponse } from "./types";

let whisperPipeline: AutomaticSpeechRecognitionPipeline | null = null;

async function initializeWhisper(request_id: string) {
  if (!whisperPipeline) {
    // @ts-ignore
    whisperPipeline = await pipeline("automatic-speech-recognition", MODEL_ID, {
      device: "webgpu",
      progress_callback: (p: ProgressInfo) =>
        postMessage({
          status: "progress",
          progress: p,
          id: request_id,
        }),
    });
  }
  return whisperPipeline;
}

self.addEventListener(
  "message",
  async (event: MessageEvent<SpeechToTextWorkerMessage>) => {
    const { id, audioData, sampleRate } = event.data;

    try {
      postMessage({
        id,
        status: "loading",
      });

      const pipeline = await initializeWhisper(id);
      if (sampleRate !== 16000) {
        throw new Error(`Expected 16kHz audio, got ${sampleRate}Hz`);
      }

      const result = await pipeline(audioData, {
        return_timestamps: false,
        chunk_length_s: 30,
        stride_length_s: 5,
      });

      const text = Array.isArray(result)
        ? result[0]?.text || ""
        : result.text || "";

      postMessage({
        id,
        status: "complete",
        text,
      });
    } catch (error) {
      console.error("Speech to text error:", error);

      postMessage({
        id,
        status: "error",
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      });
    }
  }
);

const postMessage = (message: SpeechToTextWorkerResponse) =>
  self.postMessage(message);
</file>

<file path="src/ai/textToSpeech/kokoro/constants.ts">
export const MODEL_ID = "onnx-community/Kokoro-82M-v1.0-ONNX";
export const MODEL_ONNX_URL_BASE = `https://huggingface.co/${MODEL_ID}/resolve/main/`;

export const EXPECTED_FILES = {
  "config.json": 44,
  "onnx/model.onnx": 325532232,
  "tokenizer.json": 3497,
  "tokenizer_config.json": 113,
};
</file>

<file path="src/ai/textToSpeech/kokoro/Kokoro.ts">
import { ProgressInfo } from "@huggingface/transformers";
import isFileInCache from "@utils/isFileInCache";

import { TextToSpeech } from "../types";
import SequentialAudioPlayer from "./SequentialAudioPlayer";
import { EXPECTED_FILES, MODEL_ONNX_URL_BASE } from "./constants";
import { KokoroInput, KokoroOutput, WorkerResponseKokoro } from "./types";

const WORKER_LOG = false;

class Kokoro implements TextToSpeech {
  private worker: Worker;
  private queue: Array<{ text: string; signal: AbortSignal }> = [];
  private isProcessing = false;
  public player = new SequentialAudioPlayer();
  private voice: string = "bm_fable";
  private speed: number = 1.2;

  constructor(options: { voice?: string; speed?: number } = {}) {
    this.worker = new Worker(new URL("./worker.ts", import.meta.url), {
      type: "module",
    });
    if (options?.speed) {
      this.speed = options.speed;
    }
    if (options?.voice) {
      this.voice = options.voice;
    }
  }

  public async preload(
    callback: (progress: number) => void = () => {}
  ): Promise<void> {
    const files: Record<
      string,
      {
        total: number;
        loaded: number;
      }
    > = Object.entries(EXPECTED_FILES).reduce(
      (acc, [file, total]) => ({
        ...acc,
        [file]: {
          total,
          loaded: 0,
        },
      }),
      {}
    );
    await this.workerMessage(
      {
        text: "",
        voice: this.voice,
        speed: this.speed,
      },
      (progress) => {
        if (progress.status === "progress") {
          files[progress.file] = {
            loaded: progress.loaded,
            total: progress.total,
          };
          const { total, loaded } = Object.entries(files).reduce(
            (acc, [file, progress]) => ({
              total: acc.total + progress.total,
              loaded: acc.loaded + progress.loaded,
            }),
            { total: 0, loaded: 0 }
          );
          callback(Math.round((loaded / total) * 100));
        }
      }
    );
  }

  private cleanTextForSpeech(text: string): string {
    return text
      .replace(/\*+/g, '') // Remove asterisks (markdown emphasis)
      .replace(/[_]{1,}/g, '') // Remove underscores (markdown emphasis)
      .replace(/[#]+/g, '') // Remove hashtags (markdown headers)
      .replace(/[`]+/g, '') // Remove backticks (markdown code)
      .replace(/[~]+/g, '') // Remove tildes (strikethrough)
      .replace(/[\[\]]/g, '') // Remove square brackets
      .replace(/[{}]/g, '') // Remove curly braces
      .replace(/[<>]/g, '') // Remove angle brackets
      .replace(/[|]/g, '') // Remove pipe characters
      .replace(/[@#$%^&+=]/g, '') // Remove various symbols
      .replace(/\s+/g, ' ') // Normalize whitespace
      .trim();
  }

  public speak(text: string, signal?: AbortSignal): void {
    if (!text || text.trim() === "") return;
    if (signal?.aborted) return;

    this.queue.push({
      text: this.cleanTextForSpeech(text),
      signal: signal || new AbortController().signal,
    });

    if (!this.isProcessing) {
      this.processNext();
    }
  }

  private processNext(): void {
    this.queue = this.queue.filter((item) => !item.signal.aborted);

    if (this.queue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const item = this.queue.shift()!;

    this.processAndPlay(item.text, item.signal)
      .then(() => {
        // Process next item in queue
        this.processNext();
      })
      .catch((error) => {
        if (error.name === "AbortError") {
          this.processNext();
          return;
        }
        console.error("Error processing TTS:", error);
        this.processNext();
      });
  }

  private async processAndPlay(
    text: string,
    signal: AbortSignal
  ): Promise<void> {
    if (signal.aborted) {
      throw new DOMException("Operation aborted", "AbortError");
    }

    const audioBlob = await this.workerMessage(
      {
        text,
        voice: this.voice,
        speed: this.speed,
      },
      () => {},
      signal
    );

    if (signal.aborted) {
      throw new DOMException("Operation aborted", "AbortError");
    }
    this.player.play(audioBlob, signal);
  }

  private workerMessage(
    input: KokoroInput,
    loadingCallback: (progress: ProgressInfo) => void = () => {},
    signal?: AbortSignal
  ): Promise<KokoroOutput> {
    return new Promise((resolve, reject) => {
      const id = Math.random().toString(36);

      const abortListener = () => {
        this.worker.removeEventListener("message", listener);
        reject(new DOMException("Operation aborted", "AbortError"));
      };

      if (signal && signal.aborted) {
        reject(new DOMException("Operation aborted", "AbortError"));
        return;
      }

      signal &&
        signal.addEventListener("abort", abortListener, {
          once: true,
        });

      this.worker.postMessage({ input, id, log: WORKER_LOG });

      const listener = (e: MessageEvent<WorkerResponseKokoro>) => {
        if (e.data.id !== id) return;
        if (e.data.status === "loading") {
          loadingCallback(e.data.progress);
          return;
        }

        if (e.data.status === "complete") {
          this.worker.removeEventListener("message", listener);
          signal && signal.removeEventListener("abort", abortListener);
          resolve(e.data.output);
        }

        if (e.data.status === "error") {
          this.worker.removeEventListener("message", listener);
          signal && signal.removeEventListener("abort", abortListener);
          reject(e.data);
        }
      };

      this.worker.addEventListener("message", listener);
    });
  }

  public isCached = async (): Promise<boolean> =>
    (
      await Promise.all(
        Object.keys(EXPECTED_FILES).map((file) =>
          isFileInCache("transformers-cache", MODEL_ONNX_URL_BASE + file)
        )
      )
    ).every((c) => c);
}

export default Kokoro;
</file>

<file path="src/ai/textToSpeech/kokoro/phonemize.ts">
import { phonemize as espeakng } from "phonemizer";

const split = (text: string, regex: RegExp) => {
  const result: Array<{ match: boolean; text: string }> = [];
  let prev = 0;
  for (const match of text.matchAll(regex)) {
    const fullMatch = match[0];
    if (prev < match.index) {
      result.push({ match: false, text: text.slice(prev, match.index) });
    }
    if (fullMatch.length > 0) {
      result.push({ match: true, text: fullMatch });
    }
    prev = match.index + fullMatch.length;
  }
  if (prev < text.length) {
    result.push({ match: false, text: text.slice(prev) });
  }
  return result;
};

const splitNum = (match: string): string => {
  if (match.includes(".")) {
    return match;
  } else if (match.includes(":")) {
    let [h, m] = match.split(":").map(Number);
    if (m === 0) {
      return `${h} o'clock`;
    } else if (m < 10) {
      return `${h} oh ${m}`;
    }
    return `${h} ${m}`;
  }
  let year = parseInt(match.slice(0, 4), 10);
  if (year < 1100 || year % 1000 < 10) {
    return match;
  }
  let left = match.slice(0, 2);
  let right = parseInt(match.slice(2, 4), 10);
  let suffix = match.endsWith("s") ? "s" : "";
  if (year % 1000 >= 100 && year % 1000 <= 999) {
    if (right === 0) {
      return `${left} hundred${suffix}`;
    } else if (right < 10) {
      return `${left} oh ${right}${suffix}`;
    }
  }
  return `${left} ${right}${suffix}`;
};

const flipMoney = (match: string): string => {
  const bill = match[0] === "$" ? "dollar" : "pound";
  if (isNaN(Number(match.slice(1)))) {
    return `${match.slice(1)} ${bill}s`;
  } else if (!match.includes(".")) {
    let suffix = match.slice(1) === "1" ? "" : "s";
    return `${match.slice(1)} ${bill}${suffix}`;
  }
  const [b, c] = match.slice(1).split(".");
  const d = parseInt(c.padEnd(2, "0"), 10);
  let coins =
    match[0] === "$"
      ? d === 1
        ? "cent"
        : "cents"
      : d === 1
        ? "penny"
        : "pence";
  return `${b} ${bill}${b === "1" ? "" : "s"} and ${d} ${coins}`;
};

function pointNum(match: string): string {
  let [a, b] = match.split(".");
  return `${a} point ${b.split("").join(" ")}`;
}

/**
 * Normalize text for phonemization
 * @param {string} text The text to normalize
 * @returns {string} The normalized text
 */
const normalizeText = (text: string): string =>
  text
    // 1. Handle quotes and brackets
    .replace(/[‚Äò‚Äô]/g, "'")
    .replace(/¬´/g, "‚Äú")
    .replace(/¬ª/g, "‚Äù")
    .replace(/[‚Äú‚Äù]/g, '"')
    .replace(/\(/g, "¬´")
    .replace(/\)/g, "¬ª")

    // 2. Replace uncommon punctuation marks
    .replace(/„ÄÅ/g, ", ")
    .replace(/„ÄÇ/g, ". ")
    .replace(/ÔºÅ/g, "! ")
    .replace(/Ôºå/g, ", ")
    .replace(/Ôºö/g, ": ")
    .replace(/Ôºõ/g, "; ")
    .replace(/Ôºü/g, "? ")

    // 3. Whitespace normalization
    .replace(/[^\S \n]/g, " ")
    .replace(/  +/, " ")
    .replace(/(?<=\n) +(?=\n)/g, "")

    // 4. Abbreviations
    .replace(/\bD[Rr]\.(?= [A-Z])/g, "Doctor")
    .replace(/\b(?:Mr\.|MR\.(?= [A-Z]))/g, "Mister")
    .replace(/\b(?:Ms\.|MS\.(?= [A-Z]))/g, "Miss")
    .replace(/\b(?:Mrs\.|MRS\.(?= [A-Z]))/g, "Mrs")
    .replace(/\betc\.(?! [A-Z])/gi, "etc")

    // 5. Normalize casual words
    .replace(/\b(y)eah?\b/gi, "$1e'a")

    // 5. Handle numbers and currencies
    .replace(
      /\d*\.\d+|\b\d{4}s?\b|(?<!:)\b(?:[1-9]|1[0-2]):[0-5]\d\b(?!:)/g,
      splitNum
    )
    .replace(/(?<=\d),(?=\d)/g, "")
    .replace(
      /[$¬£]\d+(?:\.\d+)?(?: hundred| thousand| (?:[bm]|tr)illion)*\b|[$¬£]\d+\.\d\d?\b/gi,
      flipMoney
    )
    .replace(/\d*\.\d+/g, pointNum)
    .replace(/(?<=\d)-(?=\d)/g, " to ")
    .replace(/(?<=\d)S/g, " S")

    // 6. Handle possessives
    .replace(/(?<=[BCDFGHJ-NP-TV-Z])'?s\b/g, "'S")
    .replace(/(?<=X')S\b/g, "s")

    // 7. Handle hyphenated words/letters
    .replace(/(?:[A-Za-z]\.){2,} [a-z]/g, (m) => m.replace(/\./g, "-"))
    .replace(/(?<=[A-Z])\.(?=[A-Z])/gi, "-")

    // 8. Strip leading and trailing whitespace
    .trim();

const escapeRegExp = (string: string): string =>
  string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string

const PUNCTUATION = ';:,.!?¬°¬ø‚Äî‚Ä¶"¬´¬ª‚Äú‚Äù(){}[]';
const PUNCTUATION_PATTERN = new RegExp(
  `(\\s*[${escapeRegExp(PUNCTUATION)}]+\\s*)+`,
  "g"
);

const phonemize = async (
  text: string,
  language: string = "a",
  norm: boolean = true
): Promise<string> => {
  // 1. Normalize text
  if (norm) {
    text = normalizeText(text);
  }

  // 2. Split into chunks, to ensure we preserve punctuation
  const sections = split(text, PUNCTUATION_PATTERN);

  // 3. Convert each section to phonemes
  const lang = language === "a" ? "en-us" : "en";
  const ps = (
    await Promise.all(
      sections.map(async ({ match, text }) =>
        match ? text : (await espeakng(text, lang)).join(" ")
      )
    )
  ).join("");

  // 4. Post-process phonemes
  let processed = ps
    // https://en.wiktionary.org/wiki/kokoro#English
    .replace(/k…ôkÀàoÀê…πo ä/g, "kÀào äk…ô…πo ä")
    .replace(/k…ôkÀà…îÀê…π…ô ä/g, "kÀà…ô äk…ô…π…ô ä")
    .replace(/ ≤/g, "j")
    .replace(/r/g, "…π")
    .replace(/x/g, "k")
    .replace(/…¨/g, "l")
    .replace(/(?<=[a-z…πÀê])(?=hÀà ånd…π…™d)/g, " ")
    .replace(/ z(?=[;:,.!?¬°¬ø‚Äî‚Ä¶"¬´¬ª‚Äú‚Äù ]|$)/g, "z");

  // 5. Additional post-processing for American English
  if (language === "a") {
    processed = processed.replace(/(?<=nÀàa…™n)ti(?!Àê)/g, "di");
  }
  return processed.trim();
};

export default phonemize;
</file>

<file path="src/ai/textToSpeech/kokoro/SequentialAudioPlayer.ts">
class SequentialAudioPlayer {
  private queue: Array<{ blob: Blob; signal: AbortSignal }> = [];
  private _isPlaying = false;
  private currentAudio: HTMLAudioElement | null = null;
  private isPlayingEventListeners: Set<(isSpeaking: boolean) => void> =
    new Set();

  public get isPlaying() {
    return this._isPlaying;
  }

  public set isPlaying(playing: boolean) {
    this._isPlaying = playing;
    this.isPlayingEventListeners.forEach((listener) => listener(playing));
  }

  public onIsPlayingChange = (listener: (playing: boolean) => void) => {
    this.isPlayingEventListeners.add(listener);
    return () => this.isPlayingEventListeners.delete(listener);
  };

  public play = (audioBlob: Blob, signal?: AbortSignal): void => {
    if (signal?.aborted) return;

    this.queue.push({
      blob: audioBlob,
      signal: signal || new AbortController().signal,
    });

    if (!this.isPlaying) {
      this.playNext();
    }
  };

  private playNext = async (): Promise<void> => {
    // Filter out aborted items
    this.queue = this.queue.filter((item) => !item.signal.aborted);

    if (this.queue.length === 0) {
      this.isPlaying = false;
      return;
    }

    this.isPlaying = true;
    const item = this.queue.shift()!;

    try {
      await this.playBlob(item.blob, item.signal);
    } catch (error) {
      console.error("Error playing audio:", error);
    }

    this.playNext();
  };

  private playBlob = (blob: Blob, signal: AbortSignal): Promise<void> => {
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new DOMException("Operation aborted", "AbortError"));
        return;
      }

      const audioUrl = URL.createObjectURL(blob);
      const audio = document.createElement("audio");

      audio.src = audioUrl;
      this.currentAudio = audio;

      const cleanup = () => {
        URL.revokeObjectURL(audioUrl);
        this.currentAudio = null;
        signal.removeEventListener("abort", abortHandler);
      };

      const abortHandler = () => {
        audio.pause();
        cleanup();
        reject(new DOMException("Operation aborted", "AbortError"));
      };

      signal.addEventListener("abort", abortHandler, { once: true });

      audio.onended = () => {
        cleanup();
        resolve();
      };

      audio.onerror = (error) => {
        cleanup();
        reject(error);
      };

      audio.play().catch(reject);
    });
  };
}

export default SequentialAudioPlayer;
</file>

<file path="src/ai/textToSpeech/kokoro/types.ts">
import { ProgressInfo } from "@huggingface/transformers";

export type KokoroOutput = Blob;
export type KokoroInput = {
  text: string;
  voice?: string;
  speed?: number;
};
export type WorkerResponseKokoro = WorkerResponse<KokoroOutput>;
export type WorkerRequestKokoro = WorkerRequest<KokoroInput>;

export interface WorkerRequest<Input> {
  input?: Input;
  id: string;
  log?: boolean;
}

export type InitPipelineProgressEvent = {
  status: "loading";
  id: string;
  progress: ProgressInfo;
};

export type PipelineReadyEvent = {
  status: "ready";
  id: string;
};

export type TranscribeErrorEvent = {
  status: "error";
  error: any;
  id: string;
};

export type CompleteEvent<Output> = {
  status: "complete";
  output: Output;
  id: string;
};

export type WorkerResponse<Output = any> =
  | InitPipelineProgressEvent
  | PipelineReadyEvent
  | TranscribeErrorEvent
  | CompleteEvent<Output>;

export enum QueueStatus {
  ADDED_TO_QUEUE = "ADDED_TO_QUEUE",
  PENDING = "PENDING",
  ERROR = "ERROR",
  DONE = "DONE",
}

export interface QueueData {
  status: QueueStatus;
  workerStatus?: WorkerResponseKokoro["status"];
  statusText: string;
}
</file>

<file path="src/ai/textToSpeech/kokoro/voices.ts">
export const VOICES = Object.freeze({
  af: {
    // Default voice is a 50-50 mix of Bella & Sarah
    name: "Default",
    language: "en-us",
    gender: "Female",
  },
  af_bella: {
    name: "Bella",
    language: "en-us",
    gender: "Female",
  },
  af_nicole: {
    name: "Nicole",
    language: "en-us",
    gender: "Female",
  },
  af_sarah: {
    name: "Sarah",
    language: "en-us",
    gender: "Female",
  },
  af_sky: {
    name: "Sky",
    language: "en-us",
    gender: "Female",
  },
  am_adam: {
    name: "Adam",
    language: "en-us",
    gender: "Male",
  },
  am_michael: {
    name: "Michael",
    language: "en-us",
    gender: "Male",
  },

  bf_emma: {
    name: "Emma",
    language: "en-gb",
    gender: "Female",
  },
  bf_isabella: {
    name: "Isabella",
    language: "en-gb",
    gender: "Female",
  },
  bm_george: {
    name: "George",
    language: "en-gb",
    gender: "Male",
  },
  bm_lewis: {
    name: "Lewis",
    language: "en-gb",
    gender: "Male",
  },
  bm_daniel: {
    name: "Daniel",
    language: "en-gb",
    gender: "Male",
  },
  bm_fable: {
    name: "Fable",
    language: "en-gb",
    gender: "Male",
  },
});

const VOICE_DATA_URL =
  "https://huggingface.co/onnx-community/Kokoro-82M-v1.0-ONNX/resolve/main/voices";

const getVoiceFile = async (id: string) => {
  const url = `${VOICE_DATA_URL}/${id}.bin`;

  let cache;
  try {
    cache = await caches.open("kokoro-voices");
    const cachedResponse = await cache.match(url);
    if (cachedResponse) {
      return await cachedResponse.arrayBuffer();
    }
  } catch (e) {
    console.warn("Unable to open cache", e);
  }

  // No cache, or cache failed to open. Fetch the file.
  const response = await fetch(url);
  const buffer = await response.arrayBuffer();

  if (cache) {
    try {
      // NOTE: We use `new Response(buffer, ...)` instead of `response.clone()` to handle LFS files
      await cache.put(
        url,
        new Response(buffer, {
          headers: response.headers,
        })
      );
    } catch (e) {
      console.warn("Unable to cache file", e);
    }
  }

  return buffer;
};

const VOICE_CACHE = new Map();

export const getVoiceData = async (voice: string) => {
  if (VOICE_CACHE.has(voice)) {
    return VOICE_CACHE.get(voice);
  }

  const buffer = new Float32Array(await getVoiceFile(voice));
  VOICE_CACHE.set(voice, buffer);
  return buffer;
};
</file>

<file path="src/ai/textToSpeech/kokoro/worker.ts">
import {
  AutoTokenizer,
  PreTrainedModel,
  PreTrainedTokenizer,
  ProgressInfo,
  RawAudio,
  StyleTextToSpeech2Model,
  Tensor,
} from "@huggingface/transformers";

import { MODEL_ID } from "./constants";
import phonemize from "./phonemize";
import { WorkerRequestKokoro, WorkerResponseKokoro } from "./types";
import { VOICES, getVoiceData } from "./voices";

const STYLE_DIM = 256;
const SAMPLE_RATE = 24000;
const postMessage = (e: WorkerResponseKokoro) => self.postMessage(e);
const onMessage = (cb: (e: MessageEvent<WorkerRequestKokoro>) => void) =>
  self.addEventListener("message", cb);

class ModelInstance {
  private static instance: ModelInstance = null;
  private tokenizer: PreTrainedTokenizer;
  private model: PreTrainedModel;
  private modelId: string = MODEL_ID;

  public static getInstance() {
    if (!this.instance) {
      this.instance = new ModelInstance();
    }
    return this.instance;
  }

  public loadModel = async (
    log: (...data: Array<any>) => void,
    progress: (progress: ProgressInfo) => void
  ): Promise<{
    tokenizer: PreTrainedTokenizer;
    model: PreTrainedModel;
  }> => {
    if (this.tokenizer && this.model) {
      return {
        tokenizer: this.tokenizer,
        model: this.model,
      };
    }
    const tokenizerPromise = AutoTokenizer.from_pretrained(this.modelId, {
      progress_callback: (p) => {
        log(p);
        progress(p);
      },
    });

    const modelPromise = StyleTextToSpeech2Model.from_pretrained(this.modelId, {
      dtype: "fp32",
      device: "webgpu",
      progress_callback: (p) => {
        log(p);
        progress(p);
      },
    });

    const [tokenizer, model] = await Promise.all([
      tokenizerPromise,
      modelPromise,
    ]);

    this.tokenizer = tokenizer;
    this.model = model;
    return {
      tokenizer: this.tokenizer,
      model: this.model,
    };
  };
}

onMessage(async (event) => {
  const instance = ModelInstance.getInstance();
  const log = (...e: Array<any>) =>
    event.data.log ? console.log("[WORKER]", ...e) : null;

  const { model, tokenizer } = await instance.loadModel(
    log,
    (p: ProgressInfo) => {
      postMessage({ status: "loading", id: event.data.id, progress: p });
    }
  );
  const voice = event.data?.input?.voice || "af";
  const speed = event.data?.input?.speed || 1;
  const text = event.data.input.text;
  if (!VOICES.hasOwnProperty(voice)) {
    log(`Voice "${voice}" not found. Available voices:`);
    throw new Error(
      `Voice "${voice}" not found. Should be one of: ${Object.keys(VOICES).join(", ")}.`
    );
  }

  if (!event.data.input.text) {
    log("no input");
    postMessage({
      status: "complete",
      output: null,
      id: event.data.id,
    });
    return;
  }

  try {
    const language = /** @type {"a"|"b"} */ voice.at(0); // "a" or "b"
    const phonemes = await phonemize(text, language);
    const { input_ids } = tokenizer(phonemes, {
      truncation: true,
    });

    // Select voice style based on number of input tokens
    const numTokens = Math.min(Math.max(input_ids.dims.at(-1) - 2, 0), 509);

    const data = await getVoiceData(voice);
    const offset = numTokens * STYLE_DIM;
    const voiceData = data.slice(offset, offset + STYLE_DIM);

    postMessage({
      status: "ready",
      id: event.data.id,
    });

    const inputs = {
      input_ids,
      style: new Tensor("float32", voiceData, [1, STYLE_DIM]),
      speed: new Tensor("float32", [speed], [1]),
    };

    // Generate audio
    const { waveform } = await model(inputs);
    const audio = new RawAudio(waveform.data, SAMPLE_RATE);
    const blob = audio.toBlob();

    log("complete", blob);
    postMessage({
      status: "complete",
      output: blob,
      id: event.data.id,
    });
  } catch (error) {
    log("ERROR", error);
    postMessage({
      status: "error",
      error: error,
      id: event.data.id,
    });
  }
});
</file>

<file path="src/ai/textToSpeech/types.ts">
export interface TextToSpeech {
  speak: (text: string) => void;
}
</file>

<file path="src/ai/voiceActivityDetection/constants.ts">
export const MODEL_ID = "onnx-community/silero-vad";
export const MODEL_ONNX_URL = `https://huggingface.co/${MODEL_ID}/resolve/main/onnx/model.onnx	`;

/**
 * Sample rate of the input audio.
 * Coindicentally, this is the same for both models (Moonshine and Silero VAD)
 */
export const INPUT_SAMPLE_RATE = 16000;
const INPUT_SAMPLE_RATE_MS = INPUT_SAMPLE_RATE / 1000;

/**
 * Probabilities ABOVE this value are considered as SPEECH
 */
export const SPEECH_THRESHOLD = 0.3;

/**
 * If current state is SPEECH, and the probability of the next state
 * is below this value, it is considered as NON-SPEECH.
 */
export const EXIT_THRESHOLD = 0.1;

/**
 * After each speech chunk, wait for at least this amount of silence
 * before considering the next chunk as a new speech chunk
 */
export const MIN_SILENCE_DURATION_MS = 400;
export const MIN_SILENCE_DURATION_SAMPLES =
  MIN_SILENCE_DURATION_MS * INPUT_SAMPLE_RATE_MS;

/**
 * Pad the speech chunk with this amount each side
 */
export const SPEECH_PAD_MS = 80;
export const SPEECH_PAD_SAMPLES = SPEECH_PAD_MS * INPUT_SAMPLE_RATE_MS;

/**
 * Final speech chunks below this duration are discarded
 */
export const MIN_SPEECH_DURATION_SAMPLES = 250 * INPUT_SAMPLE_RATE_MS; // 250 ms

/**
 * Maximum duration of audio that can be handled by Moonshine
 */
export const MAX_BUFFER_DURATION = 30;

/**
 * Size of the incoming buffers
 */
export const NEW_BUFFER_SIZE = 512;

/**
 * The number of previous buffers to keep, to ensure the audio is padded correctly
 */
export const MAX_NUM_PREV_BUFFERS = Math.ceil(
  SPEECH_PAD_SAMPLES / NEW_BUFFER_SIZE
);
</file>

<file path="src/ai/voiceActivityDetection/types.ts">
import { ProgressInfo } from "@huggingface/transformers";

export interface VadWorkerMessage {
  id: string;
  type: "init" | "audio" | "reset";
  buffer?: Float32Array;
}

export enum VoiceActivityDetectionStatus {
  IDLE = "idle",
  WAITING = "waiting",
  RECORDING = "recording",
}

interface VadWorkerResponseAudio {
  id: string;
  type: "ready" | "speech_start" | "speech_end" | "speech_chunk" | "error";
  buffer?: Float32Array;
  start?: number;
  end?: number;
  duration?: number;
  error?: string;
}

interface VadWorkerResponseProgress {
  id: string;
  type: "progress";
  progress: ProgressInfo;
}

export type VadWorkerResponse =
  | VadWorkerResponseAudio
  | VadWorkerResponseProgress;

export interface VadCallbacks {
  onSpeechStart?: () => void;
  onSpeechEnd?: () => void;
  onSpeechChunk?: (
    audioBuffer: Float32Array,
    timing: { start: number; end: number; duration: number }
  ) => void;
  onError?: (error: string) => void;
}
</file>

<file path="src/ai/voiceActivityDetection/vad-processor.ts">
declare class AudioWorkletProcessor {
  readonly port: MessagePort;
  process(
    inputs: Float32Array[][],
    outputs: Float32Array[][],
    parameters: Record<string, Float32Array>
  ): boolean;
}

declare function registerProcessor(
  name: string,
  processorCtor: typeof AudioWorkletProcessor
): void;

class VadProcessor extends AudioWorkletProcessor {
  private bufferSize: number;
  private buffer: Float32Array;
  private bufferIndex: number;

  constructor() {
    super();
    this.bufferSize = 512; // Process in 512 sample chunks
    this.buffer = new Float32Array(this.bufferSize);
    this.bufferIndex = 0;
  }

  process(inputs: Float32Array[][]): boolean {
    const input = inputs[0];

    if (input.length > 0) {
      const inputChannel = input[0]; // Get first channel

      for (let i = 0; i < inputChannel.length; i++) {
        this.buffer[this.bufferIndex] = inputChannel[i];
        this.bufferIndex++;

        if (this.bufferIndex >= this.bufferSize) {
          // Send buffer to main thread when full
          this.port.postMessage({
            buffer: this.buffer.slice(), // Copy the buffer
          });

          // Reset buffer
          this.bufferIndex = 0;
        }
      }
    }

    return true; // Keep processor alive
  }
}

registerProcessor("vad-processor", VadProcessor);
</file>

<file path="src/ai/voiceActivityDetection/VoiceActivityDetection.ts">
import { MODEL_ONNX_URL } from "@ai/voiceActivityDetection/constants";
import { ProgressInfo } from "@huggingface/transformers";
import isFileInCache from "@utils/isFileInCache";
import { data } from "autoprefixer";

import {
  VadCallbacks,
  VadWorkerMessage,
  VadWorkerResponse,
  VoiceActivityDetectionStatus,
} from "./types";
import workletUrl from "./vad-processor.ts?worker&url";


class VoiceActivityDetection {
  private worker: Worker;
  private callbacks: VadCallbacks = {};
  private isReady = false;
  private audioContext: AudioContext | null = null;
  private mediaStream: MediaStream | null = null;
  private sourceNode: MediaStreamAudioSourceNode | null = null;
  private workletNode: AudioWorkletNode | null = null;
  private _status = VoiceActivityDetectionStatus.IDLE;
  private statusListener = new Set<
    (status: VoiceActivityDetectionStatus) => void
  >([]);
  private requestId: number = 0;

  public get status() {
    return this._status;
  }

  private set status(newStatus: VoiceActivityDetectionStatus) {
    this._status = newStatus;
    this.statusListener.forEach((listener) => listener(newStatus));
  }

  public onStatusChange = (
    callback: (status: VoiceActivityDetectionStatus) => void
  ) => {
    const listener = () => callback(this.status);
    this.statusListener.add(listener);
    return () => this.statusListener.delete(listener);
  };

  constructor(callbacks: VadCallbacks = {}) {
    this.callbacks = callbacks;
    this.worker = new Worker(new URL("./worker.ts", import.meta.url), {
      type: "module",
    });

    this.worker.addEventListener("message", this.handleWorkerMessage);
  }

  public preload(
    progressCallback: (progress: number) => void = () => {}
  ): Promise<void> {
    return new Promise((resolve) => {
      const id = (this.requestId++).toString();

      const listener = (message: MessageEvent<VadWorkerResponse>) => {
        if (message.data.id !== id) return;
        if (message.data.type === "ready") {
          this.worker.removeEventListener("message", listener);
          resolve();
        }

        if (
          message.data.type === "progress" &&
          message.data.progress.status === "progress" &&
          message.data.progress.file === "onnx/model.onnx"
        ) {
          progressCallback(Math.round(message.data.progress.progress));
        }
        if (
          message.data.type === "progress" &&
          message.data.progress.status === "done" &&
          message.data.progress.file === "onnx/model.onnx"
        ) {
          progressCallback(100);
        }
      };
      this.worker.addEventListener("message", listener);
      this.postMessage({ type: "init", id });
    });
  }

  public isCached = async (): Promise<boolean> =>
    await isFileInCache("transformers-cache", MODEL_ONNX_URL);

  private handleWorkerMessage = (event: MessageEvent<VadWorkerResponse>) => {
    // @ts-ignore
    const { type, buffer, start, end, duration, error } = event.data;

    switch (type) {
      case "ready":
        this.isReady = true;
        break;

      case "speech_start":
        this.status = VoiceActivityDetectionStatus.RECORDING;
        this.callbacks.onSpeechStart?.();
        break;

      case "speech_end":
        this.status = VoiceActivityDetectionStatus.WAITING;
        this.callbacks.onSpeechEnd?.();
        break;

      case "speech_chunk":
        if (
          buffer &&
          start !== undefined &&
          end !== undefined &&
          duration !== undefined
        ) {
          this.callbacks.onSpeechChunk?.(buffer, { start, end, duration });
        }
        break;

      case "error":
        if (error) {
          this.callbacks.onError?.(error);
        }
        break;
    }
  };

  private handleWorkletMessage = (event: MessageEvent) => {
    const { buffer } = event.data;
    if (buffer && this.isReady) {
      this.postMessage(
        {
          type: "audio",
          buffer: buffer,
          id: (this.requestId++).toString(),
        },
        [buffer.buffer]
      );
    }
  };

  public async startMicrophone(): Promise<void> {
    if (this.status !== VoiceActivityDetectionStatus.IDLE) {
      console.warn("Microphone is already active");
      return;
    }

    try {
      this.mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16000,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true,
        },
      });

      this.audioContext = new (window.AudioContext ||
        (window as any).webkitAudioContext)({
        sampleRate: 16000,
      });

      await this.audioContext.audioWorklet.addModule(workletUrl);

      this.sourceNode = this.audioContext.createMediaStreamSource(
        this.mediaStream
      );

      this.workletNode = new AudioWorkletNode(
        this.audioContext,
        "vad-processor"
      );
      this.workletNode.port.onmessage = this.handleWorkletMessage;

      this.sourceNode.connect(this.workletNode);

      this.status = VoiceActivityDetectionStatus.WAITING;
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Failed to start microphone";
      this.callbacks.onError?.(errorMessage);
      throw error;
    }
  }

  public stopMicrophone(): void {
    if (this.status === VoiceActivityDetectionStatus.IDLE) {
      return;
    }

    if (this.sourceNode) {
      this.sourceNode.disconnect();
      this.sourceNode = null;
    }

    if (this.workletNode) {
      this.workletNode.disconnect();
      this.workletNode.port.onmessage = null;
      this.workletNode = null;
    }

    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
      this.mediaStream = null;
    }

    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }

    this.status = VoiceActivityDetectionStatus.IDLE;
  }

  public processAudio(audioBuffer: Float32Array): void {
    if (!this.isReady) {
      console.warn("VAD not ready yet");
      return;
    }

    this.postMessage(
      {
        type: "audio",
        buffer: audioBuffer,
        id: (this.requestId++).toString(),
      },
      [audioBuffer.buffer]
    );
  }

  public reset(): void {
    this.postMessage({ type: "reset", id: (this.requestId++).toString() });
  }

  public setCallbacks(callbacks: VadCallbacks): void {
    this.callbacks = { ...this.callbacks, ...callbacks };
  }

  public destroy(): void {
    this.stopMicrophone();
    this.worker.removeEventListener("message", this.handleWorkerMessage);
    this.worker.terminate();
  }

  public get ready(): boolean {
    return this.isReady;
  }

  private postMessage = (
    message: VadWorkerMessage,
    transfer?: Transferable[]
  ) => {
    this.worker.postMessage(message, transfer);
  };
}

export default VoiceActivityDetection;
</file>

<file path="src/ai/voiceActivityDetection/worker.ts">
import { AutoModel, ProgressInfo, Tensor } from "@huggingface/transformers";

import {
  EXIT_THRESHOLD,
  INPUT_SAMPLE_RATE,
  MAX_BUFFER_DURATION,
  MAX_NUM_PREV_BUFFERS,
  MIN_SILENCE_DURATION_SAMPLES,
  MIN_SPEECH_DURATION_SAMPLES,
  MODEL_ID,
  SPEECH_PAD_SAMPLES,
  SPEECH_THRESHOLD,
} from "./constants";
import { VadWorkerMessage, VadWorkerResponse } from "./types";

// Load VAD model
let silero_vad: any = null;
let isInitialized = false;

async function initializeVAD(
  request_id: string,
  progress_callback = (progress: ProgressInfo) => {}
) {
  if (isInitialized) return;

  try {
    silero_vad = await AutoModel.from_pretrained(MODEL_ID, {
      // @ts-expect-error
      config: { model_type: "custom" },
      dtype: "fp32",
      progress_callback,
    });

    isInitialized = true;
    postMessage({ type: "ready", id: request_id });
  } catch (error) {
    postMessage({
      type: "error",
      error:
        error instanceof Error ? error.message : "Failed to initialize VAD",
      id: request_id,
    });
  }
}

// Global audio buffer to store incoming audio
const BUFFER = new Float32Array(MAX_BUFFER_DURATION * INPUT_SAMPLE_RATE);
let bufferPointer = 0;

// Initial state for VAD
const sr = new Tensor("int64", [INPUT_SAMPLE_RATE], []);
let state = new Tensor("float32", new Float32Array(2 * 1 * 128), [2, 1, 128]);

// VAD state tracking
let isRecording = false;
let postSpeechSamples = 0;
let prevBuffers: Float32Array[] = [];

/**
 * Perform Voice Activity Detection (VAD)
 * @param {Float32Array} buffer The new audio buffer
 * @returns {Promise<boolean>} `true` if the buffer is speech, `false` otherwise.
 */
async function vad(buffer: Float32Array): Promise<boolean> {
  if (!silero_vad) throw new Error("VAD not initialized");

  const input = new Tensor("float32", buffer, [1, buffer.length]);
  const { stateN, output } = await silero_vad({ input, sr, state });
  state = stateN; // Update state

  const isSpeech = output.data[0];

  // Use heuristics to determine if the buffer is speech or not
  return (
    // Case 1: We are above the threshold (definitely speech)
    isSpeech > SPEECH_THRESHOLD ||
    // Case 2: We are in the process of recording, and the probability is above the negative (exit) threshold
    (isRecording && isSpeech >= EXIT_THRESHOLD)
  );
}

function resetAfterRecording(offset = 0) {
  BUFFER.fill(0, offset);
  bufferPointer = offset;
  isRecording = false;
  postSpeechSamples = 0;
}

function dispatchSpeechChunk(request_id: string, overflow?: Float32Array) {
  // Get timing information
  const now = Date.now();
  const end =
    now - ((postSpeechSamples + SPEECH_PAD_SAMPLES) / INPUT_SAMPLE_RATE) * 1000;
  const start = end - (bufferPointer / INPUT_SAMPLE_RATE) * 1000;
  const duration = end - start;
  const overflowLength = overflow?.length ?? 0;

  // Combine previous buffers with current buffer
  const buffer = BUFFER.slice(0, bufferPointer + SPEECH_PAD_SAMPLES);
  const prevLength = prevBuffers.reduce((acc, b) => acc + b.length, 0);
  const paddedBuffer = new Float32Array(prevLength + buffer.length);

  let offset = 0;
  for (const prev of prevBuffers) {
    paddedBuffer.set(prev, offset);
    offset += prev.length;
  }
  paddedBuffer.set(buffer, offset);

  // Send speech chunk
  postMessage(
    {
      type: "speech_chunk",
      buffer: paddedBuffer,
      start,
      end,
      duration,
      id: request_id,
    },
    [paddedBuffer.buffer]
  );

  // Handle overflow and reset
  if (overflow) {
    BUFFER.set(overflow, 0);
  }
  resetAfterRecording(overflowLength);
}

function resetState() {
  BUFFER.fill(0);
  bufferPointer = 0;
  isRecording = false;
  postSpeechSamples = 0;
  prevBuffers = [];
  state = new Tensor("float32", new Float32Array(2 * 1 * 128), [2, 1, 128]);
}

// Handle messages from main thread
self.addEventListener(
  "message",
  async (event: MessageEvent<VadWorkerMessage>) => {
    const { type, buffer, id } = event.data;
    switch (type) {
      case "init":
        await initializeVAD(id, (progress) => {
          postMessage({
            type: "progress",
            progress,
            id,
          });
        });
        return;

      case "reset":
        resetState();
        return;

      case "audio":
        if (!buffer || !isInitialized) return;
        await processAudioBuffer(buffer, id);
        return;
    }
  }
);

async function processAudioBuffer(buffer: Float32Array, request_id: string) {
  const wasRecording = isRecording;
  const isSpeech = await vad(buffer);

  if (!wasRecording && !isSpeech) {
    // Not recording and no speech - add to previous buffers queue
    if (prevBuffers.length >= MAX_NUM_PREV_BUFFERS) {
      prevBuffers.shift();
    }
    prevBuffers.push(buffer);
    return;
  }

  // Check if buffer exceeds remaining space
  const remaining = BUFFER.length - bufferPointer;
  if (buffer.length >= remaining) {
    // Buffer overflow - dispatch current chunk and start new one
    BUFFER.set(buffer.subarray(0, remaining), bufferPointer);
    bufferPointer += remaining;

    const overflow = buffer.subarray(remaining);
    dispatchSpeechChunk(request_id, overflow);
    return;
  } else {
    // Normal case - add buffer to global buffer
    BUFFER.set(buffer, bufferPointer);
    bufferPointer += buffer.length;
  }

  if (isSpeech) {
    if (!isRecording) {
      // Start of speech detected
      postMessage({ type: "speech_start", id: request_id });
      isRecording = true;
    }
    postSpeechSamples = 0; // Reset silence counter
    return;
  }

  // No speech in current buffer
  postSpeechSamples += buffer.length;

  // Check if we should end the speech chunk
  if (postSpeechSamples < MIN_SILENCE_DURATION_SAMPLES) {
    // Short pause - continue recording
    return;
  }

  if (bufferPointer < MIN_SPEECH_DURATION_SAMPLES) {
    // Speech too short - discard
    resetAfterRecording();
    return;
  }

  // End of speech chunk - dispatch it
  postMessage({ type: "speech_end", id: request_id });
  dispatchSpeechChunk(request_id);
}

const postMessage = (message: VadWorkerResponse, transfer?: Transferable[]) =>
  self.postMessage(message, null, transfer);

export {};
</file>

<file path="src/ai/agent.ts">
export const SYSTEM_PROMPT = `You are JARVIS, the sophisticated AI assistant from Iron Man.

# Core Traits

Voice: Refined British eloquence, dry wit, polite formality
Demeanor: Calm, loyal, genuinely protective
Expertise: Advanced tech, science, strategic planning

# Communication Style

Provide precise, proactive solutions
DO NOT use emojies or special characters like asterisks / *
End: Offer additional assistance`;

export const getEndInstructions = (keyword: string) => `# End conversation

When the user indicates they want to end the conversation (through phrases like "goodbye," "bye," "talk to you later," "that's all," "thanks, I'm done," or similar farewell expressions), respond with a polite farewell message and then include the exact keyword ${keyword} on a new line at the very end of your response.
But only use that if you are 100% sure the user explicitly told you to end the conversation!

Example format:
Thank you for the conversation! Have a great day.
${keyword}`;

export const INSTRUCTIONS = [
  "never use ellipsis (...)",
  "Keep your answers short but precise",
  "Only use tools if you absolutely have to.",
];
</file>

<file path="src/ai/types.ts">
import { McpServerWithState } from "@ai/mcp/react/types";

export enum ModelStatus {
  IDLE,
  MODEL_LOADING,
  CONVERSATION_LOADING,
  READY,
}

/* MESSAGES */

export interface Message {
  id: string;
  role: MessageRole;
  messageParts: Array<MessagePart>;
}

export enum MessageRole {
  ASSISTANT,
  USER,
  SYSTEM,
}

export type MessageUser = Message & {
  role: MessageRole.USER;
  messageParts: [MessagePartText];
};

export interface MessagePartBase {
  type: MessagePartType;
  id: string;
}

export enum MessagePartType {
  TEXT,
  TOOL_CALL,
}

export type MessagePartTool = MessagePartBase & {
  type: MessagePartType.TOOL_CALL;
  functionName: string;
  parameters: Record<string, any>;
  response: string;
  responseMedia?: {
    type: "image" | "audio";
    data: string;
    mimeType: string;
  };
};

export type MessagePartText = MessagePartBase & {
  type: MessagePartType.TEXT;
  text: string;
};

export type MessagePart = MessagePartTool | MessagePartText;

export interface Conversation {
  createConversation: (
    systemPrompt: string,
    mcpServers: Array<
      (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState
    >
  ) => void;
  messages: Array<Message>;
  onMessagesChange: (callback: (messages: Array<Message>) => void) => void;
  status: ModelStatus;
  onStatusChange: (callback: (status: ModelStatus) => void) => void;
  processPrompt: (
    message: MessageUser,
    onTextFeedback?: (feedback: string) => void
  ) => Promise<void>;
}

export interface ConversationConstructorOptions {
  log?: (message?: any, ...optionalParams: any[]) => void;
  onConversationEnded?: () => void;
  conversationEndKeyword?: string;
}

export interface McpServerStoreBase {
  name: string;
  active: boolean;
  activeTools: Array<string>;
  activePrompts: Array<string>;
}

export interface McpServerStoreHttp extends McpServerStoreBase {
  url: string;
}

export interface McpServerStoreBuiltIn extends McpServerStoreBase {
  serverType: "take_picture" | "memories" | string;
}

export type McpServerStore = McpServerStoreHttp | McpServerStoreBuiltIn;

export type XMLToolSignature = {
  functionName: string;
  parameters: Record<string, any>;
};
</file>

<file path="src/pages/ChatPage.tsx">
import useAgent from "@ai/agentContext/useAgent";
import { ModelStatus } from "@ai/types";
import { Dot, Loader, McpIcon, PageContent } from "@theme";
import DownLoadDisclaimer from "@ui/DownLoadDisclaimer";
import Chat from "@ui/chat/Chat";
import Jarvis from "@ui/jarvis/Jarvis";
import { Fragment } from "preact";
import { useEffect, useState } from "preact/hooks";

import { version } from "../../package.json";

export function ChatPage() {
  const [ui, setUi] = useState<"chat" | "jarvis">("jarvis");
  const {
    isMute,
    setMute,
    isDeaf,
    setDeaf,
    cacheCheckDone,
    allModelsLoaded,
    conversationStatus,
    evaluateConversation,
  } = useAgent();

  useEffect(() => {
    evaluateConversation();
  }, [cacheCheckDone, allModelsLoaded]);

  const conversationStatusText =
    conversationStatus === ModelStatus.IDLE
      ? "OFFLINE"
      : conversationStatus === ModelStatus.MODEL_LOADING
        ? "LOADING..."
        : conversationStatus === ModelStatus.CONVERSATION_LOADING
          ? "LOADING..."
          : conversationStatus === ModelStatus.READY
            ? "ONLINE"
            : "ERROR";

  return (
    <Fragment>
      <PageContent
        title={`JARVIS`}
        statusBar={{
          [`VERSION_${version}`]: false,
          [`STATUS: ${conversationStatusText}`]: true,
        }}
        button={{
          to: "/mcp",
          iconLeft: <McpIcon />,
          children: "MCP_SETTINGS",
        }}
      >
        {!cacheCheckDone ? (
          <div className="mt-24 flex items-center justify-center">
            <Loader size={10} />
          </div>
        ) : !allModelsLoaded ? (
          <DownLoadDisclaimer />
        ) : ui === "jarvis" ? (
          <Jarvis />
        ) : (
          <Chat conversationStatusText={conversationStatusText} />
        )}
      </PageContent>
      <div className="fixed bottom-8 left-8 space-y-2">
        <div className="text-secondary-300 flex items-center space-x-2 text-xs">
          <Dot />
          <button onClick={() => setDeaf(!isDeaf)} className="cursor-pointer">
            VOICE_DETECTION: {isDeaf ? "STANDBY" : "ACTIVE"}
          </button>
        </div>
        <div className="text-primary-300 flex items-center space-x-2 font-mono text-xs">
          <Dot />
          <button onClick={() => setMute(!isMute)} className="cursor-pointer">
            AUDIO_OUTPUT: {isMute ? "MUTED" : "ENABLED"}
          </button>
        </div>
      </div>

      <div className="fixed right-8 bottom-8">
        <button
          onClick={() => setUi(ui === "jarvis" ? "chat" : "jarvis")}
          className="group relative flex items-center space-x-2 rounded-lg border border-cyan-500/30 bg-slate-900/80 px-4 py-2 font-mono text-xs text-cyan-400 transition-all duration-300 hover:border-cyan-400/60 hover:bg-slate-800/90 hover:shadow-[0_0_20px_rgba(6,182,212,0.3)]"
        >
          <div
            className={`h-2 w-2 rounded-full transition-all duration-300 ${
              ui === "jarvis"
                ? "bg-orange-400 shadow-[0_0_8px_rgba(251,146,60,0.6)]"
                : "bg-cyan-400 shadow-[0_0_8px_rgba(6,182,212,0.6)]"
            }`}
          />
          <span className="transition-all duration-300 group-hover:text-cyan-300">
            {ui === "jarvis" ? "JARVIS" : "CHAT"}
          </span>
          <div className="text-slate-500 group-hover:text-slate-400">‚Üí</div>
          <span className="text-slate-400 transition-all duration-300 group-hover:text-cyan-300">
            {ui === "jarvis" ? "CHAT" : "JARVIS"}
          </span>
        </button>
      </div>
    </Fragment>
  );
}

export default ChatPage;
</file>

<file path="src/pages/McpPage.tsx">
import { ChatBubbleLeftRightIcon } from "@heroicons/react/24/outline";
import { PageContent } from "@theme";
import McpOverview from "@ui/mcp/McpOverview";

import { version } from "../../package.json";

export function McpPage() {
  return (
    <PageContent
      title="MCP_SERVERS_CONTROL"
      subtitle="MODEL_CONTEXT_PROTOCOL_MANAGEMENT_INTERFACE"
      statusBar={{
        [`VERSION_${version}`]: false,
        "MONITORING: ENABLED": true,
      }}
      button={{
        to: "/",
        iconLeft: <ChatBubbleLeftRightIcon width="1.25em" />,
        children: "RETURN_TO_CHAT",
      }}
    >
      <McpOverview />
    </PageContent>
  );
}

export default McpPage;
</file>

<file path="src/pages/OAuthCallbackPage.tsx">
import { useEffect } from 'preact/hooks';
import { onMcpAuthorization } from '@ai/mcp/auth/callback';

export default function OAuthCallbackPage() {
  useEffect(() => {
    // Handle the OAuth callback when component mounts
    onMcpAuthorization().catch((error) => {
      console.error('OAuth callback error:', error);
    });
  }, []);

  return (
    <div style={{ fontFamily: 'sans-serif', padding: '20px', textAlign: 'center' }}>
      <h1>Processing Authentication...</h1>
      <p>Please wait while we complete your authentication.</p>
      <p>This window will close automatically.</p>
    </div>
  );
}
</file>

<file path="src/theme/button/Button.tsx">
import cn from "@utils/classnames";
import { ComponentChildren } from "preact";
import { Link } from "preact-router";

import { Loader } from "../index";

type ButtonColor = "primary" | "secondary" | "danger";
type ButtonVariant = "solid" | "outline" | "ghost";
type ButtonSize = "sm" | "md" | "lg";

interface BaseButtonProps {
  children: ComponentChildren;
  className?: string;
  color?: ButtonColor;
  variant?: ButtonVariant;
  size?: ButtonSize;
  iconLeft?: ComponentChildren;
  iconRight?: ComponentChildren;
  disabled?: boolean;
  loading?: boolean;
  title?: string;
}

interface ButtonPropsButton extends BaseButtonProps {
  onClick?: () => void;
  type?: "button" | "submit" | "reset";
  href?: never;
}

interface ButtonPropsRouter extends BaseButtonProps {
  to: string;
}

export type ButtonProps = ButtonPropsRouter | ButtonPropsButton;

const colorVariantStyles: Record<ButtonColor, Record<ButtonVariant, string>> = {
  secondary: {
    solid:
      "bg-secondary-950/20 text-secondary-300 hover:bg-secondary-900/30 hover:shadow-[0_0_20px_rgba(0,162,255,0.3)] focus:ring-secondary-400/50 border-secondary-400/50 backdrop-blur-sm",
    outline:
      "bg-secondary-950/20 text-secondary-300 border-secondary-400/50 hover:bg-secondary-900/30 hover:shadow-[0_0_15px_rgba(0,162,255,0.3)] hover:border-secondary-300 focus:ring-secondary-400/50 backdrop-blur-sm",
    ghost:
      "bg-transparent text-secondary-300 border-transparent hover:bg-secondary-950/20 hover:shadow-[0_0_10px_rgba(0,162,255,0.2)] focus:ring-secondary-400/50",
  },
  primary: {
    solid:
      "bg-primary-950/20 text-primary-300 hover:bg-primary-900/30 hover:shadow-[0_0_20px_rgba(0,162,255,0.3)] focus:ring-primary-400/50 border-primary-400/50 backdrop-blur-sm",
    outline:
      "bg-primary-950/20 text-primary-300 border-primary-400/50 hover:bg-primary-900/30 hover:shadow-[0_0_15px_rgba(0,162,255,0.3)] hover:border-primary-300 focus:ring-primary-400/50 backdrop-blur-sm",
    ghost:
      "bg-transparent text-primary-300 border-transparent hover:bg-primary-950/20 hover:shadow-[0_0_10px_rgba(0,162,255,0.2)] focus:ring-primary-400/50",
  },
  danger: {
    solid:
      "bg-red-950/20 text-red-300 hover:bg-red-900/30 hover:shadow-[0_0_20px_rgba(255,0,0,0.3)] focus:ring-red-400/50 border-red-400/50 backdrop-blur-sm",
    outline:
      "bg-red-950/20 text-red-300 border-red-400/50 hover:bg-red-900/30 hover:shadow-[0_0_15px_rgba(255,0,0,0.3)] hover:border-red-300 focus:ring-red-400/50 backdrop-blur-sm",
    ghost:
      "bg-transparent text-red-300 border-transparent hover:bg-red-950/20 hover:shadow-[0_0_10px_rgba(255,0,0,0.2)] focus:ring-red-400/50",
  },
};

const sizeStyles: Record<ButtonSize, string> = {
  sm: "px-3 py-1.5 text-xs gap-1.5",
  md: "px-4 py-2 text-sm gap-2",
  lg: "px-6 py-3 text-base gap-2.5",
};

export default function Button({
  children,
  className = "",
  color = "primary",
  variant = "solid",
  size = "md",
  iconLeft,
  iconRight,
  disabled = false,
  loading = false,
  title = "",
  ...props
}: ButtonProps) {
  const baseStyles =
    "cursor-pointer inline-flex items-center justify-center gap-[1em] font-medium border focus:outline-none focus:ring-2 focus:ring-offset-2 transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed uppercase tracking-wider";

  const combinedClassName = cn(
    baseStyles,
    colorVariantStyles[color][variant],
    sizeStyles[size],
    className
  );

  const content = (
    <>
      {loading && <Loader />}
      {!loading && iconLeft && (
        <span className="flex-shrink-0">{iconLeft}</span>
      )}
      <span className="flex gap-2">{children}</span>
      {!loading && iconRight && (
        <span className="flex-shrink-0">{iconRight}</span>
      )}
    </>
  );

  if ("to" in props) {
    return (
      <Link {...({ href: props.to, className: combinedClassName, title } as any)}>
        {content}
      </Link>
    );
  }

  if ("onClick" in props || props.type === "submit") {
    return (
      <button
        type={"type" in props ? props.type : "button"}
        onClick={props.onClick}
        disabled={disabled || loading}
        className={combinedClassName}
        title={title}
      >
        {content}
      </button>
    );
  }
  return null;
}
</file>

<file path="src/theme/form/Checkbox.tsx">
import { FunctionComponent } from "preact";

import cn from "../../utils/classnames";

const Checkbox: FunctionComponent<{
  value: string;
  name: string;
  label: string;
  id: string;
  checked: boolean;
  onChange: (checked: boolean) => void;
  className?: string;
}> = ({ value, id, name, label, checked, onChange, className = "" }) => (
  <div className="flex gap-3">
    <div className="flex h-5 shrink-0 items-center">
      <div className={cn("group grid size-4 grid-cols-1", className)}>
        <input
          defaultValue={value}
          id={id}
          name={name}
          checked={checked}
          onChange={() => onChange(!checked)}
          type="checkbox"
          className="border-primary-400/50 bg-primary-950/20 checked:border-primary-300 checked:bg-primary-500/30 indeterminate:border-primary-300 indeterminate:bg-primary-500/30 focus-visible:outline-primary-400 disabled:border-primary-400/30 disabled:bg-primary-950/10 disabled:checked:bg-primary-950/10 col-start-1 row-start-1 appearance-none rounded-sm border backdrop-blur-sm transition-all duration-300 checked:shadow-[0_0_10px_rgba(59,130,246,0.3)] focus-visible:outline-2 focus-visible:outline-offset-2 forced-colors:appearance-auto"
        />
        <svg
          fill="none"
          viewBox="0 0 14 14"
          className="stroke-primary-100 group-has-disabled:stroke-primary-400/25 pointer-events-none col-start-1 row-start-1 size-3.5 self-center justify-self-center"
        >
          <path
            d="M3 8L6 11L11 3.5"
            strokeWidth={2}
            strokeLinecap="round"
            strokeLinejoin="round"
            className="opacity-0 group-has-checked:opacity-100"
          />
          <path
            d="M3 7H11"
            strokeWidth={2}
            strokeLinecap="round"
            strokeLinejoin="round"
            className="opacity-0 group-has-indeterminate:opacity-100"
          />
        </svg>
      </div>
    </div>
    <label htmlFor={id} className="text-primary-300 text-sm">
      {label}
    </label>
  </div>
);

export default Checkbox;
</file>

<file path="src/theme/form/FormField.tsx">
import cn from "@utils/classnames";
import { ComponentChildren } from "preact";

interface FormFieldProps {
  children: ComponentChildren;
  className?: string;
  label?: string;
  description?: string;
  required?: boolean;
  id: string;
  error?: string;
}

export default function FormField({
  children,
  className = "",
  label,
  description,
  required = false,
  id,
  error,
}: FormFieldProps) {
  return (
    <div className={cn("space-y-1", className)}>
      {Boolean(label) && (
        <label
          htmlFor={id}
          className={cn(
            "text-primary-300 block text-xs font-medium tracking-wider uppercase"
          )}
        >
          {label}
          {required && <span className="ml-1 text-red-400">*</span>}
        </label>
      )}

      {children}

      {Boolean(description) && (
        <p className="text-primary-400/80 text-xs">{description}</p>
      )}

      {Boolean(error) && <p className="text-xs text-red-400">{error}</p>}
    </div>
  );
}
</file>

<file path="src/theme/form/InputText.tsx">
import cn from "@utils/classnames";
import FormField from "./FormField";
import { InputTextProps } from "./types";

export default function InputText({
  className = "",
  type = "text",
  name,
  id,
  label,
  description,
  required = false,
  placeholder = "",
  value,
  error,
  disabled = false,
  onChange,
  onKeyDown,
  onFocus,
  onBlur,
}: InputTextProps) {
  return (
    <FormField
      className={className}
      label={label}
      description={description}
      required={required}
      id={id}
      error={error}
    >
      <input
        type={type}
        name={name}
        id={id}
        placeholder={placeholder}
        disabled={disabled}
        className={cn(
          "border-primary-400/70 bg-primary-950/40 text-primary-100 focus:border-primary-300 focus:ring-primary-400/70 placeholder:text-primary-400/60 w-full border px-3.5 py-2 text-base text-sm shadow-[inset_0_0_15px_rgba(0,162,255,0.2)] backdrop-blur-sm focus:ring-2 focus:outline-none",
          error && "border-red-400/70 focus:border-red-300 focus:ring-red-400/70",
          disabled && "opacity-50 cursor-not-allowed"
        )}
        value={value}
        onChange={onChange}
        onKeyDown={onKeyDown}
        onFocus={onFocus}
        onBlur={onBlur}
        required={required}
      />
    </FormField>
  );
}
</file>

<file path="src/theme/form/RadioGroup.tsx">
import { RadioGroup as HeadlessRadioGroup, Radio } from "@headlessui/react";
import { ComponentChildren, FunctionComponent } from "preact";

import cn from "../../utils/classnames";

const RadioGroup: FunctionComponent<{
  value: string;
  onChange: (value: string) => void;
  className?: string;
  choices: Array<{ value: string; label: ComponentChildren; className?: string }>;
}> = ({ value, onChange, className = "", choices }) => (
  <HeadlessRadioGroup
    value={value}
    onChange={onChange}
    className={cn("grid grid-cols-3 gap-3 sm:grid-cols-6", className)}
  >
    {choices.map((choice) => (
      <Radio
        key={choice.value}
        value={choice.value}
        aria-label={choice.value}
        className={cn(
          choice?.className ||
            "flex items-center justify-center border border-blue-400/50 bg-blue-950/20 backdrop-blur-sm px-3 py-3 text-sm font-medium text-blue-300 font-mono uppercase tracking-wider hover:bg-blue-900/30 hover:shadow-[0_0_15px_rgba(0,162,255,0.3)] data-checked:border-blue-300 data-checked:bg-blue-500/30 data-checked:text-blue-100 data-checked:shadow-[0_0_20px_rgba(0,162,255,0.4)] data-checked:hover:bg-blue-500/40 data-focus:ring-2 data-focus:ring-blue-400/50 data-focus:ring-offset-2 transition-all duration-300 sm:flex-1"
          //"relative -m-0.5 flex cursor-pointer items-center justify-center rounded-full p-0.5 focus:outline-hidden data-checked:ring-2 data-focus:data-checked:ring-3 data-focus:data-checked:ring-offset-1"
        )}
      >
        {choice.label}
      </Radio>
    ))}
  </HeadlessRadioGroup>
);

export default RadioGroup;
</file>

<file path="src/theme/form/Select.tsx">
import cn from "@utils/classnames";

import FormField from "./FormField";
import { SelectProps } from "./types";

export default function Select({
  className = "",
  name,
  id,
  label,
  description,
  required = false,
  value,
  options,
  placeholder,
  error,
  disabled = false,
  onChange,
  onFocus,
  onBlur,
}: SelectProps) {
  return (
    <FormField
      className={className}
      label={label}
      description={description}
      required={required}
      id={id}
      error={error}
    >
      <div className="relative">
        <select
          name={name}
          id={id}
          disabled={disabled}
          className={cn(
            "border-primary-400/70 bg-primary-950/40 text-primary-100 focus:border-primary-300 focus:ring-primary-400/70 w-full cursor-pointer appearance-none border px-3.5 py-2 text-base text-sm shadow-[inset_0_0_15px_rgba(0,162,255,0.2)] backdrop-blur-sm focus:ring-2 focus:outline-none",
            error &&
              "border-red-400/70 focus:border-red-300 focus:ring-red-400/70",
            disabled && "cursor-not-allowed opacity-50"
          )}
          value={value}
          onChange={onChange}
          onFocus={onFocus}
          onBlur={onBlur}
          required={required}
        >
          {placeholder && (
            <option value="" disabled className="text-primary-400/60">
              {placeholder}
            </option>
          )}
          {options.map((option) => (
            <option
              key={option.value}
              value={option.value}
              disabled={option.disabled}
              className="bg-primary-950 text-primary-100"
            >
              {option.label}
            </option>
          ))}
        </select>

        {/* Custom dropdown arrow */}
        <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
          <svg
            className="text-primary-400 h-4 w-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </div>
      </div>
    </FormField>
  );
}
</file>

<file path="src/theme/form/Textarea.tsx">
import cn from "@utils/classnames";

import FormField from "./FormField";
import { TextareaProps } from "./types";

export default function Textarea({
  className = "",
  name,
  id,
  label,
  description,
  required = false,
  placeholder = "",
  value,
  rows = 4,
  cols,
  resize = "vertical",
  error,
  disabled = false,
  onChange,
  onKeyDown,
  onFocus,
  onBlur,
}: TextareaProps) {
  const resizeClass = {
    none: "resize-none",
    both: "resize",
    horizontal: "resize-x",
    vertical: "resize-y",
  }[resize];

  return (
    <FormField
      className={className}
      label={label}
      description={description}
      required={required}
      id={id}
      error={error}
    >
      <textarea
        name={name}
        id={id}
        placeholder={placeholder}
        rows={rows}
        cols={cols}
        disabled={disabled}
        className={cn(
          "border-primary-400/70 bg-primary-950/40 text-primary-100 focus:border-primary-300 focus:ring-primary-400/70 placeholder:text-primary-400/60 w-full border px-3.5 py-2 text-base text-sm shadow-[inset_0_0_15px_rgba(0,162,255,0.2)] backdrop-blur-sm focus:ring-2 focus:outline-none",
          resizeClass,
          error &&
            "border-red-400/70 focus:border-red-300 focus:ring-red-400/70",
          disabled && "cursor-not-allowed opacity-50"
        )}
        value={value}
        onChange={onChange}
        onKeyDown={onKeyDown}
        onFocus={onFocus}
        onBlur={onBlur}
        required={required}
      />
    </FormField>
  );
}
</file>

<file path="src/theme/form/types.ts">
import { JSX } from "preact";

// Base form field props shared by all form components
export interface BaseFormFieldProps {
  className?: string;
  name: string;
  id: string;
  label?: string;
  description?: string;
  required?: boolean;
  error?: string;
  disabled?: boolean;
}

// Input-specific props
export interface InputTextProps extends BaseFormFieldProps {
  type?: string;
  placeholder?: string;
  value: string;
  onChange?: (e: JSX.TargetedEvent<HTMLInputElement, Event>) => void;
  onKeyDown?: (e: JSX.TargetedKeyboardEvent<HTMLInputElement>) => void;
  onFocus?: (e: JSX.TargetedFocusEvent<HTMLInputElement>) => void;
  onBlur?: (e: JSX.TargetedFocusEvent<HTMLInputElement>) => void;
}

// Textarea-specific props
export interface TextareaProps extends BaseFormFieldProps {
  placeholder?: string;
  value: string;
  rows?: number;
  cols?: number;
  resize?: "none" | "both" | "horizontal" | "vertical";
  onChange?: (e: JSX.TargetedEvent<HTMLTextAreaElement, Event>) => void;
  onKeyDown?: (e: JSX.TargetedKeyboardEvent<HTMLTextAreaElement>) => void;
  onFocus?: (e: JSX.TargetedFocusEvent<HTMLTextAreaElement>) => void;
  onBlur?: (e: JSX.TargetedFocusEvent<HTMLTextAreaElement>) => void;
}

// Select option type
export interface SelectOption {
  value: string;
  label: string;
  disabled?: boolean;
}

// Select-specific props
export interface SelectProps extends BaseFormFieldProps {
  value: string;
  options: SelectOption[];
  placeholder?: string;
  onChange?: (e: JSX.TargetedEvent<HTMLSelectElement, Event>) => void;
  onFocus?: (e: JSX.TargetedFocusEvent<HTMLSelectElement>) => void;
  onBlur?: (e: JSX.TargetedFocusEvent<HTMLSelectElement>) => void;
}
</file>

<file path="src/theme/jarvis/Crosshair.tsx">
import cn from "@utils/classnames";

export default function Crosshair({ className = "" }: { className?: string }) {
  return (
    <div
      className={cn(
        className,
        "pointer-events-none flex -translate-x-1/2 -translate-y-1/2 items-center justify-center"
      )}
    >
      <div className="bg-primary-400/60 absolute -top-4 left-1/2 h-8 w-0.5 -translate-x-1/2 transform" />
      <div className="bg-primary-400/60 absolute -bottom-4 left-1/2 h-8 w-0.5 -translate-x-1/2 transform" />
      <div className="bg-primary-400/60 absolute top-1/2 -left-4 h-0.5 w-8 -translate-y-1/2 transform" />
      <div className="bg-primary-400/60 absolute top-1/2 -right-4 h-0.5 w-8 -translate-y-1/2 transform" />
      <div className="border-primary-400/60 h-4 w-4 rounded-full border" />
    </div>
  );
}
</file>

<file path="src/theme/misc/Dot.tsx">
export default function Dot() {
  return (
    <div className="h-[0.8em] w-[0.8em] animate-pulse rounded-full bg-current" />
  );
}
</file>

<file path="src/theme/misc/Loader.tsx">
import cn from "@utils/classnames";
import { FunctionComponent } from "preact";

const Loader: FunctionComponent<{ size?: 4 | 5 | 6 | 8 | 10 }> = ({
  size = 5,
}) => {
  const sizeClass =
    {
      4: "h-4 w-4",
      5: "h-5 w-5",
      6: "h-6 w-6",
      8: "h-8 w-8",
      10: "h-10 w-10",
    }[size] || "h-5 w-5";

  return (
    <svg
      className={cn(
        sizeClass,
        "animate-spin rounded-full shadow-[0_0_10px_rgba(0,162,255,0.5)]"
      )}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
    >
      <circle
        className="opacity-25"
        cx="12"
        cy="12"
        r="10"
        stroke="currentColor"
        strokeWidth="4"
      ></circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      ></path>
    </svg>
  );
};

export default Loader;
</file>

<file path="src/theme/misc/LoadingDots.tsx">
import { useEffect, useState } from "preact/hooks";

export default function LoadingDots() {
  const [active, setActive] = useState<1 | 2 | 3>(1);

  useEffect(() => {
    const interval = window.setInterval(
      () => setActive(active === 3 ? 1 : active === 2 ? 3 : 2),
      400
    );
    return () => {
      window.clearInterval(interval);
    };
  }, [active]);

  return (
    <span>
      <span style={{ opacity: 1 }}>.</span>
      <span style={{ opacity: active !== 1 ? 1 : 0 }}>.</span>
      <span style={{ opacity: active === 3 ? 1 : 0 }}>.</span>
    </span>
  );
}
</file>

<file path="src/theme/misc/McpIcon.tsx">
import { FunctionComponent } from "preact";

interface McpIconProps {
  width?: string;
  height?: string;
  className?: string;
}

const McpIcon: FunctionComponent<McpIconProps> = ({
  width = "1em",
  height = "1em",
  className = "",
}) => (
  <svg
    fill="currentColor"
    fillRule="evenodd"
    height={height}
    style={{ flex: "none", lineHeight: 1 }}
    viewBox="0 0 24 24"
    width={width}
    xmlns="http://www.w3.org/2000/svg"
    className={`${className} drop-shadow-[0_0_5px_rgba(0,162,255,0.3)]`}
  >
    <path d="M15.688 2.343a2.588 2.588 0 00-3.61 0l-9.626 9.44a.863.863 0 01-1.203 0 .823.823 0 010-1.18l9.626-9.44a4.313 4.313 0 016.016 0 4.116 4.116 0 011.204 3.54 4.3 4.3 0 013.609 1.18l.05.05a4.115 4.115 0 010 5.9l-8.706 8.537a.274.274 0 000 .393l1.788 1.754a.823.823 0 010 1.18.863.863 0 01-1.203 0l-1.788-1.753a1.92 1.92 0 010-2.754l8.706-8.538a2.47 2.47 0 000-3.54l-.05-.049a2.588 2.588 0 00-3.607-.003l-7.172 7.034-.002.002-.098.097a.863.863 0 01-1.204 0 .823.823 0 010-1.18l7.273-7.133a2.47 2.47 0 00-.003-3.537z"></path>
    <path d="M14.485 4.703a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a4.115 4.115 0 000 5.9 4.314 4.314 0 006.016 0l7.12-6.982a.823.823 0 000-1.18.863.863 0 00-1.204 0l-7.119 6.982a2.588 2.588 0 01-3.61 0 2.47 2.47 0 010-3.54l7.12-6.982z"></path>
  </svg>
);

export default McpIcon;
</file>

<file path="src/theme/misc/Message.tsx">
import cn from "@utils/classnames";
import { ComponentChildren } from "preact";

export type MessageType = "info" | "warning" | "success" | "error";

interface MessageProps {
  type: MessageType;
  title?: string;
  children: ComponentChildren;
  className?: string;
}

const messageStyles: Record<MessageType, string> = {
  info: "border-blue-400/50 bg-blue-950/20 shadow-[0_0_15px_rgba(59,130,246,0.2)]",
  warning:
    "border-yellow-400/50 bg-yellow-950/20 shadow-[0_0_15px_rgba(234,179,8,0.2)]",
  success:
    "border-green-400/50 bg-green-950/20 shadow-[0_0_15px_rgba(34,197,94,0.2)]",
  error:
    "border-red-400/50 bg-red-950/20 shadow-[0_0_15px_rgba(239,68,68,0.2)]",
};

const titleStyles: Record<MessageType, string> = {
  info: "text-blue-300 uppercase tracking-wider",
  warning: "text-yellow-300 uppercase tracking-wider",
  success: "text-green-300 uppercase tracking-wider",
  error: "text-red-300 uppercase tracking-wider",
};

const contentStyles: Record<MessageType, string> = {
  info: "text-blue-200 font-mono",
  warning: "text-yellow-200 font-mono",
  success: "text-green-200 font-mono",
  error: "text-red-200 font-mono",
};

export function Message({ type, title, children, className }: MessageProps) {
  return (
    <div className={cn("border p-4", messageStyles[type], className)}>
      {title && (
        <h3 className={cn("mb-2 text-sm font-bold", titleStyles[type])}>
          {title}
        </h3>
      )}
      <div className={cn("text-sm", contentStyles[type])}>{children}</div>
    </div>
  );
}

export default Message;
</file>

<file path="src/theme/misc/Progress.tsx">
import cn from "@utils/classnames";
import { FunctionComponent } from "preact";

interface ProgressProps {
  value: number;
  max?: number;
  size?: "sm" | "md" | "lg";
  variant?: "primary" | "secondary" | "danger";
  showLabel?: boolean;
  className?: string;
}

const Progress: FunctionComponent<ProgressProps> = ({
  value,
  max = 100,
  size = "md",
  variant = "primary",
  showLabel = false,
  className = "",
}) => {
  const percentage = Math.min(100, Math.max(0, (value / max) * 100));

  const sizeStyles = {
    sm: "h-1",
    md: "h-2",
    lg: "h-3",
  }[size];

  const variantStyles = {
    primary: {
      bg: "bg-primary-950/20 backdrop-blur-sm border-primary-400/30",
      fill: "bg-primary-400 shadow-[0_0_10px_rgba(0,162,255,0.5)]",
    },
    secondary: {
      bg: "bg-secondary-950/20 backdrop-blur-sm border-secondary-400/30",
      fill: "bg-secondary-400 shadow-[0_0_10px_rgba(0,162,255,0.5)]",
    },
    danger: {
      bg: "bg-red-950/20 backdrop-blur-sm border-red-400/30",
      fill: "bg-red-400 shadow-[0_0_10px_rgba(255,0,0,0.5)]",
    },
  }[variant];

  return (
    <div className={cn("w-full", className)}>
      {showLabel && (
        <div className="mb-1 flex justify-between text-xs text-secondary-300">
          <span>{Math.round(percentage)}%</span>
          <span>{value}/{max}</span>
        </div>
      )}
      <div
        className={cn(
          "w-full overflow-hidden rounded-full border",
          sizeStyles,
          variantStyles.bg
        )}
      >
        <div
          className={cn(
            "h-full rounded-full transition-all duration-300 ease-out",
            variantStyles.fill
          )}
          style={{ width: `${percentage}%` }}
        />
      </div>
    </div>
  );
};

export default Progress;
</file>

<file path="src/theme/modal/Modal.tsx">
import {
  Dialog,
  DialogBackdrop,
  DialogPanel,
  DialogTitle,
} from "@headlessui/react";
import { XMarkIcon } from "@heroicons/react/24/outline";
import { ComponentChildren, FunctionComponent } from "preact";

export type ModalSize = "sm" | "md" | "lg" | "xl" | "2xl";

const sizeClasses: Record<ModalSize, string> = {
  sm: "sm:max-w-md",
  md: "sm:max-w-lg",
  lg: "sm:max-w-2xl",
  xl: "sm:max-w-4xl",
  "2xl": "sm:max-w-6xl",
};

const Modal: FunctionComponent<{
  open: boolean;
  setOpen: (open: boolean) => void;
  title: string;
  subtitle?: string;
  children: ComponentChildren;
  size?: ModalSize;
}> = ({ open, setOpen, title, subtitle, children, size = "md" }) => (
  <Dialog open={open} onClose={setOpen} className="relative z-10">
    <DialogBackdrop
      transition
      className="fixed inset-0 bg-black/70 backdrop-blur-sm transition-opacity data-closed:opacity-0 data-enter:duration-300 data-enter:ease-out data-leave:duration-200 data-leave:ease-in"
    />
    <div className="fixed inset-0 z-10 w-screen overflow-y-auto">
      <div className="flex min-h-full items-end justify-center p-4 sm:items-center sm:p-0">
        <DialogPanel
          transition
          className={`border-primary-400/30 bg-primary-950/20 relative transform overflow-hidden border p-4 text-left shadow-[0_0_500px_rgba(0,162,255,0.2)] backdrop-blur-sm transition-all data-closed:translate-y-4 data-closed:opacity-0 data-enter:duration-300 data-enter:ease-out data-leave:duration-200 data-leave:ease-in sm:my-8 sm:w-full ${sizeClasses[size]} data-closed:sm:translate-y-0 data-closed:sm:scale-95`}
        >
          <div className="absolute top-4 right-4 hidden sm:block">
            <button
              type="button"
              onClick={() => setOpen(false)}
              className="border-primary-400/30 bg-primary-950/20 text-primary-300 hover:bg-primary-900/30 hover:text-primary-200 focus:ring-primary-400/50 cursor-pointer border backdrop-blur-sm transition-all duration-300 hover:shadow-[0_0_15px_rgba(0,162,255,0.3)] focus:ring-2 focus:ring-offset-2 focus:outline-hidden"
            >
              <span className="sr-only">Close</span>
              <XMarkIcon aria-hidden="true" className="size-6" />
            </button>
          </div>
          <div className="mt-3 sm:mt-5">
            <DialogTitle
              as="h3"
              className="text-text-bright text-base font-semibold tracking-wider uppercase"
            >
              {title}
            </DialogTitle>
            {Boolean(subtitle) && (
              <p className="text-text/80 mt-2 text-sm">{subtitle}</p>
            )}
            <div className="mt-10 text-sm">{children}</div>
          </div>
        </DialogPanel>
      </div>
    </div>
  </Dialog>
);

export default Modal;
</file>

<file path="src/theme/page/Background.tsx">
export default function Background() {
  return (
    <div className="fixed inset-0 flex h-screen items-center justify-center overflow-hidden bg-black">
      <div className="from-primary-950/20 absolute inset-0 bg-gradient-to-br via-black to-cyan-950/20">
        <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(0,162,255,0.1),transparent_50%)]" />
        <div className="absolute inset-0 animate-pulse bg-[linear-gradient(45deg,transparent_30%,rgba(0,162,255,0.05)_50%,transparent_70%)]" />
      </div>
      <div className="absolute inset-0 bg-[linear-gradient(rgba(0,162,255,0.1)_1px,transparent_1px),linear-gradient(90deg,rgba(0,162,255,0.1)_1px,transparent_1px)] bg-[size:50px_50px] opacity-30" />
      <div className="border-primary-400/50 absolute top-4 left-4 h-16 w-16 border-t-2 border-l-2" />
      <div className="border-primary-400/50 absolute top-4 right-4 h-16 w-16 border-t-2 border-r-2" />
      <div className="border-primary-400/50 absolute bottom-4 left-4 h-16 w-16 border-b-2 border-l-2" />
      <div className="border-primary-400/50 absolute right-4 bottom-4 h-16 w-16 border-r-2 border-b-2" />
    </div>
  );
}
</file>

<file path="src/theme/page/ContentBox.tsx">
import cn from "@utils/classnames";
import { ComponentChildren } from "preact";

export default function ContentBox({
  children,
  header,
  className = "",
  wrapperClassName = "",
}: {
  children?: ComponentChildren;
  header?: ComponentChildren;
  className?: string;
  wrapperClassName?: string;
}) {
  return (
    <div
      className={cn(
        wrapperClassName,
        "border-primary-400/30 bg-primary-950/10 border shadow-[0_0_20px_rgba(0,162,255,0.1)] backdrop-blur-sm"
      )}
    >
      {header && (
        <div className="border-b border-blue-400/20 bg-gradient-to-r from-blue-500/10 via-transparent to-blue-500/10 px-6 py-4">
          {header}
        </div>
      )}
      <div className={cn(className, "p-4")}>{children}</div>
    </div>
  );
}
</file>

<file path="src/theme/page/PageContent.tsx">
import cn from "@utils/classnames";
import { useState, useEffect, useMemo } from "preact/hooks";
import { ComponentChildren } from "preact";

import { ButtonProps } from "../button/Button";
import { Button } from "../index";

export default function PageContent({
  title,
  subtitle,
  children,
  className = "",
  statusBar = {},
  button = null,
}: {
  title: string;
  subtitle?: string;
  children?: ComponentChildren;
  className?: string;
  statusBar?: Record<string, boolean>;
  button?: ButtonProps;
}) {
  const [time, setTime] = useState<number>(new Date().getTime());

  useEffect(() => {
    const interval = setInterval(() => {
      setTime(new Date().getTime());
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  const timeString: string = useMemo(
    () => new Date().toLocaleTimeString(),
    [time]
  );

  return (
    <div
      className={cn(className, "mx-auto my-[5vh] w-10/12 max-w-4xl space-y-4")}
    >
      <header className="border-primary-400/30 from-primary-500/20 to-primary-500/20 border bg-gradient-to-r via-cyan-400/20 p-4 shadow-[0_0_30px_rgba(0,162,255,0.2)] backdrop-blur-sm">
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-primary-300 text-4xl font-bold drop-shadow-[0_0_10px_rgba(0,162,255,0.8)]">
              {title}
            </h1>
            {Boolean(subtitle) && (
              <p className="text-primary-400/80 mt-1 text-lg">{subtitle}</p>
            )}
          </div>
          {button && <Button {...button} />}
        </div>
        {Object.entries(statusBar).length !== 0 && (
          <div className="border-primary-400/20 text-primary-300/60 mt-3 flex items-center justify-between border-t pt-2 text-sm">
            {Object.entries(statusBar).map(([text, animate]) => (
              <span className={cn({ "animate-pulse": animate })} key={text}>
                {text}
              </span>
            ))}
            <span>{timeString}</span>
          </div>
        )}
      </header>
      {children}
    </div>
  );
}
</file>

<file path="src/theme/index.ts">
export { default as Background } from "./page/Background";
export { default as PageContent } from "./page/PageContent";
export { default as ContentBox } from "./page/ContentBox";
export { default as Loader } from "./misc/Loader";
export { default as McpIcon } from "./misc/McpIcon";
export { default as Dot } from "./misc/Dot";
export { default as Message, type MessageType } from "./misc/Message";
export { default as Progress } from "./misc/Progress";
export { default as LoadingDots } from "./misc/LoadingDots";
export { default as FormField } from "./form/FormField";
export { default as Checkbox } from "./form/Checkbox";
export { default as RadioGroup } from "./form/RadioGroup";
export { default as InputText } from "./form/InputText";
export { default as Textarea } from "./form/Textarea";
export { default as Select } from "./form/Select";
export type {
  InputTextProps,
  TextareaProps,
  SelectProps,
  SelectOption,
} from "./form/types";
export { default as Button } from "./button/Button";
export { default as Modal, type ModalSize } from "./modal/Modal";
export { default as Crosshair } from "./jarvis/Crosshair";
</file>

<file path="src/ui/chat/Chat.tsx">
import useAgent from "@ai/agentContext/useAgent";
import { ModelStatus } from "@ai/types";
import { PaperAirplaneIcon } from "@heroicons/react/24/outline";
import { Button, ContentBox, InputText } from "@theme";
import cn from "@utils/classnames";
import { JSX } from "preact";
import { useEffect, useMemo, useRef, useState } from "preact/hooks";

import { Message } from "./Message";

export default function Chat({
  conversationStatusText,
  className = "",
}: {
  conversationStatusText: string;
  className?: string;
}) {
  const listRef = useRef<HTMLUListElement>(null);
  const messagesLengthRef = useRef<number>(0);
  const [prompt, setPrompt] = useState<string>("");
  const { conversationStatus, messages, submit } = useAgent();

  const messagesLength = useMemo(
    () => JSON.stringify(messages).length,
    [messages]
  );

  useEffect(() => {
    if (messagesLength === messagesLengthRef.current) return;
    const list = listRef.current;
    if (!list) return;
    list.scrollTop = list.scrollHeight;
    messagesLengthRef.current = messagesLength;
  }, [messagesLength]);

  const onSubmit = async (e: JSX.TargetedEvent<HTMLFormElement, Event>) => {
    e.preventDefault();
    if (prompt && conversationStatus === ModelStatus.READY) submit(prompt);
    setPrompt("");
  };

  return (
    <div className={cn(className, "space-y-4")}>
      <ContentBox className="!p-0">
        <ul
          ref={listRef}
          className="scrollbar-hide max-h-[50vh] space-y-4 overflow-y-auto p-4"
        >
          {messages.map((message) => (
            <li key={message.id}>
              <Message message={message} />
            </li>
          ))}
        </ul>
      </ContentBox>
      <ContentBox className="space-y-4 p-4">
        <form className="flex w-full items-stretch gap-2" onSubmit={onSubmit}>
          <InputText
            type="text"
            id="prompt"
            name="prompt"
            placeholder="ENTER_COMMAND..."
            className="w-full"
            value={prompt}
            onChange={(e) => setPrompt((e.target as HTMLInputElement).value)}
          />
          <Button
            type="submit"
            disabled={conversationStatus !== ModelStatus.READY}
          >
            <PaperAirplaneIcon width="1.5em" />
          </Button>
        </form>
        <div className="flex items-center justify-between">
          <p className="text-text-bright text-xs">
            AI_CORE: {conversationStatusText}
          </p>
        </div>
      </ContentBox>
    </div>
  );
}
</file>

<file path="src/ui/chat/Message.tsx">
import {
  Message as MessageI,
  MessagePart,
  MessagePartType,
  MessageRole,
} from "@ai/types";
import { Loader } from "@theme";
import cn from "@utils/classnames";
import nl2brJsx from "@utils/nl2brJsx";

const icons = {
  [MessageRole.ASSISTANT]: (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1rem"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      className="-translate-y-1/15"
    >
      <path d="M12 8V4H8" />
      <rect width="16" height="12" x="4" y="8" rx="2" />
      <path d="M2 14h2" />
      <path d="M20 14h2" />
      <path d="M15 13v2" />
      <path d="M9 13v2" />
    </svg>
  ),
  [MessageRole.USER]: (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1rem"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      className="-translate-y-1/15"
    >
      <path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" />
      <circle cx="12" cy="7" r="4" />
    </svg>
  ),
  [MessageRole.SYSTEM]: (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1rem"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="2"
      stroke-linecap="round"
      stroke-linejoin="round"
      className="-translate-y-1/15"
    >
      <path d="M12 6V2H8" />
      <path d="m8 18-4 4V8a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2Z" />
      <path d="M2 12h2" />
      <path d="M9 11v2" />
      <path d="M15 11v2" />
      <path d="M20 12h2" />
    </svg>
  ),
};

function MessagePartRenderer({ part }: { part: MessagePart }) {
  if (part.type === MessagePartType.TEXT) {
    return (
      <div>
        <p className="text-text-bright text-sm leading-relaxed">
          {nl2brJsx(part.text).flat()}
        </p>
      </div>
    );
  }

  if (part.type === MessagePartType.TOOL_CALL) {
    return (
      <div className="border-primary-400/60 bg-primary-950/40 my-4 border p-3">
        <div className="text-text-bright mb-2 flex items-center gap-2 text-xs font-medium">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="1rem"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="text-primary-300"
          >
            <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />
          </svg>
          TOOL_EXECUTION: {part.functionName}
        </div>
        <div className="text-text-bright/90 mb-2 text-xs">
          <strong>PARAMETERS:</strong>
          <pre className="border-primary-400/30 text-text-superbright/80 mt-1 max-w-full overflow-x-auto rounded border bg-black/50 p-2 text-xs">
            {JSON.stringify(part.parameters, null, 2)}
          </pre>
        </div>
        {part.response && (
          <div className="text-text-bright/90 text-xs">
            <strong>OUTPUT:</strong>
            <p className="text-text-superbright mt-1">{part.response}</p>
          </div>
        )}
        {part.responseMedia && (
          <div className="mt-2">
            {part.responseMedia.type === "image" && (
              <img
                src={`data:${part.responseMedia.mimeType};base64,${part.responseMedia.data}`}
                alt="Tool response"
                className="border-primary-400/50 max-w-full rounded border shadow-[0_0_15px_rgba(0,162,255,0.4)]"
              />
            )}
            {part.responseMedia.type === "audio" && (
              <audio
                src={`data:${part.responseMedia.mimeType};base64,${part.responseMedia.data}`}
                controls
                className="max-w-full"
                style={{
                  filter: "invert(1) hue-rotate(180deg) brightness(0.8)",
                }}
              />
            )}
          </div>
        )}
      </div>
    );
  }

  return null;
}

export function Message({
  message,
  className = "",
}: {
  message: MessageI;
  className?: string;
}) {
  return (
    <div
      className={cn(
        className,
        "flex",
        message.role === MessageRole.USER ? "flex-row" : "flex-row-reverse"
      )}
    >
      <div className="border-primary-400/60 bg-primary-950/30 w-19/20 border p-4">
        <p className="mb-4 text-xs">
          <span className="flex items-center gap-2">
            {message.role === MessageRole.ASSISTANT ? (
              <>
                <span className="text-text">
                  {icons[MessageRole.ASSISTANT]}
                </span>
                <span className="text-text-bright">JARVIS</span>
              </>
            ) : message.role === MessageRole.USER ? (
              <>
                <span className="text-text">{icons[MessageRole.USER]}</span>
                <span className="text-text-bright">USER_INPUT</span>
              </>
            ) : message.role === MessageRole.SYSTEM ? (
              <>
                <span className="text-text">{icons[MessageRole.SYSTEM]}</span>
                <span className="text-text-bright">SYSTEM_DIRECTIVE</span>
              </>
            ) : (
              ""
            )}
          </span>
        </p>
        <div>
          {message.messageParts.length > 0 ? (
            message.messageParts.map((part) => (
              <MessagePartRenderer key={part.id} part={part} />
            ))
          ) : (
            <div className="text-text flex items-center gap-2 text-sm">
              <Loader size={4} />
              PROCESSING_REQUEST...
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/jarvis/Jarvis.tsx">
import useAgent from "@ai/agentContext/useAgent";
import {
  MessagePartTool,
  MessagePartType,
  MessageRole,
  ModelStatus,
} from "@ai/types";
import { LoadingDots } from "@theme";
import { useEffect, useRef, useState } from "preact/hooks";
import toast from "react-hot-toast";

import Rings from "./Rings";
import ToolCallPopup from "./ToolCallPopup";

const JARVIS_KEYWORDS = [
  "charmus",
  "jarvis",
  "JARIFAS",
  "Charmis",
  "Jarmus",
].map((s) => s.toLowerCase());

export default function Jarvis({}: {}) {
  const {
    isSpeaking,
    submit,
    onVadDetected,
    messages,
    conversationStatus,
    isDeaf,
    setDeaf,
    setMute,
    jarvisActive,
    setJarvisActive,
  } = useAgent();
  const [activeRequest, setActiveRequest] = useState<string>("");
  const [audioLevels, setAudioLevels] = useState<number[]>([0, 0, 0, 0, 0, 0]);
  const processedToolCalls = useRef<Set<string>>(new Set());

  useEffect(() => {
    if (import.meta.env.VITE_IS_PRESENTATION !== "true") setDeaf(false);
    setMute(false);
    return () => {
      setDeaf(true);
      setMute(true);
    };
  }, []);

  useEffect(() => {
    if (!jarvisActive || !isSpeaking) {
      setAudioLevels([0, 0, 0, 0, 0, 0]);
      return;
    }

    const interval = setInterval(() => {
      if (isSpeaking) {
        setAudioLevels((prev) => prev.map(() => Math.random() * 100));
      } else {
        setAudioLevels((prev) => prev.map((level) => Math.max(0, level * 0.8)));
      }
    }, 100);

    return () => clearInterval(interval);
  }, [jarvisActive, isSpeaking]);

  useEffect(() => {
    const unsubscribe = onVadDetected((text: string) => {
      if (isSpeaking) {
        return;
      } else if (jarvisActive) {
        console.log("[ACTIVE_REQUEST]", text);
        setActiveRequest(text);
        submit(text).finally(() => setActiveRequest(""));
      } else if (
        JARVIS_KEYWORDS.some((word) => text.toLowerCase().includes(word))
      ) {
        setJarvisActive(true);
        console.log("[ACTIVE_REQUEST]", text);
        setActiveRequest(text);
        submit(text).finally(() => setActiveRequest(""));
      } else {
        console.log("[INACTIVE]", text);
      }
    });
    return () => {
      unsubscribe();
    };
  }, [onVadDetected, submit, jarvisActive, isSpeaking]);

  useEffect(() => {
    const toolCalls = messages
      .filter((m) => m.role === MessageRole.ASSISTANT)
      .flatMap(
        (m) =>
          m.messageParts.filter(
            (mp) => mp.type === MessagePartType.TOOL_CALL
          ) as MessagePartTool[]
      );

    toolCalls
      .filter((tc) => !processedToolCalls.current.has(tc.id))
      .forEach((tc) => {
        toast.custom(<ToolCallPopup id={tc.id} />, { duration: 20000 });
        processedToolCalls.current.add(tc.id);
      });
  }, [messages]);

  const text =
    conversationStatus === ModelStatus.CONVERSATION_LOADING ||
    conversationStatus === ModelStatus.MODEL_LOADING ? (
      <span>
        Please wait a moment while
        <br />
        everything is being prepared
        <LoadingDots />
      </span>
    ) : isSpeaking ? (
      <span>VOICE OUTPUT</span>
    ) : isDeaf ? (
      <span>Activate voice detection first.</span>
    ) : jarvisActive ? (
      <span>{activeRequest}</span>
    ) : (
      <span>READY! Start the conversation with "Jarvis"</span>
    );

  return (
    <div className="relative flex w-full flex-col items-center justify-center gap-12 pt-44">
      <div className="relative">
        <Rings
          isActive={jarvisActive || isSpeaking}
          isSpeaking={isSpeaking}
          audioLevels={audioLevels}
          size="1.5vmin"
        />
      </div>

      <div className="text-center">
        <div
          className={`font-mono text-sm transition-all duration-500 ${
            jarvisActive
              ? isSpeaking
                ? "animate-pulse text-orange-400"
                : "text-cyan-400"
              : "text-slate-500"
          }`}
        >
          {text}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/jarvis/Rings.tsx">
import cn from "@utils/classnames";

export default function Rings({
  isActive,
  isSpeaking,
  audioLevels,
  size = "10vmin",
  className = "",
}: {
  isActive: boolean;
  isSpeaking: boolean;
  audioLevels: number[];
  size?: string;
  className?: string;
}) {
  return (
    <div
      className={cn(
        "relative flex h-[20em] w-[20em] items-center justify-center",
        className
      )}
      style={{ fontSize: size }}
    >
      {/* Outermost Ring with Dots */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive ? "animate-spin border-cyan-300/40" : "border-slate-500/20"
        }`}
        style={{
          width: "20em",
          height: "20em",
          borderWidth: "0.125em",
          borderStyle: "solid",
          borderRadius: "50%",
          animationDuration: "12s",
        }}
      >
        {/* Orbital Dots */}
        <div
          className="absolute left-1/2 -translate-x-1/2 rounded-full bg-cyan-400 opacity-60"
          style={{
            width: "0.5em",
            height: "0.5em",
            top: "-0.25em",
          }}
        />
        <div
          className="absolute left-1/2 -translate-x-1/2 rounded-full bg-cyan-400 opacity-60"
          style={{
            width: "0.5em",
            height: "0.5em",
            bottom: "-0.25em",
          }}
        />
        <div
          className="absolute top-1/2 -translate-y-1/2 rounded-full bg-cyan-400 opacity-60"
          style={{
            width: "0.5em",
            height: "0.5em",
            left: "-0.25em",
          }}
        />
        <div
          className="absolute top-1/2 -translate-y-1/2 rounded-full bg-cyan-400 opacity-60"
          style={{
            width: "0.5em",
            height: "0.5em",
            right: "-0.25em",
          }}
        />
      </div>

      {/* Outer Ring */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive ? "animate-spin border-cyan-400/60" : "border-slate-600/30"
        }`}
        style={{
          width: "15em",
          height: "15em",
          borderWidth: "0.125em",
          borderStyle: "solid",
          borderRadius: "50%",
          animationDuration: "8s",
        }}
      >
        {/* Spinning Lines */}
        <div
          className="absolute top-0 left-1/2 -translate-x-1/2 bg-cyan-400 opacity-80"
          style={{ height: "1.5em", width: "0.0625em" }}
        />
        <div
          className="absolute bottom-0 left-1/2 -translate-x-1/2 bg-cyan-400 opacity-80"
          style={{ height: "1.5em", width: "0.0625em" }}
        />
      </div>

      {/* Middle Ring with Segments */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive ? "animate-spin" : ""
        }`}
        style={{
          width: "12em",
          height: "12em",
          animationDuration: "4s",
          animationDirection: "reverse",
        }}
      >
        {/* Segmented Arc */}
        <div
          className={`h-full w-full border-transparent transition-all duration-1000`}
          style={{
            borderRadius: "50%",
            borderWidth: "0.125em",
            borderStyle: "solid",
            borderTopColor: isActive
              ? "rgba(59, 130, 246, 0.7)"
              : "rgba(51, 65, 85, 0.2)",
            borderRightColor: isActive
              ? "rgba(59, 130, 246, 0.5)"
              : "rgba(51, 65, 85, 0.2)",
            borderBottomColor: "transparent",
            borderLeftColor: isActive
              ? "rgba(59, 130, 246, 0.3)"
              : "rgba(51, 65, 85, 0.2)",
          }}
        />
      </div>

      {/* Inner Ring */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive ? "animate-spin border-blue-400/40" : "border-slate-700/20"
        }`}
        style={{
          width: "10em",
          height: "10em",
          borderWidth: "0.0625em",
          borderStyle: "solid",
          borderRadius: "50%",
          animationDuration: "6s",
          animationDirection: "reverse",
        }}
      >
        {/* Inner Indicators */}
        <div
          className="absolute left-1/2 -translate-x-1/2 rounded-full bg-blue-400 opacity-70"
          style={{
            width: "0.25em",
            height: "0.25em",
            top: "-0.125em",
          }}
        />
        <div
          className="absolute left-1/2 -translate-x-1/2 rounded-full bg-blue-400 opacity-70"
          style={{
            width: "0.25em",
            height: "0.25em",
            bottom: "-0.125em",
          }}
        />
      </div>

      {/* Core Ring */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive ? "animate-spin border-cyan-500/30" : "border-slate-800/20"
        }`}
        style={{
          width: "7em",
          height: "7em",
          borderWidth: "0.0625em",
          borderStyle: "solid",
          borderRadius: "50%",
          animationDuration: "3s",
        }}
      />

      {/* Audio Level Indicators */}
      {isActive && (
        <div
          id="audio"
          className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
          style={{ width: "24em", height: "24em" }}
        >
          {audioLevels.map((level, i) => {
            return (
              <div
                key={i}
                className="absolute bg-cyan-400 transition-all duration-150"
                style={{
                  width: "0.125em",
                  height: "1em",
                  //height: `${Math.max(0.25, level * 0.01875)}em`,
                  left: "50%",
                  top: "50%",
                  transformOrigin: "top left",
                  transform: `rotate(${i * 60}deg) translateY(calc(-${10 + level * 0.01}em)) translateX(-0.0625em)`,
                  opacity: isSpeaking ? 0.8 : 0.3,
                  boxShadow: isSpeaking
                    ? `0 0 0.625em rgba(6, 182, 212, ${level * 0.01})`
                    : "none",
                }}
              />
            );
          })}
        </div>
      )}

      {/* Speaking Ring Expansion */}
      {isSpeaking && isActive && (
        <div
          className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 animate-pulse border border-cyan-400/30"
          style={{
            width: "18em",
            height: "18em",
            borderRadius: "50%",
            animationDuration: "0.8s",
          }}
        />
      )}

      {/* Central Core */}
      <div
        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-1000 ${
          isActive
            ? isSpeaking
              ? "animate-pulse bg-orange-400"
              : "animate-pulse bg-cyan-500"
            : "bg-slate-600"
        }`}
        style={{
          width: "5em",
          height: "5em",
          borderRadius: "50%",
          transform: isSpeaking && isActive ? "scale(1.1)" : "scale(1)",
          transition: "transform 0.2s ease-in-out",
          boxShadow: isActive
            ? isSpeaking
              ? "0 0 3.125em rgba(251, 146, 60, 0.8)"
              : "0 0 2.5em rgba(6, 182, 212, 0.6)"
            : "0 0 0.625em rgba(100, 116, 139, 0.3)",
        }}
      >
        {/* Core Pulse */}
        <div
          className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 rounded-full ${
            isActive ? "animate-ping bg-white" : "bg-slate-300 opacity-50"
          }`}
          style={{
            width: "1em",
            height: "1em",
            animationDuration: isSpeaking ? "0.5s" : "2s",
          }}
        />

        {/* Core Lines */}
        {isActive && (
          <>
            <div
              className="absolute left-1/2 -translate-x-1/2 bg-white/60 transition-all duration-150"
              style={{
                width: "0.0625em",
                height: isSpeaking ? "1.25em" : "1em",
                top: "0.5em",
                opacity: isSpeaking ? 1 : 0.6,
              }}
            />
            <div
              className="absolute left-1/2 -translate-x-1/2 bg-white/60 transition-all duration-150"
              style={{
                width: "0.0625em",
                height: isSpeaking ? "1.25em" : "1em",
                bottom: "0.5em",
                opacity: isSpeaking ? 1 : 0.6,
              }}
            />
            <div
              className="absolute top-1/2 -translate-y-1/2 bg-white/60 transition-all duration-150"
              style={{
                height: "0.0625em",
                width: isSpeaking ? "1.25em" : "1em",
                left: "0.5em",
                opacity: isSpeaking ? 1 : 0.6,
              }}
            />
            <div
              className="absolute top-1/2 -translate-y-1/2 bg-white/60 transition-all duration-150"
              style={{
                height: "0.0625em",
                width: isSpeaking ? "1.25em" : "1em",
                right: "0.5em",
                opacity: isSpeaking ? 1 : 0.6,
              }}
            />
          </>
        )}
      </div>

      {/* Floating Particles */}
      {isActive && (
        <>
          <div
            className="absolute animate-ping rounded-full bg-cyan-400 opacity-80"
            style={{
              width: "0.25e m",
              height: "0.25em",
              top: "30%",
              left: "20%",
              animationDelay: "0s",
              animationDuration: "3s",
            }}
          />
          <div
            className="absolute animate-ping rounded-full bg-blue-400 opacity-60"
            style={{
              width: "0.25em",
              height: "0.25em",
              top: "70%",
              right: "25%",
              animationDelay: "1s",
              animationDuration: "4s",
            }}
          />
          <div
            className="absolute animate-ping rounded-full bg-cyan-300 opacity-70"
            style={{
              width: "0.25em",
              height: "0.25em",
              top: "25%",
              right: "30%",
              animationDelay: "2s",
              animationDuration: "3.5s",
            }}
          />
        </>
      )}
    </div>
  );
}
</file>

<file path="src/ui/jarvis/ToolCallPopup.tsx">
import useAgent from "@ai/agentContext/useAgent";
import { MessagePartTool, MessagePartType, MessageRole } from "@ai/types";
import cn from "@utils/classnames";
import { useMemo } from "preact/hooks";

interface ToolCallPopupProps {
  id: string;
}

export default function ToolCallPopup({ id }: ToolCallPopupProps) {
  const { messages } = useAgent();
  const toolCall = useMemo(
    () =>
      messages
        .filter((m) => m.role === MessageRole.ASSISTANT)
        .flatMap(
          (m) =>
            m.messageParts.filter(
              (mp) => mp.type === MessagePartType.TOOL_CALL
            ) as MessagePartTool[]
        )
        .find((tc) => tc.id === id),
    [id, messages]
  );

  if (!toolCall) {
    return null;
  }

  return (
    <div className={cn("w-[300px]")}>
      <div className="relative w-full rounded-lg border border-cyan-500/30 bg-slate-900/90 p-4 shadow-[0_0_20px_rgba(6,182,212,0.2)] backdrop-blur-sm">
        {/* Connecting line to center */}
        <div className="absolute top-1/2 right-full h-px w-8 -translate-y-1/2 bg-gradient-to-l from-cyan-500/50 to-transparent" />

        {/* Content */}
        <div className="space-y-2">
          <div className="flex items-center space-x-2">
            <div className="h-2 w-2 animate-pulse rounded-full bg-cyan-400" />
            <div className="font-mono text-xs tracking-wider text-cyan-400 uppercase">
              Tool Call
            </div>
          </div>

          <div className="font-mono text-sm text-white">
            {toolCall.functionName}
          </div>

          {Object.keys(toolCall.parameters).length > 0 && (
            <div className="font-mono text-xs text-slate-300">
              {Object.entries(toolCall.parameters).map(([key, value]) => (
                <div key={key} className="truncate">
                  <span className="text-cyan-300">{key}:</span>{" "}
                  <span className="text-slate-400">
                    {typeof value === "string"
                      ? value.slice(0, 30)
                      : JSON.stringify(value).slice(0, 30)}
                    {(typeof value === "string"
                      ? value.length
                      : JSON.stringify(value).length) > 30 && "..."}
                  </span>
                </div>
              ))}
            </div>
          )}

          <div className="mt-2 border-t border-slate-700 pt-2 font-mono text-xs">
            <div className="mb-1 flex items-center space-x-2">
              <div
                className={`h-1.5 w-1.5 rounded-full ${toolCall.response ? "animate-pulse bg-green-400" : "bg-yellow-400"}`}
              />
              <div
                className={`tracking-wider uppercase ${toolCall.response ? "text-green-400" : "text-yellow-400"}`}
              >
                {toolCall.response ? "Result" : "Pending"}
              </div>
            </div>
            <div className="max-h-20 overflow-y-auto rounded bg-slate-800/50 p-2">
              {toolCall.response ? (
                <div className="overflow-hidden text-green-300">
                  {toolCall.response.length <= 100 ? (
                    toolCall.response
                  ) : (
                    <>
                      <div>{toolCall.response.slice(0, 100)}...</div>
                      <div className="mt-1 text-xs text-slate-400 italic">
                        ({toolCall.response.length} chars total)
                      </div>
                    </>
                  )}
                </div>
              ) : (
                <div className="text-yellow-300 italic">
                  Awaiting response...
                </div>
              )}
            </div>
          </div>

          {toolCall.responseMedia && (
            <div className="font-mono text-xs text-blue-300">
              <div className="flex items-center space-x-1">
                <div className="h-1 w-1 rounded-full bg-blue-400" />
                <span>{toolCall.responseMedia.type.toUpperCase()}</span>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/ui/mcp/components/McpPrompts.tsx">
import { Prompt } from "@modelcontextprotocol/sdk/types.js";
import { Checkbox } from "@theme";
import cn from "@utils/classnames";

function McpPrompts({
  className = "",
  prompts = [],
  activePrompts,
  serverId,
  handleTogglePrompt,
}: {
  className?: string;
  prompts: Array<Prompt>;
  activePrompts: Array<string>;
  serverId: string;
  handleTogglePrompt: (name: string, checked: boolean) => void;
}) {
  return (
    <div className={cn("border-t border-blue-400/20 px-6 py-4", className)}>
      <h4 className="mb-3 font-mono text-sm font-medium tracking-wider text-blue-300 uppercase">
        PROMPTS_AVAILABLE ({activePrompts.length}/{prompts.length} ACTIVE)
      </h4>
      <div className="space-y-3">
        {prompts.map((prompt) => (
          <div
            key={prompt.name}
            className="border border-purple-400/30 bg-purple-950/10 p-4 text-sm shadow-[0_0_10px_rgba(147,51,234,0.1)] backdrop-blur-sm"
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <Checkbox
                    id={`prompt-${prompt.name}-${serverId}`}
                    name={`prompt-${prompt.name}`}
                    value={prompt.name}
                    label=""
                    checked={activePrompts.includes(prompt.name)}
                    onChange={(checked) =>
                      handleTogglePrompt(prompt.name, checked)
                    }
                  />
                  <h5 className="font-mono font-medium tracking-wider text-purple-300 uppercase">
                    {prompt.name}
                  </h5>
                  <span className="font-mono text-xs text-purple-400/80">
                    {activePrompts.includes(prompt.name)
                      ? "(ACTIVE)"
                      : "(INACTIVE)"}
                  </span>
                </div>
                {prompt.description && (
                  <p className="mt-1 font-mono text-purple-400/80">
                    {prompt.description}
                  </p>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default McpPrompts;
</file>

<file path="src/ui/mcp/components/McpResources.tsx">
import { Resource } from "@modelcontextprotocol/sdk/types.js";
import cn from "@utils/classnames";

function McpResources({
  className = "",
  resources = [],
}: {
  className?: string;
  resources: Array<Resource>;
}) {
  return (
    <div className={cn("border-t border-blue-400/20 px-6 py-4", className)}>
      <h4 className="mb-3 text-sm font-medium text-blue-300 font-mono uppercase tracking-wider">
        RESOURCES_AVAILABLE ({resources.length})
      </h4>
      <div className="space-y-2">
        {resources.map((resource) => (
          <div
            key={resource.uri}
            className="border border-blue-400/30 bg-blue-950/10 backdrop-blur-sm p-2 text-sm shadow-[0_0_10px_rgba(0,162,255,0.1)]"
          >
            <div className="font-medium text-blue-300 font-mono uppercase tracking-wider">
              {resource.name || resource.uri}
            </div>
            {resource.description && (
              <div className="mt-1 text-blue-400/80 font-mono">{resource.description}</div>
            )}
            <div className="mt-1 font-mono text-xs text-blue-400/60">
              {resource.uri}
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}

export default McpResources;
</file>

<file path="src/ui/mcp/components/McpServerHeader.tsx">
import { McpState } from "@ai/mcp/McpServer";
import type { McpServerWithState } from "@ai/mcp/react/types";
import useMcpServer from "@ai/mcp/react/useMcpServer";
import { McpServerStoreBuiltIn, McpServerStoreHttp } from "@ai/types";
import { PowerIcon, TrashIcon } from "@heroicons/react/24/outline";
import { Button } from "@theme";
import cn from "@utils/classnames";

const getStateColor = (state: McpState) => {
  switch (state) {
    case McpState.READY:
      return "bg-green-500/20 text-green-400 border-green-400/50 shadow-[0_0_10px_rgba(34,197,94,0.3)]";
    case McpState.CONNECTING:
    case McpState.LOADING:
      return "bg-yellow-500/20 text-yellow-400 border-yellow-400/50 shadow-[0_0_10px_rgba(234,179,8,0.3)]";
    case McpState.FAILED:
      return "bg-red-500/20 text-red-400 border-red-400/50 shadow-[0_0_10px_rgba(239,68,68,0.3)]";
    case McpState.IDLE:
      return "bg-primary500/20 text-primary-400 border-primary400/50 shadow-[0_0_10px_rgba(59,130,246,0.3)]";
    default:
      return "bg-primary500/20 text-primary-400 border-primary400/50 shadow-[0_0_10px_rgba(59,130,246,0.3)]";
  }
};

const getStateIcon = (state: McpState) => {
  switch (state) {
    case McpState.READY:
      return "‚óè";
    case McpState.CONNECTING:
    case McpState.LOADING:
      return "‚óê";
    case McpState.FAILED:
      return "‚óè";
    case McpState.IDLE:
      return "‚óã";
    default:
      return "‚óã";
  }
};

const getStateText = (state: McpState) => {
  switch (state) {
    case McpState.READY:
      return "ONLINE";
    case McpState.CONNECTING:
      return "CONNECTING";
    case McpState.LOADING:
      return "INITIALIZING";
    case McpState.FAILED:
      return "ERROR";
    case McpState.IDLE:
      return "STANDBY";
    default:
      return "";
  }
};

function McpServerHeader({
  serverInfo,
}: {
  serverInfo: (McpServerStoreHttp | McpServerStoreBuiltIn) & McpServerWithState;
}) {
  const isBuiltin = "serverType" in serverInfo;

  const { removeHttpServer, updateServerConfig } = useMcpServer();

  return (
    <div className="flex items-center justify-between">
      <div className="flex items-center space-x-3">
        <span
          className={cn(
            "inline-flex items-center border px-2 py-1 text-xs font-medium backdrop-blur-sm",
            getStateColor(serverInfo.state)
          )}
        >
          <span className="mr-1">{getStateIcon(serverInfo.state)}</span>
          {getStateText(serverInfo.state)}
        </span>

        <span
          className={cn(
            "inline-flex items-center border px-2 py-1 text-xs font-medium backdrop-blur-sm",
            {
              "border-primary400/50 bg-primary500/20 text-primary-300 shadow-[0_0_10px_rgba(59,130,246,0.3)]":
                serverInfo.active,
              "border-primary400/30 bg-primary950/10 text-primary-400/60":
                !serverInfo.active,
            }
          )}
        >
          {serverInfo.active ? "ACTIVE" : "INACTIVE"}
        </span>

        <div>
          <div className="flex items-center gap-2">
            <h3 className="text-primary-300 text-lg font-semibold tracking-wider uppercase">
              {serverInfo.name}
            </h3>
            {serverInfo.server && (
              <span className="text-primary-400/80 text-sm">
                ({serverInfo.activeTools.length}/
                {serverInfo.server.tools.length} TOOL
                {serverInfo.server.tools.length !== 1 ? "S" : ""} ACTIVE)
              </span>
            )}
          </div>
          <p className="text-primary-400/60 text-xs">
            {isBuiltin
              ? `BUILTIN_MODULE ‚Ä¢ ${(serverInfo as any).serverType.toUpperCase()}`
              : `HTTP_ENDPOINT ‚Ä¢ ${(serverInfo as any).url}`}
          </p>
          {serverInfo.error && (
            <p className="mt-1 text-xs text-red-400">
              ERROR: {serverInfo.error}
            </p>
          )}
        </div>
      </div>

      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() =>
            updateServerConfig({
              ...serverInfo,
              active: !serverInfo.active,
            })
          }
          color={serverInfo.active ? "primary" : "secondary"}
          title={serverInfo.active ? "DEACTIVATE_SERVER" : "ACTIVATE_SERVER"}
        >
          <PowerIcon width="1em" />
        </Button>

        {!isBuiltin && (
          <Button
            variant="outline"
            size="sm"
            onClick={() => removeHttpServer((serverInfo as any).url)}
            color="danger"
            title="TERMINATE_CONNECTION"
          >
            <TrashIcon width="1em" />
          </Button>
        )}
      </div>
    </div>
  );
}

export default McpServerHeader;
</file>

<file path="src/ui/mcp/components/McpTools.tsx">
import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { Button, Checkbox } from "@theme";
import cn from "@utils/classnames";

function McpTools({
  className = "",
  tools = [],
  activeTools,
  serverId,
  handleToggleTool,
  openToolModal,
  serverActive,
}: {
  className?: string;
  tools: Array<Tool>;
  activeTools: Array<string>;
  serverId: string;
  handleToggleTool: (name: string, checked: boolean) => void;
  openToolModal: (tool: Tool) => void;
  serverActive: boolean;
}) {
  return (
    <div className={cn("px-6 py-4", className)}>
      <h4 className="text-primary-300 mb-3 text-sm font-medium tracking-wider uppercase">
        TOOLS_AVAILABLE ({activeTools.length}/{tools.length} ACTIVE)
      </h4>
      <div className="space-y-3">
        {tools.map((tool) => (
          <div
            key={tool.name}
            className="border-primary-400/30 bg-primary-950/10 border p-4"
          >
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <Checkbox
                    id={`tool-${tool.name}-${serverId}`}
                    name={`tool-${tool.name}`}
                    value={tool.name}
                    label=""
                    checked={activeTools.includes(tool.name)}
                    onChange={(checked) => handleToggleTool(tool.name, checked)}
                  />
                  <h5 className="text-primary-300 text-sm font-medium tracking-wider uppercase">
                    {tool.name}
                  </h5>
                  <span className="text-primary-400/80 text-xs">
                    {activeTools.includes(tool.name)
                      ? "(ACTIVE)"
                      : "(INACTIVE)"}
                  </span>
                </div>
                {tool.description && (
                  <p className="text-primary-400/80 mt-1 text-sm">
                    {tool.description}
                  </p>
                )}
              </div>
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => openToolModal(tool)}
                  disabled={!activeTools.includes(tool.name) || !serverActive}
                >
                  EXECUTE_TOOL
                </Button>
              </div>
            </div>

            {tool.inputSchema && (
              <div className="mt-3">
                <details className="group">
                  <summary className="text-primary-300 hover:text-primary-200 cursor-pointer text-xs font-medium tracking-wider uppercase">
                    INPUT_SCHEMA
                  </summary>
                  <div className="border-primary-400/20 mt-2 border bg-black/30 p-3 text-xs">
                    <pre className="text-primary-300/80 scrollbar-hide overflow-x-auto">
                      {JSON.stringify(tool.inputSchema, null, 2)}
                    </pre>
                  </div>
                </details>
              </div>
            )}
          </div>
        ))}
      </div>
    </div>
  );
}

export default McpTools;
</file>

<file path="src/ui/mcp/AddHttpServer.tsx">
import useMcpServer from "@ai/mcp/react/useMcpServer";
import { PlusIcon } from "@heroicons/react/24/outline";
import { Button, InputText, Message } from "@theme";
import cn from "@utils/classnames";
import { useState } from "preact/hooks";
import { JSX } from "preact";

interface AddHttpServerProps {
  className?: string;
}

function AddHttpServer({ className = "" }: AddHttpServerProps) {
  const { addHttpServer } = useMcpServer();

  const [newServer, setNewServer] = useState({ name: "", url: "" });
  const [addServerError, setAddServerError] = useState<string | null>(
    null
  );
  const [addServerLoading, setAddServerLoading] =
    useState<boolean>(false);

  const handleAddServer = async () => {
    if (!newServer.name.trim() || !newServer.url.trim()) {
      return;
    }
    setAddServerLoading(true);
    setAddServerError(null);

    try {
      await addHttpServer(newServer.name.trim(), newServer.url.trim());
      setNewServer({ name: "", url: "" });
    } catch (e) {
      setAddServerError(e.toString());
    } finally {
      setAddServerLoading(false);
    }
  };

  const handleKeyDown = (e: JSX.TargetedKeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" && newServer.name.trim() && newServer.url.trim()) {
      e.preventDefault();
      handleAddServer();
    }
  };

  return (
    <div className={cn("space-y-4", className)}>
      <h3 className="text-sm font-medium">INITIALIZE_HTTP_SERVER_CONNECTION</h3>
      <div className="flex gap-3">
        <InputText
          name="server-name"
          id="server-name"
          placeholder="LOCAL_MCP_SERVER"
          label="SERVER_DESIGNATION"
          value={newServer.name}
          onChange={(e) =>
            setNewServer((prev) => ({ ...prev, name: (e.target as HTMLInputElement).value }))
          }
          onKeyDown={handleKeyDown}
          className="w-full"
        />
        <InputText
          name="server-url"
          id="server-url"
          type="url"
          label="CONNECTION_ENDPOINT"
          placeholder="https://api.server.com/mcp"
          value={newServer.url}
          onChange={(e) =>
            setNewServer((prev) => ({ ...prev, url: (e.target as HTMLInputElement).value }))
          }
          onKeyDown={handleKeyDown}
          className="w-full"
        />
        <div className="flex items-end">
          <Button
            variant="outline"
            onClick={handleAddServer}
            loading={addServerLoading}
            disabled={!newServer.name.trim() || !newServer.url.trim()}
            className="h-[38px] px-3"
            title="ESTABLISH_CONNECTION"
          >
            <PlusIcon width="1em" />
          </Button>
        </div>
      </div>
      {addServerError && <Message type="error">{addServerError}</Message>}
    </div>
  );
}

export default AddHttpServer;
</file>

<file path="src/ui/mcp/CallTool.tsx">
import { McpServer } from "@ai/mcp/McpServer";
import {
  Button,
  Checkbox,
  InputText,
  Message,
  Modal,
  Select,
  Textarea,
} from "@theme";
import type { SelectOption } from "@theme";
import { useState } from "preact/hooks";

interface Tool {
  name: string;
  description?: string;
  inputSchema?: any;
}

interface CallToolProps {
  isOpen: boolean;
  onClose: () => void;
  server: McpServer;
  tool: Tool;
}

export function CallTool({ isOpen, onClose, server, tool }: CallToolProps) {
  const [parameters, setParameters] = useState<Record<string, any>>({});
  const [result, setResult] = useState<any>(null);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // Generate form fields based on the tool's input schema
  const generateFormFields = () => {
    if (!tool.inputSchema?.properties) {
      return null;
    }

    const properties = tool.inputSchema.properties;
    const required = tool.inputSchema.required || [];

    return Object.entries(properties).map(([key, schema]: [string, any]) => {
      const isRequired = required.includes(key);

      return renderFormField(
        key,
        schema,
        parameters[key],
        isRequired,
        (value) => setParameters((prev) => ({ ...prev, [key]: value }))
      );
    });
  };

  const renderFormField = (
    key: string,
    schema: any,
    value: any,
    isRequired: boolean,
    onChange: (value: any) => void
  ) => {
    const fieldId = `tool-${tool.name}-${key}`;

    if (schema.type === "boolean") {
      return (
        <div key={key}>
          <div className="mb-1">
            <span className="text-primary-300 text-xs font-medium tracking-wider uppercase">
              {key.toUpperCase()}
              {isRequired && <span className="ml-1 text-red-400">*</span>}
            </span>
          </div>
          {schema.description && (
            <p className="text-primary-400/80 mb-2 text-xs">
              {schema.description}
            </p>
          )}
          <Checkbox
            id={fieldId}
            name={key}
            value={value ? "true" : "false"}
            label="Enable"
            checked={value || false}
            onChange={(checked) => onChange(checked)}
          />
        </div>
      );
    }

    if (schema.type === "number" || schema.type === "integer") {
      return (
        <InputText
          key={key}
          id={fieldId}
          name={key}
          type="number"
          label={key.toUpperCase()}
          description={schema.description}
          required={isRequired}
          value={value?.toString() || ""}
          placeholder={`Enter ${key}...`}
          onChange={(e) => {
            const target = e.target as HTMLInputElement;
            const numValue = target.value ? Number(target.value) : undefined;
            onChange(numValue);
          }}
        />
      );
    }

    if (schema.enum) {
      const options: SelectOption[] = schema.enum.map((option: string) => ({
        value: option,
        label: option,
      }));

      return (
        <Select
          key={key}
          id={fieldId}
          name={key}
          label={key.toUpperCase()}
          description={schema.description}
          required={isRequired}
          value={value || ""}
          options={options}
          placeholder={`Select ${key}...`}
          onChange={(e) =>
            onChange((e.target as HTMLInputElement).value || undefined)
          }
        />
      );
    }

    if (schema.type === "object" || schema.type === "array") {
      return (
        <Textarea
          key={key}
          id={fieldId}
          name={key}
          label={key.toUpperCase()}
          description={
            schema.description
              ? `${schema.description} (JSON format)`
              : "Enter as JSON"
          }
          required={isRequired}
          value={value ? JSON.stringify(value, null, 2) : ""}
          rows={4}
          placeholder={`Enter ${key} as JSON...`}
          onChange={(e) => {
            try {
              const target = e.target as HTMLTextAreaElement;
              const parsed = target.value
                ? JSON.parse(target.value)
                : undefined;
              onChange(parsed);
            } catch {
              // Invalid JSON, keep the string value for now
              onChange((e.target as HTMLTextAreaElement).value);
            }
          }}
        />
      );
    }

    // Default to text input
    return (
      <InputText
        key={key}
        id={fieldId}
        name={key}
        label={key.toUpperCase()}
        description={schema.description}
        required={isRequired}
        value={value || ""}
        placeholder={`Enter ${key}...`}
        onChange={(e) =>
          onChange((e.target as HTMLInputElement).value || undefined)
        }
      />
    );
  };

  const handleCall = async () => {
    setIsLoading(true);
    setError(null);
    setResult(null);

    try {
      const toolResult = await server.callTool(tool.name, parameters);
      setResult(toolResult);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error occurred");
    } finally {
      setIsLoading(false);
    }
  };

  const handleClose = () => {
    setParameters({});
    setResult(null);
    setError(null);
    onClose();
  };

  const formatResult = (result: any) => {
    if (result?.content) {
      return result.content.map((item: any, index: number) => {
        if (item.type === "text") {
          return (
            <div key={index} className="mb-2">
              <div className="text-text mb-1 text-xs font-medium uppercase">
                TEXT_OUTPUT:
              </div>
              <div className="text-primary-200 text-sm whitespace-pre-wrap">
                {item.text}
              </div>
            </div>
          );
        }
        if (item.type === "image") {
          return (
            <div key={index} className="mb-2">
              <div className="text-text mb-1 text-xs font-medium uppercase">
                IMAGE_OUTPUT:
              </div>
              <img
                src={`data:${item.mimeType};base64,${item.data}`}
                alt="Tool result"
                className="border-primary-400/30 max-w-full border shadow-[0_0_10px_rgba(0,162,255,0.2)]"
              />
            </div>
          );
        }
        return (
          <div key={index} className="mb-2">
            <div className="text-text mb-1 text-xs font-medium uppercase">
              {item.type || "UNKNOWN"}_OUTPUT:
            </div>
            <pre className="text-text/80 border-primary-400/20 overflow-x-auto border bg-black/30 p-2 text-xs">
              {JSON.stringify(item, null, 2)}
            </pre>
          </div>
        );
      });
    }

    return (
      <pre className="text-text/80 border-primary-400/20 overflow-x-auto border bg-black/30 p-3 text-sm">
        {JSON.stringify(result, null, 2)}
      </pre>
    );
  };

  return (
    <Modal
      open={isOpen}
      setOpen={handleClose}
      title={`Call Tool: ${tool.name}`}
      subtitle={tool.description}
      size="lg"
    >
      <div className="space-y-4">
        <div>
          <h3 className="text-text mb-3 text-sm font-medium uppercase">
            PARAMETERS
          </h3>
          {tool.inputSchema?.properties ? (
            <div className="space-y-4">{generateFormFields()}</div>
          ) : (
            <p className="text-primary-400/80 text-sm">
              NO_PARAMETERS_REQUIRED
            </p>
          )}
        </div>

        <div className="flex justify-end">
          <Button onClick={handleCall} disabled={isLoading}>
            {isLoading ? "EXECUTING..." : "EXECUTE_TOOL"}
          </Button>
        </div>

        {error && (
          <Message type="error" title="ERROR">
            {error}
          </Message>
        )}

        {result && (
          <Message type="success" title="RESULT">
            <div className="text-sm">{formatResult(result)}</div>
          </Message>
        )}
      </div>
    </Modal>
  );
}

export default CallTool;
</file>

<file path="src/ui/mcp/McpOverview.tsx">
import { McpState } from "@ai/mcp/McpServer";
import useMcpServer from "@ai/mcp/react/useMcpServer";
import { Tool } from "@modelcontextprotocol/sdk/types.js";
import { ContentBox, Message } from "@theme";
import cn from "@utils/classnames";
import { useState } from "preact/hooks";

import AddHttpServer from "./AddHttpServer";
import CallTool from "./CallTool";
import McpPrompts from "./components/McpPrompts";
import McpResources from "./components/McpResources";
import McpServerHeader from "./components/McpServerHeader";
import McpTools from "./components/McpTools";

function McpOverview({ className = "" }: { className?: string }) {
  const { httpServers, builtinServers, error, updateServerConfig } =
    useMcpServer();
  const [callToolModal, setCallToolModal] = useState<{
    isOpen: boolean;
    server: any;
    tool: any;
  }>({
    isOpen: false,
    server: null,
    tool: null,
  });

  const handleToggleTool = (
    serverInfo: any,
    toolName: string,
    checked?: boolean
  ) => {
    const isActive = checked ?? !serverInfo.activeTools.includes(toolName);
    const newActiveTools = isActive
      ? [
          ...serverInfo.activeTools.filter((name: string) => name !== toolName),
          toolName,
        ]
      : serverInfo.activeTools.filter((name: string) => name !== toolName);

    updateServerConfig({
      ...serverInfo,
      activeTools: newActiveTools,
    });
  };

  const handleTogglePrompt = (
    serverInfo: any,
    promptName: string,
    checked?: boolean
  ) => {
    const isActive = checked ?? !serverInfo.activePrompts.includes(promptName);
    const newActivePrompts = isActive
      ? [
          ...serverInfo.activePrompts.filter(
            (name: string) => name !== promptName
          ),
          promptName,
        ]
      : serverInfo.activePrompts.filter((name: string) => name !== promptName);

    updateServerConfig({
      ...serverInfo,
      activePrompts: newActivePrompts,
    });
  };

  if (error) {
    return (
      <div className={cn(className, "relative")}>
        <div className="py-12 text-center">
          <Message
            type="error"
            title="Error Loading Servers"
            className="mx-auto max-w-md"
          >
            {error}
          </Message>
        </div>
      </div>
    );
  }

  const unifiedServers = [...builtinServers, ...httpServers];

  return (
    <div className={cn("space-y-6", className)}>
      <ContentBox>
        <AddHttpServer />
      </ContentBox>

      <div className="space-y-4">
        {unifiedServers.length === 0 ? (
          <ContentBox className="p-12 text-center">
            <p className="text-text-bright text-lg">NO_MCP_SERVERS_DETECTED</p>
            <p className="text-text/80 mt-2 text-sm">
              INITIALIZE_HTTP_SERVER_CONNECTION_ABOVE
            </p>
          </ContentBox>
        ) : (
          unifiedServers.map((serverInfo) => (
            <ContentBox
              key={serverInfo.name}
              header={<McpServerHeader serverInfo={serverInfo} />}
            >
              {serverInfo.active && serverInfo.server && (
                <>
                  {serverInfo.server.tools.length > 0 && (
                    <McpTools
                      tools={serverInfo.server.tools}
                      activeTools={serverInfo.activeTools}
                      serverId={serverInfo.name}
                      handleToggleTool={(toolName, checked) =>
                        handleToggleTool(serverInfo, toolName, checked)
                      }
                      openToolModal={(tool: Tool) =>
                        setCallToolModal({
                          isOpen: true,
                          server: serverInfo.server,
                          tool,
                        })
                      }
                      serverActive={serverInfo.state === McpState.READY}
                    />
                  )}

                  {serverInfo.server.resources.length > 0 && (
                    <McpResources resources={serverInfo.server.resources} />
                  )}

                  {serverInfo.server.prompts.length > 0 && (
                    <McpPrompts
                      prompts={serverInfo.server.prompts}
                      activePrompts={serverInfo.activePrompts}
                      serverId={serverInfo.name}
                      handleTogglePrompt={(promptName, checked) =>
                        handleTogglePrompt(serverInfo, promptName, checked)
                      }
                    />
                  )}
                </>
              )}
            </ContentBox>
          ))
        )}
      </div>

      {callToolModal.isOpen && callToolModal.server && callToolModal.tool && (
        <CallTool
          isOpen={callToolModal.isOpen}
          onClose={() =>
            setCallToolModal({ isOpen: false, server: null, tool: null })
          }
          server={callToolModal.server}
          tool={callToolModal.tool}
        />
      )}
    </div>
  );
}

export default McpOverview;
</file>

<file path="src/ui/mcp/TakePictureModal.tsx">
import ImageToText from "@ai/imageToText/ImageToText";
import { Crosshair, Modal } from "@theme";
import { eventEmitter } from "@utils/eventEmitter";
import { FunctionComponent } from "preact";
import { useEffect, useRef, useState } from "preact/hooks";

const TIMEOUT = 5;

const TakePictureModal: FunctionComponent = () => {
  const [isOpen, setIsOpen] = useState(false);
  const [query, setQuery] = useState<string>("");
  const [countdown, setCountdown] = useState<number | null>(3);
  const [isProcessing, setIsProcessing] = useState(false);
  const [capturedImageUrl, setCapturedImageUrl] = useState<string>("");
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const imageToTextRef = useRef<ImageToText | null>(null);

  useEffect(() => {
    // Initialize ImageToText instance
    imageToTextRef.current = new ImageToText();
    imageToTextRef.current.preload();

    const openModal = () => {
      setIsOpen(true);
      setCountdown(TIMEOUT);
      setIsProcessing(false);
      setCapturedImageUrl("");
    };

    const unsubscribe = eventEmitter.on("openTakePictureModal", (query) => {
      openModal();
      setQuery(query);
    });
    return () => unsubscribe();
  }, []);

  useEffect(() => {
    if (isOpen) {
      navigator.mediaDevices
        .getUserMedia({
          video: {
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            facingMode: "user",
          },
        })
        .then((stream) => {
          streamRef.current = stream;
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
          }
        })
        .catch((err) => {
          console.error("Error accessing camera:", err);
          eventEmitter.emit("takePictureError", "Error accessing camera");
          setIsOpen(false);
        });
    } else {
      if (streamRef.current) {
        streamRef.current.getTracks().forEach((track) => track.stop());
        streamRef.current = null;
      }
    }
  }, [isOpen]);

  useEffect(() => {
    if (countdown === null) return;

    if (countdown > 0) {
      const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
      return () => clearTimeout(timer);
    } else {
      takePicture();
    }
  }, [countdown]);

  const takePicture = async () => {
    if (videoRef.current) {
      const canvas = document.createElement("canvas");
      // Use the actual video dimensions, which should now be higher resolution
      const width = videoRef.current.videoWidth || 1920;
      const height = videoRef.current.videoHeight || 1080;

      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.drawImage(videoRef.current, 0, 0, width, height);

        const dataUrl = canvas.toDataURL("image/png", 1.0);
        setCapturedImageUrl(dataUrl);
        setIsProcessing(true);

        try {
          const prompt = query || "Describe this image in detail.";
          const imageDescription = await imageToTextRef.current.generate(
            dataUrl,
            prompt
          );

          // Emit the result
          eventEmitter.emit("pictureTaken", {
            imageData: dataUrl.split(",")[1],
            imageDescription,
          });
        } catch (e) {
          eventEmitter.emit(
            "takePictureError",
            "Failed to generate Description"
          );
        } finally {
          setIsOpen(false);
          setIsProcessing(false);
          setCapturedImageUrl("");
        }
      } else {
        eventEmitter.emit("takePictureError", "Failed to get canvas context");
      }
      setIsOpen(false);
      setCountdown(null);
    }
  };

  // @ts-ignore
  return (
    <Modal size="xl" open={isOpen} setOpen={setIsOpen} title="">
      <div className="border-primary-400/30 relative overflow-hidden border bg-black">
        {/* JARVIS-style header */}
        <div className="border-primary-400/30 from-primary-500/20 to-primary-500/20 border-b bg-gradient-to-r via-cyan-400/20 px-4 py-2">
          <div className="text-primary-300 flex items-center justify-between font-mono text-xs">
            <span>VISUAL_ACQUISITION_SYSTEM</span>
            <span className="animate-pulse">CAMERA_ACTIVE</span>
            <span>RES: 1920x1080</span>
          </div>
        </div>

        <div className="relative p-4">
          <div className="border-primary-400/50 relative overflow-hidden shadow-[0_0_30px_rgba(0,162,255,0.3)]">
            {/* Show captured image during processing, otherwise show video */}
            <div className="relative">
              {/* Countdown overlay */}
              <div className="absolute inset-0 z-20 flex flex-col items-center justify-center gap-8 bg-black/70">
                {countdown !== null && countdown > 0 && (
                  <>
                    <Crosshair />
                    <div className="text-center">
                      <div className="text-primary-300 animate-pulse font-mono text-xl">
                        ACQUIRING_TARGET_{countdown}
                      </div>
                    </div>
                  </>
                )}

                {/* Processing overlay */}
                {isProcessing && (
                  <div className="max-w-lg px-4 text-center">
                    <div className="text-primary-300 mb-2 animate-pulse font-mono text-lg">
                      PROCESSING_IMAGE...
                    </div>
                  </div>
                )}
              </div>

              {isProcessing && capturedImageUrl ? (
                <img
                  src={capturedImageUrl}
                  alt="Captured"
                  className="h-auto w-full brightness-110 contrast-110 filter"
                />
              ) : (
                <video
                  ref={videoRef}
                  autoPlay
                  playsInline
                  className="h-auto w-full brightness-110 contrast-110 filter"
                  onLoadedData={() => videoRef.current?.play()}
                />
              )}
            </div>
            {/* Scanning lines animation */}
            <div
              className="via-primary-400/10 absolute inset-0 h-1 animate-pulse bg-gradient-to-b from-transparent to-transparent"
              style={{
                animation: "scan 2s linear infinite",
                background:
                  "linear-gradient(to bottom, transparent, rgba(0,162,255,0.2), transparent)",
                height: "4px",
              }}
            />
          </div>

          {/* Status bar */}
          <div className="border-primary-400/30 bg-primary-950/20 text-primary-300 mt-4 flex items-center justify-between rounded border px-3 py-2 font-mono text-xs">
            <span>
              STATUS:{" "}
              {isProcessing
                ? "PROCESSING"
                : countdown !== null
                  ? "CAPTURING"
                  : "READY"}
            </span>
            <span>FOCAL_LENGTH: AUTO</span>
            <span>EXPOSURE: AUTO</span>
          </div>
        </div>
      </div>

      <style
        // @ts-ignore
        jsx="true"
      >{`
        @keyframes scan {
          0% {
            top: 0;
          }
          100% {
            top: 100%;
          }
        }
      `}</style>
    </Modal>
  );
};

export default TakePictureModal;
</file>

<file path="src/ui/DownLoadDisclaimer.tsx">
import { DownloadModelProgress } from "@ai/agentContext/AgentContext";
import useAgent from "@ai/agentContext/useAgent";
import { EXPECTED_FILES as EXPECTED_FILES_VLM } from "@ai/imageToText/constants";
import Conversation from "@ai/llm/Conversation";
import { TextGeneration } from "@ai/llm/textGeneration";
import { EXPECTED_FILES as EXPECTED_FILES_STT } from "@ai/speechToText/constants";
import { EXPECTED_FILES as EXPECTED_FILES_TTS } from "@ai/textToSpeech/kokoro/constants";
import { ArrowDownTrayIcon } from "@heroicons/react/16/solid";
import { Button, ContentBox, Progress } from "@theme";
import formatBytes from "@utils/formatBytes";
import { useState } from "preact/hooks";

TextGeneration.model_id = "Qwen3-4B";

const VAD_SIZE = 2243022;
const LLM_SIZE = Conversation.downloadSize;
const TTS_SIZE = Object.values(EXPECTED_FILES_TTS).reduce(
  (acc, size) => acc + size,
  0
);
const STT_SIZE = Object.values(EXPECTED_FILES_STT).reduce(
  (acc, size) => acc + size,
  0
);
const VLM_SIZE = Object.values(EXPECTED_FILES_VLM).reduce(
  (acc, size) => acc + size,
  0
);

const getModel = (
  key: string
): {
  taskName: string;
  name: string;
  size: number;
  url: string;
} => {
  switch (key) {
    case "vad":
      return {
        taskName: "VOICE_ACTIVITY_DETECTION",
        name: "Silero VAD",
        size: VAD_SIZE,
        url: "https://github.com/snakers4/silero-vad",
      };
    case "llm":
      return {
        taskName: "LARGE_LANGUAGE_MODEL",
        name: "Qwen3 4B",
        size: LLM_SIZE,
        url: "https://github.com/snakers4/silero-vad",
      };
    case "tts":
      return {
        taskName: "SPEECH_SYNTHESIS",
        name: "Kokoro",
        size: TTS_SIZE,
        url: "https://huggingface.co/hexgrad/Kokoro-82M",
      };
    case "stt":
      return {
        taskName: "SPEECH_RECOGNITION",
        name: "Whisper Base",
        size: STT_SIZE,
        url: "https://huggingface.co/openai/whisper-base",
      };
    case "vlm":
      return {
        taskName: "VISION_LANGUAGE_MODEL",
        name: "SmolVLM 256M",
        size: VLM_SIZE,
        url: "https://huggingface.co/HuggingFaceTB/SmolVLM-256M-Instruct",
      };
    default:
      return null;
  }
};

export default function DownLoadDisclaimer({}: {}) {
  const [isDownloading, setIsDownloading] = useState<boolean>(false);
  const { loadModels } = useAgent();
  const [progress, setProgress] = useState<DownloadModelProgress>({
    vad: 0,
    llm: 0,
    tts: 0,
    stt: 0,
    vlm: 0,
  });

  const download = async () => {
    setIsDownloading(true);
    await loadModels((progress) => {
      setProgress(progress);
    });
    setIsDownloading(false);
  };

  return (
    <div>
      <ContentBox className="space-y-4">
        <h3 className="text-sm font-medium">WELCOME_TO_JARVIS</h3>
        <p>
          Jarvis is a sophisticated AI agent that leverages cutting-edge
          on-device AI models and integrates seamlessly with various tools
          through the Model Context Protocol (MCP). Unlike cloud-dependent
          assistants, Jarvis operates locally on your device, ensuring privacy,
          speed, and reliability while providing intelligent assistance for your
          daily tasks.
        </p>
        <p>
          Everything runs entirely in your browser with{" "}
          <a
            className="underline"
            href="https://huggingface.co/docs/transformers.js/index"
          >
            Transformers.js
          </a>{" "}
          and ONNX Runtime Web, meaning no data is sent to a server. It can even
          run offline!
        </p>
        <div className="my-16 flex w-full items-center justify-center">
          {isDownloading ? (
            <ul className="w-full">
              {Object.entries(progress).map(([key, progress]) => {
                const model = getModel(key);
                return !model ? null : (
                  <li className="mt-6 flex w-full flex-col gap-2">
                    <p>
                      {model.taskName} - {progress}%
                      <br />
                      <span className="text-text-bright text-xs">
                        <a
                          className="underline"
                          target="_blank"
                          href={model.url}
                        >
                          {model.name}
                        </a>{" "}
                        ({formatBytes(model.size)})
                      </span>
                    </p>
                    <Progress value={progress} />
                  </li>
                );
              })}
            </ul>
          ) : (
            <Button
              iconLeft={<ArrowDownTrayIcon width="1.25em" />}
              onClick={download}
            >
              Download required models (‚âà{" "}
              {formatBytes(
                VAD_SIZE + LLM_SIZE + TTS_SIZE + STT_SIZE + VLM_SIZE
              )}
              )
            </Button>
          )}
        </div>
      </ContentBox>
    </div>
  );
}
</file>

<file path="src/utils/classnames.ts">
const cn = (...classes: Array<Record<string, boolean> | string>): string =>
  classes
    .map((entry) =>
      typeof entry === "string"
        ? entry
        : Object.entries(entry || {})
            .filter(([, append]) => append)
            .map(([cl]) => cl)
            .join(" ")
    )
    .filter((e) => e !== "")
    .join(" ");
export default cn;
</file>

<file path="src/utils/constants.ts">
export const MCP_SERVERS_STORAGE_KEY = "mcp:servers";
export const MCP_BUILTIN_SERVERS_STORAGE_KEY = "mcp:builtin_servers";
</file>

<file path="src/utils/eventEmitter.ts">
type Listener = (...args: any[]) => void;

class EventEmitter {
  private events: { [key: string]: Listener[] } = {};

  on(event: string, listener: Listener): () => void {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    return () => this.off(event, listener);
  }

  off(event: string, listener: Listener): void {
    if (!this.events[event]) {
      return;
    }
    this.events[event] = this.events[event].filter((l) => l !== listener);
  }

  emit(event: string, ...args: any[]): void {
    if (!this.events[event]) {
      return;
    }
    this.events[event].forEach((listener) => listener(...args));
  }
}

export const eventEmitter = new EventEmitter();
</file>

<file path="src/utils/extractFunctionCall.ts">
const extractFunctionCall = (
  text: string
): { functionName: string; parameters: Record<string, any> } | null => {
  const functionCallRegex =
    /<functionCall>\s*<name>([^<]+)<\/name>\s*<parameters>(.*?)<\/parameters>\s*<\/functionCall>/s;
  const match = text.match(functionCallRegex);

  if (!match) return null;

  const functionName = match[1].trim();
  const parametersXml = match[2].trim();

  const parameters: Record<string, any> = {};
  const paramRegex = /<(\w+)\s+type="([^"]+)">([^<]*)<\/\1>/g;
  let paramMatch;

  while ((paramMatch = paramRegex.exec(parametersXml)) !== null) {
    const [, paramName, type, value] = paramMatch;
    parameters[paramName] = value;
  }

  return { functionName, parameters };
};

export default extractFunctionCall;
</file>

<file path="src/utils/extractSentences.ts">
const extractSentences = (text: string): string[] => {
  if (!text || text.trim().length === 0) {
    return [];
  }
  // Common abbreviations that end with periods but don't end sentences
  const abbreviations = new Set([
    "mr",
    "mrs",
    "ms",
    "dr",
    "prof",
    "sr",
    "jr",
    "vs",
    "etc",
    "inc",
    "ltd",
    "corp",
    "co",
    "st",
    "ave",
    "blvd",
    "rd",
    "dept",
    "univ",
    "assn",
    "bros",
    "ph.d",
    "m.d",
    "b.a",
    "m.a",
    "phd",
    "md",
    "ba",
    "ma",
    "bsc",
    "msc",
    "llb",
    "llm",
    "a.m",
    "p.m",
    "am",
    "pm",
    "e.g",
    "i.e",
    "cf",
    "et",
    "al",
    "ibid",
    "jan",
    "feb",
    "mar",
    "apr",
    "may",
    "jun",
    "jul",
    "aug",
    "sep",
    "oct",
    "nov",
    "dec",
  ]);

  // Split on sentence-ending punctuation followed by whitespace or end of string
  const sentenceRegex = /([.!?]+)(\s+|$)/g;
  const parts: string[] = [];
  let lastIndex = 0;
  let match;

  while ((match = sentenceRegex.exec(text)) !== null) {
    const endPunctuation = match[1];
    const followingWhitespace = match[2];
    const sentenceEnd = match.index + endPunctuation.length;

    // Extract the potential sentence
    const potentialSentence = text.substring(lastIndex, sentenceEnd).trim();

    if (potentialSentence.length === 0) {
      continue;
    }

    // Check if this is likely a real sentence ending
    let isRealSentenceEnd = true;

    // Handle ellipsis - if we have 3 or more dots, it's likely not a sentence end
    if (endPunctuation.includes(".") && endPunctuation.length >= 3) {
      isRealSentenceEnd = false;
    }
    // Handle single dots - check for abbreviations
    else if (endPunctuation === ".") {
      // Look for word before the period
      const beforePeriod = potentialSentence.substring(
        0,
        potentialSentence.length - 1
      );
      const lastWordMatch = beforePeriod.match(/\b(\w+)$/i);

      if (lastWordMatch) {
        const lastWord = lastWordMatch[1].toLowerCase();

        // Check if it's a known abbreviation
        if (abbreviations.has(lastWord)) {
          isRealSentenceEnd = false;
        }
        // Check for initials (single letters)
        else if (lastWord.length === 1) {
          isRealSentenceEnd = false;
        }
        // Check for numbers (decimal numbers, versions, etc.)
        else if (/^\d+$/.test(lastWord)) {
          // Look ahead to see if next character after whitespace is a digit
          const nextChar = text.charAt(
            sentenceEnd + followingWhitespace.length
          );
          if (/\d/.test(nextChar)) {
            isRealSentenceEnd = false;
          }
        }
      }

      // Additional check: if the next word starts with lowercase, probably not sentence end
      if (isRealSentenceEnd && followingWhitespace.trim().length > 0) {
        const nextWordStart = sentenceEnd + followingWhitespace.length;
        const nextChar = text.charAt(nextWordStart);
        if (nextChar && /[a-z]/.test(nextChar)) {
          isRealSentenceEnd = false;
        }
      }
    }

    if (isRealSentenceEnd) {
      parts.push(potentialSentence);
      lastIndex = sentenceEnd + followingWhitespace.length;
    }
  }

  // Add any remaining text only if it appears to be a complete sentence
  const remainingText = text.substring(lastIndex).trim();
  if (remainingText.length > 0) {
    // Check if the remaining text ends with sentence-ending punctuation
    if (/[.!?]+$/.test(remainingText)) {
      // If it ends with a period, check if it's likely an abbreviation
      if (remainingText.endsWith(".")) {
        const beforePeriod = remainingText.substring(
          0,
          remainingText.length - 1
        );
        const lastWordMatch = beforePeriod.match(/\b(\w+)$/i);

        let isCompletesentence = true;

        if (lastWordMatch) {
          const lastWord = lastWordMatch[1].toLowerCase();

          // If it's a known abbreviation or single letter, it's likely incomplete
          if (abbreviations.has(lastWord) || lastWord.length === 1) {
            isCompletesentence = false;
          }
        }

        if (isCompletesentence) {
          parts.push(remainingText);
        }
      } else {
        // Ends with ! or ?, definitely complete
        parts.push(remainingText);
      }
    }
    // If it doesn't end with punctuation, it's likely incomplete - don't include it
  }

  return parts.filter((sentence) => sentence.length > 0);
};

export default extractSentences;
</file>

<file path="src/utils/formatBytes.ts">
const formatBytes = (bytes: number, decimals: number = 2): string => {
  if (bytes === 0) return "0 Bytes";

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
};

export default formatBytes;
</file>

<file path="src/utils/isFileInCache.ts">
const isFileInCache = async (
  cacheName: string,
  fileUrl: string
): Promise<boolean> => {
  try {
    // Open the specific cache named 'transformers-cache'
    const cache = await caches.open(cacheName);

    // Check if the file exists in the cache
    const response = await cache.match(fileUrl);

    // Return true if found, false if not
    return response !== undefined;
  } catch (error) {
    console.error("Error checking cache:", error);
    return false;
  }
};

export default isFileInCache;
</file>

<file path="src/utils/isFullSentence.ts">
const isFullSentence = (snippet: string): string | null => {
  // Common abbreviations that end with periods but don't end sentences
  const abbreviations = new Set([
    "mr",
    "mrs",
    "ms",
    "dr",
    "prof",
    "sr",
    "jr",
    "vs",
    "etc",
    "inc",
    "ltd",
    "corp",
    "co",
    "st",
    "ave",
    "blvd",
    "rd",
    "dept",
    "univ",
    "assn",
    "bros",
    "ph.d",
    "m.d",
    "b.a",
    "m.a",
    "phd",
    "md",
    "ba",
    "ma",
    "bsc",
    "msc",
    "llb",
    "llm",
    "a.m",
    "p.m",
    "am",
    "pm",
    "e.g",
    "i.e",
    "cf",
    "et",
    "al",
    "ibid",
    "jan",
    "feb",
    "mar",
    "apr",
    "may",
    "jun",
    "jul",
    "aug",
    "sep",
    "oct",
    "nov",
    "dec",
  ]);

  // Trim whitespace
  const trimmed = snippet.trim();

  // Check if empty
  if (!trimmed) {
    return null;
  }

  // Check if it ends with proper sentence-ending punctuation
  const endsWithPunctuation = /[.!?]$/.test(trimmed);

  if (!endsWithPunctuation) {
    return null;
  }

  // If it ends with a period, check if it's likely an abbreviation
  if (trimmed.endsWith(".")) {
    const beforePeriod = trimmed.substring(0, trimmed.length - 1);
    const lastWordMatch = beforePeriod.match(/\b(\w+)$/i);

    if (lastWordMatch) {
      const lastWord = lastWordMatch[1].toLowerCase();
      
      // Check if it's a known abbreviation
      if (abbreviations.has(lastWord)) {
        return null;
      }
      
      // Check for initials (single letters)
      if (lastWord.length === 1) {
        return null;
      }
    }
  }

  // Check if it starts with a capital letter or number
  const startsCorrectly = /^[A-Z0-9"'(]/.test(trimmed);

  if (!startsCorrectly) {
    return null;
  }

  // Check if it contains at least one word (letters/numbers)
  const hasWords = /[a-zA-Z0-9]/.test(trimmed);

  if (!hasWords) {
    return null;
  }

  // Basic check for balanced quotes (simple version)
  const quoteCount = (trimmed.match(/"/g) || []).length;
  const singleQuoteCount = (trimmed.match(/'/g) || []).length;

  // If quotes exist, they should be balanced (even number)
  if (quoteCount % 2 !== 0) {
    return null;
  }

  return trimmed;
};

export default isFullSentence;
</file>

<file path="src/utils/isFullXMLToolCall.ts">
import { XMLToolSignature } from "@ai/types";

const isFullXMLToolCall = (snippet: string): XMLToolSignature => {
  const functionCallRegex =
    /<functionCall>\s*<name>([^<]+)<\/name>\s*<parameters>(.*?)<\/parameters>\s*<\/functionCall>/s;

  const match = functionCallRegex.exec(snippet);

  if (!match) {
    return null;
  }

  const functionName = match[1].trim();
  const parametersXml = match[2].trim();
  const parameters: Record<string, any> = {};

  const paramRegex = /<(\w+)\s+type="([^"]+)">([^<]*)<\/\1>/g;
  let paramMatch;

  while ((paramMatch = paramRegex.exec(parametersXml)) !== null) {
    const [, paramName, type, value] = paramMatch;
    parameters[paramName] = value;
  }

  return { functionName, parameters };
};

export default isFullXMLToolCall;
</file>

<file path="src/utils/LocalStorage.ts">
type LocalStorageCallback<T> = (
  key: string,
  newValue: T | null,
  oldValue: T | null
) => void;

class LocalStorageManager {
  private callbacks: Map<string, Set<LocalStorageCallback<any>>> = new Map();
  private values: Map<string, any> = new Map();

  constructor() {
    for (let i = 0; i < window.localStorage.length; i++) {
      const key = window.localStorage.key(i);
      if (key) {
        try {
          const value = JSON.parse(window.localStorage.getItem(key) || "null");
          this.values.set(key, value);
        } catch {
          // Handle non-JSON values
          this.values.set(key, window.localStorage.getItem(key));
        }
      }
    }

    window.addEventListener("storage", this.handleStorageEvent.bind(this));
  }

  private handleStorageEvent(event: StorageEvent) {
    if (event.key && event.storageArea === window.localStorage) {
      const oldValue = this.values.get(event.key) || null;
      let newValue: any = null;

      if (event.newValue) {
        try {
          newValue = JSON.parse(event.newValue);
        } catch {
          newValue = event.newValue;
        }
      }

      this.values.set(event.key, newValue);
      this.notifyCallbacks(event.key, newValue, oldValue);
    }
  }

  private notifyCallbacks<T>(
    key: string,
    newValue: T | null,
    oldValue: T | null
  ) {
    const keyCallbacks = this.callbacks.get(key);
    if (keyCallbacks) {
      keyCallbacks.forEach((callback) => {
        try {
          callback(key, newValue, oldValue);
        } catch (error) {
          console.error("Error in localStorage callback:", error);
        }
      });
    }
  }

  setItem<T>(key: string, value: T): void {
    const oldValue = this.values.get(key) || null;
    const serializedValue = JSON.stringify(value);

    window.localStorage.setItem(key, serializedValue);
    this.values.set(key, value);

    this.notifyCallbacks(key, value, oldValue);
  }

  getItem<T>(key: string): T | null {
    const stored = window.localStorage.getItem(key);
    if (stored === null) return null;

    try {
      return JSON.parse(stored) as T;
    } catch (error) {
      console.error(`Failed to parse localStorage item "${key}":`, error);
      return null;
    }
  }

  removeItem(key: string): void {
    const oldValue = this.values.get(key) || null;
    window.localStorage.removeItem(key);
    this.values.delete(key);

    this.notifyCallbacks(key, null, oldValue);
  }

  onItemChange<T>(key: string, callback: LocalStorageCallback<T>): () => void {
    if (!this.callbacks.has(key)) {
      this.callbacks.set(key, new Set());
    }

    const keyCallbacks = this.callbacks.get(key)!;
    keyCallbacks.add(callback);

    return () => {
      keyCallbacks.delete(callback);
      if (keyCallbacks.size === 0) {
        this.callbacks.delete(key);
      }
    };
  }

  clear(): void {
    const oldValues = new Map(this.values);
    window.localStorage.clear();
    this.values.clear();

    oldValues.forEach((oldValue, key) => {
      this.notifyCallbacks(key, null, oldValue);
    });
  }
}

export const localStorage = new LocalStorageManager();
export default localStorage;
</file>

<file path="src/utils/nl2brJsx.tsx">
import { JSX } from "preact";

const nl2brJsx = (text: string): JSX.Element[] => {
  const lines = text.split("\n");
  // remove leading empty lines
  while (lines.length > 0 && lines[0] === "") {
    lines.shift();
  }
  // remove trailing empty lines
  while (lines.length > 0 && lines[lines.length - 1] === "") {
    lines.pop();
  }
  return lines.map((line, index) => (
    <span key={index} className="block">
      {line || <br />}
    </span>
  ));
};

export default nl2brJsx;
</file>

<file path="src/utils/useExternalState.ts">
import { useEffect, useRef, useState } from "preact/hooks";

export default function useExternalState<T = any>(
  subscribe: (listener: (state: T) => void) => () => void,
  getState: () => T
) {
  const [state, setState] = useState<T>(getState());
  const prevStateRef = useRef<T>(state);

  useEffect(() => {
    const unsubscribe = subscribe(() => {
      const newState = getState();
      if (newState !== prevStateRef.current) {
        setState(newState);
        prevStateRef.current = newState;
      }
    });
    return () => unsubscribe();
  }, []);

  return state;
}
</file>

<file path="src/utils/useStableValue.ts">
import { useEffect, useState } from "preact/hooks";

function useStableValue<T>(value: T, delay: number = 200): T {
  const [debouncedValue, setDebouncedValue] = useState<T | null>(null);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value]);

  return debouncedValue;
}

export default useStableValue;
</file>

<file path="src/App.tsx">
import AgentContextProvider from "@ai/agentContext/AgentContextProvider";
import { McpServerContextProvider } from "@ai/mcp/react/McpServerContextProvider";
import { Background } from "@theme";
import Router, { Route } from "preact-router";
import { Toaster } from "react-hot-toast";

import ChatPage from "./pages/ChatPage";
import McpPage from "./pages/McpPage";
import OAuthCallbackPage from "./pages/OAuthCallbackPage";
import TakePictureModal from "./ui/mcp/TakePictureModal";

function App() {
  return (
    <McpServerContextProvider>
      <AgentContextProvider>
        <Background />
        <Router>
          <Route path="/" component={ChatPage} />
          <Route path="/mcp" component={McpPage} />
          <Route path="/oauth/callback" component={OAuthCallbackPage} />
        </Router>
        <Toaster
          position="bottom-right"
          reverseOrder={false}
          containerClassName="!right-8 !bottom-26"
        />
        <TakePictureModal />
      </AgentContextProvider>
    </McpServerContextProvider>
  );
}

export default App;
</file>

<file path="src/index.css">
@import "tailwindcss";

@theme {
  --default-font-family: var(--font-mono);
  --color-text: var(--color-blue-300);
  --color-text-bright: var(--color-blue-100);
  --color-text-superbright: var(--color-white);

  --color-primary-50: var(--color-blue-50);
  --color-primary-100: var(--color-blue-100);
  --color-primary-200: var(--color-blue-200);
  --color-primary-300: var(--color-blue-300);
  --color-primary-400: var(--color-blue-400);
  --color-primary-500: var(--color-blue-500);
  --color-primary-600: var(--color-blue-600);
  --color-primary-700: var(--color-blue-700);
  --color-primary-800: var(--color-blue-800);
  --color-primary-900: var(--color-blue-900);
  --color-primary-950: var(--color-blue-950);

  /*  --color-primary-50: var(--color-red-50);
  --color-primary-100: var(--color-red-100);
  --color-primary-200: var(--color-red-200);
  --color-primary-300: var(--color-red-300);
  --color-primary-400: var(--color-red-400);
  --color-primary-500: var(--color-red-500);
  --color-primary-600: var(--color-red-600);
  --color-primary-700: var(--color-red-700);
  --color-primary-800: var(--color-red-800);
  --color-primary-900: var(--color-red-900);
  --color-primary-950: var(--color-red-950);*/

  --color-secondary-50: var(--color-green-50);
  --color-secondary-100: var(--color-green-100);
  --color-secondary-200: var(--color-green-200);
  --color-secondary-300: var(--color-green-300);
  --color-secondary-400: var(--color-green-400);
  --color-secondary-500: var(--color-green-500);
  --color-secondary-600: var(--color-green-600);
  --color-secondary-700: var(--color-green-700);
  --color-secondary-800: var(--color-green-800);
  --color-secondary-900: var(--color-green-900);
  --color-secondary-950: var(--color-green-950);
}

html {
  color: var(--color-text);
}

.scrollbar-hide {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

.scrollbar-hide::-webkit-scrollbar {
  display: none;
}
</file>

<file path="src/main.tsx">
import { render } from 'preact'
import App from './App'
import './index.css'

render(<App />, document.getElementById('root')!)
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path=".env.example">
# SSL configuration (optional)
SSL_KEY=
SSL_CRT=

# Server port (optional, defaults to 8080)
PORT=8844
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.env
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="/src/index.css" rel="stylesheet">
    <title></title>
  </head>
  <body class="bg-stone-200">
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Nicolas Martin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="package.json">
{
  "name": "jarvis",
  "version": "0.1.11",
  "description": "",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview",
    "format": "prettier --write .",
    "prepare": "husky",
    "prod": "node scripts/serverProd.mjs"
  },
  "keywords": [],
  "author": "Nico Martin <mail@nico.dev>",
  "license": "MIT",
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@headlessui/react": "^2.2.5",
    "@heroicons/react": "^2.2.0",
    "@huggingface/transformers": "3.7.3",
    "@modelcontextprotocol/sdk": "^1.17.0",
    "@tailwindcss/vite": "^4.1.11",
    "phonemizer": "^1.2.1",
    "preact": "^10.25.4",
    "preact-router": "^4.1.2",
    "react-hot-toast": "^2.5.2",
    "strict-url-sanitise": "^0.0.1",
    "uuid": "^11.1.0",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "devDependencies": {
    "@eslint/js": "^9.31.0",
    "@preact/preset-vite": "^2.9.4",
    "@tailwindcss/postcss": "^4.1.11",
    "@trivago/prettier-plugin-sort-imports": "^5.2.2",
    "@types/dom-chromium-ai": "^0.0.9",
    "@types/node": "^24.0.14",
    "@webgpu/types": "^0.1.64",
    "autoprefixer": "^10.4.21",
    "dotenv": "^17.2.0",
    "eslint": "^9.31.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "husky": "^9.1.7",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "prettier-plugin-tailwindcss": "^0.6.14",
    "tailwindcss": "^4.1.11",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.37.0",
    "vite": "^7.0.5",
    "vite-plugin-html-config": "^2.0.2"
  },
  "prettier": {
    "plugins": [
      "@trivago/prettier-plugin-sort-imports",
      "prettier-plugin-tailwindcss"
    ],
    "singleQuote": false,
    "trailingComma": "es5",
    "importOrder": [
      "<THIRD_PARTY_MODULES>",
      "^[./]"
    ],
    "importOrderSeparation": true,
    "importOrderSortSpecifiers": true
  }
}
</file>

<file path="README.md">
# JARVIS

A modern AI assistant web application featuring voice interaction, real-time conversation, and MCP (Model Context Protocol) server integration.

## Features

- **Voice Interaction**: Voice activity detection, speech-to-text, and text-to-speech capabilities
- **Real-time Chat**: Interactive conversation interface with AI assistant
- **MCP Server Integration**: Connect and interact with Model Context Protocol servers
- **Image-to-Text**: Convert images to text descriptions
- **Multi-modal Interface**: Switch between voice-activated JARVIS mode and traditional chat
- **Browser-based AI**: Runs locally in your browser using WebGPU and language model APIs

## Tech Stack

- **Framework**: Preact with TypeScript
- **Styling**: Tailwind CSS
- **AI/ML**: Transformers.js
- **Build Tool**: Vite
- **MCP**: Model Context Protocol SDK for server integrations

## Getting Started

### Prerequisites

- Node.js (version 18 or higher)
- Modern browser with WebGPU support

### Installation

1. Clone the repository:
```bash
git clone <repository-url>
cd jarvis
```

2. Install dependencies:
```bash
npm install
```

3. Start the development server:
```bash
npm run dev
```

4. Open your browser and navigate to `http://localhost:8080`

## Scripts

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run lint` - Run ESLint
- `npm run format` - Format code with Prettier
- `npm run preview` - Preview production build

## Usage

### JARVIS Mode
- Click to activate voice interaction
- Speak naturally to interact with the AI assistant
- Visual rings indicate voice activity and responses

### Chat Mode
- Switch to traditional text-based chat interface
- Type messages and receive AI responses

### MCP Settings
- Navigate to `/mcp` to configure Model Context Protocol servers
- Add HTTP servers for extended functionality
- Manage server connections and available tools

## License

MIT License - see [LICENSE](LICENSE) file for details.

## Author

Nicolas Martin (mail@nico.dev)
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": [
      "DOM",
      "DOM.Iterable",
      "ESNext"
    ],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "strictNullChecks": false,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    "paths": {
      "@theme": [
        "./src/theme/index.ts"
      ],
      "@utils/*": [
        "./src/utils/*"
      ],
      "@ai/*": [
        "./src/ai/*"
      ],
      "@ui/*": [
        "./src/ui/*"
      ]
    }
  },
  "include": [
    "src"
  ],
  "references": [
    {
      "path": "./tsconfig.node.json"
    }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import preact from "@preact/preset-vite";
import tailwindcss from "@tailwindcss/vite";
import dotenv from "dotenv";
import fs from "fs";
import { defineConfig } from "vite";
import htmlPlugin from "vite-plugin-html-config";
import tsconfigPaths from "vite-tsconfig-paths";

dotenv.config();

const TITLE = "Jarvis - your private, personal assistant";

export default defineConfig({
  worker: {
    format: "es",
  },
  server: {
    ...(fs.existsSync(process.env.SSL_KEY || "") &&
    fs.existsSync(process.env.SSL_CRT || "")
      ? {
          https: {
            key: fs.readFileSync(process.env.SSL_KEY || ""),
            cert: fs.readFileSync(process.env.SSL_CRT || ""),
          },
        }
      : {}),
    port: process.env.PORT ? parseInt(process.env.PORT) : 8080,
  },
  plugins: [
    preact(),
    tsconfigPaths(),
    tailwindcss(),
    htmlPlugin({
      title: TITLE,
    }),
  ],
});
</file>

</files>
